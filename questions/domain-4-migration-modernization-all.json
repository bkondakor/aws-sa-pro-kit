{
  "domain": "Domain 4: Accelerate Workload Migration and Modernization",
  "total_questions": 40,
  "tasks": {
    "task_4.1_migration_selection": {
      "question_count": 10,
      "questions": [
        {
          "id": "D4-T4.1-Q1",
          "question": "A company has 200 on-premises servers running mixed workloads. They need to determine migration strategy (rehost, replatform, refactor) for each workload. Which AWS service provides automated assessment with TCO calculations and migration strategy recommendations?",
          "options": [
            "AWS Application Discovery Service for inventory collection",
            "AWS Migration Evaluator (formerly TSO Logic) for right-sizing and TCO analysis with strategy recommendations",
            "AWS Migration Hub for migration tracking",
            "AWS Database Migration Service for database assessment"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Migration Evaluator provides comprehensive migration planning: (1) Agentless data collection from on-premises environment (CPU, memory, storage, network utilization), (2) Pattern analysis over 30+ days, (3) Right-sizing recommendations for AWS (EC2 instance types, storage options), (4) TCO comparison (on-premises vs AWS with 3-year projection), (5) Migration strategy recommendations based on: complexity, dependencies, quick wins vs long-term optimization. Evaluator considers: current utilization patterns, AWS pricing (On-Demand, Reserved, Savings Plans), cost of migration tools, operational efficiency gains. Option A (Application Discovery Service) collects data but doesn't provide TCO analysis or strategy recommendations. Option C (Migration Hub) tracks migrations but doesn't assess/recommend. Option D (DMS) is specific to database migration."
        },
        {
          "id": "D4-T4.1-Q2",
          "question": "Database migration assessment shows Oracle database with custom stored procedures, PL/SQL packages, and Oracle-specific features. Target is PostgreSQL on Aurora. What's the FIRST step in migration planning?",
          "options": [
            "Use AWS Database Migration Service to start replicating data immediately",
            "Run AWS Schema Conversion Tool (SCT) to analyze schema compatibility and generate conversion assessment report",
            "Manually rewrite all stored procedures in PostgreSQL",
            "Migrate to RDS Oracle first, then to Aurora PostgreSQL"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Schema Conversion Tool (SCT) is essential for heterogeneous database migration: (1) Connects to source Oracle database, (2) Analyzes schema, stored procedures, functions, triggers, (3) Generates assessment report showing: automatic conversion percentage (e.g., 85% auto-convertible), manual effort required, incompatible features, complexity score, estimated effort (person-days). (4) Converts schema to PostgreSQL equivalent, (5) Highlights items requiring manual intervention. Assessment report guides: Go/no-go decision, effort estimation, resource planning. For this scenario: SCT identifies which PL/SQL can convert automatically vs manual rewrite needed. Option A (immediate DMS) fails without schema conversion - target schema must exist before data migration. Option C (manual rewrite) without assessment is inefficient. Option D (staged migration) adds unnecessary step. Migration phases: Assess (SCT report), Convert (SCT conversion + manual fixes), Migrate data (DMS), Test, Cutover."
        },
        {
          "id": "D4-T4.1-Q3",
          "question": "A retail company must decide migration strategy for mainframe application processing transactions. Application is business-critical, poorly documented, and contains COBOL code. Which 7 R's strategy is MOST appropriate initially?",
          "options": [
            "Rehost (lift-and-shift) to EC2",
            "Refactor to microservices architecture",
            "Replatform using AWS Mainframe Modernization",
            "Retire the application and build new in cloud"
          ],
          "correctAnswer": 2,
          "explanation": "AWS Mainframe Modernization (Replatform) is appropriate for mainframe migrations: Service provides: (1) Automated refactoring (converts COBOL to Java) or Replatform (runtime environment for COBOL on AWS), (2) Managed runtime environment, (3) Migration tools, (4) Reduced risk vs full refactor. For business-critical, poorly documented system: Replatform minimizes risk - application logic stays in COBOL, runs on AWS infrastructure. Option A (Rehost) doesn't apply to mainframes - can't lift-and-shift mainframe to EC2. Option B (Refactor) is high-risk for undocumented critical system - requires understanding entire codebase. Option D (Retire/rebuild) is risky without knowing all business logic. 7 R's: Rehost (lift-and-shift), Replatform (lift-tinker-shift), Refactor (re-architect), Repurchase (move to SaaS), Retire (decommission), Retain (keep on-premises), Relocate (VMware Cloud on AWS). Mainframe modernization phases: Assess (analyze code dependencies), Refactor or Replatform (choose approach), Test (functional, performance), Train (operations team), Cutover."
        }
      ]
    },
    "task_4.2_migration_approach": {
      "question_count": 12,
      "questions": [
        {
          "id": "D4-T4.2-Q1",
          "question": "Large-scale server migration (500 physical servers) requires replication-based migration with minimal downtime. Applications are heterogeneous (Windows, Linux, various databases). Which AWS service is MOST appropriate?",
          "options": [
            "AWS Application Migration Service (MGN) with continuous replication and cutover orchestration",
            "AWS Server Migration Service (SMS) - deprecated, not recommended",
            "CloudEndure Migration (now part of MGN)",
            "Manual VM export/import to EC2"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Application Migration Service (MGN) is the current recommended solution for replication-based migration: (1) Agent installed on source servers, (2) Continuous block-level replication to AWS (staging area in AWS), (3) Minimal performance impact on source systems, (4) Non-disruptive testing (launch test instances without affecting replication), (5) Cutover automation (switch from source to migrated), (6) Automated conversion (source volumes to EBS, network config). MGN supports: Windows, Linux, Physical servers, VMware, Hyper-V, Azure VMs. Replication RTO: minutes (failover to already-replicated instances), RPO: seconds (near real-time replication). Option B (SMS) deprecated December 2022 - replaced by MGN. Option C (CloudEndure) was acquired by AWS, became MGN. Option D (manual) doesn't scale. MGN migration phases: Install agent, Initial sync (full replication), Continuous data replication, Test (launch test instance), Cutover (redirect traffic), Finalize (terminate replication)."
        },
        {
          "id": "D4-T4.2-Q2",
          "question": "MySQL database (5TB) must migrate from on-premises to RDS with minimal downtime (<30 minutes). Database receives constant updates. Which DMS configuration achieves this?",
          "options": [
            "DMS full load only (long downtime for 5TB)",
            "DMS full load + CDC (ongoing replication) with cutover during low-traffic window",
            "Export to S3, then import to RDS",
            "Use AWS Snowball for data transfer, then DMS for incremental sync"
          ],
          "correctAnswer": 1,
          "explanation": "DMS full load + CDC (Change Data Capture) minimizes downtime: (1) DMS replication instance created in AWS, (2) Full load begins (copy all existing data while source remains online), (3) CDC captures changes during full load (binary logs for MySQL), (4) After full load complete, CDC applies captured changes (replication lag decreases), (5) When lag is near zero (seconds), cutover: stop application, apply final changes, redirect application to RDS. Downtime = time to apply final changes + DNS/connection string update (< 30 minutes achievable). Option A (full load only) requires stopping source during entire migration (hours for 5TB). Option C (S3 export/import) similar downtime issue. Option D (Snowball) for large initial sync works but unnecessary complexity for 5TB over network. DMS CDC uses database transaction logs: MySQL binary logs, Oracle archive logs, PostgreSQL WAL. Prerequisites: binary logging enabled, appropriate permissions (replication slave for MySQL). DMS homogeneous vs heterogeneous: homogeneous (MySQL → RDS MySQL) uses native tools, heterogeneous (Oracle → PostgreSQL) requires schema conversion. DMS performance: Multi-AZ for HA, choose appropriate instance size (r5 for memory-intensive, c5 for CPU), monitor CloudWatch metrics (CDCLatencySource, CDCLatencyTarget)."
        },
        {
          "id": "D4-T4.2-Q3",
          "question": "500TB file server data must migrate to AWS. Network bandwidth: 100 Mbps (takes 5+ months). Data must be available in AWS within 2 weeks. What's the MOST efficient approach?",
          "options": [
            "Use AWS Snowball Edge devices (80TB each, 7 devices) for initial bulk transfer, then AWS DataSync for incremental sync",
            "Use AWS DataSync over VPN for entire transfer",
            "Use AWS Storage Gateway with cached volumes",
            "Use third-party tools like Aspera for faster transfer"
          ],
          "correctAnswer": 0,
          "explanation": "Snowball Edge + DataSync hybrid approach: (1) Order multiple Snowball Edge devices (80TB usable per device, 100TB raw), (2) Copy data to Snowball devices on-premises (local network speed), (3) Ship devices to AWS (AWS uploads to S3), (4) After bulk transfer complete, use DataSync to sync incremental changes and new files created during shipping, (5) Cutover when sync complete. Timeline: Snowball data copy (days), Shipping (1 week), AWS upload (days), DataSync incremental (hours/days). Total: ~2 weeks. Option B (DataSync over 100 Mbps) calculation: 500TB × 8 bits / 100 Mbps / 86400 sec/day ≈ 463 days (impossible in 2 weeks). Option C (Storage Gateway cached) doesn't solve initial transfer problem. Option D (Aspera) accelerates network transfer but still limited by 100 Mbps bandwidth. Snowball family: Snowball Edge Storage Optimized (80TB, 40 vCPUs), Snowball Edge Compute Optimized (39.5TB, 52 vCPUs, GPU), Snowmobile (up to 100PB, for exabyte-scale). When to use Snowball: >10TB data, limited bandwidth, cost (cheaper than months of high-bandwidth transfer), time-sensitive migration."
        }
      ]
    },
    "task_4.3_architecture_design": {
      "question_count": 10,
      "questions": [
        {
          "id": "D4-T4.3-Q1",
          "question": "Monolithic application (3-tier: presentation, business logic, data) migrated to AWS on EC2. Now refactoring to microservices. What's the recommended decomposition strategy to minimize risk?",
          "options": [
            "Strangler Fig pattern: incrementally extract services while monolith runs, routing traffic gradually to new services",
            "Big Bang rewrite: rebuild entire application as microservices simultaneously",
            "Database-first split: divide database first, then split application",
            "Keep monolith, just containerize it"
          ],
          "correctAnswer": 0,
          "explanation": "Strangler Fig pattern minimizes risk during refactoring: (1) Identify bounded contexts (business capabilities that can be independent services), (2) Extract service for one capability (e.g., payment processing), (3) Deploy new service alongside monolith, (4) Use API Gateway or ALB to route traffic: new feature → microservice, existing feature → monolith, (5) Gradually migrate features to microservices, (6) Eventually, monolith 'strangled' - all traffic to microservices. Benefits: Incremental (low risk), Testable (validate each extraction), Rollback capability. Option B (Big Bang) high-risk - if anything fails, everything fails. Option C (database-first) risky - application and database tightly coupled, splitting database first breaks application. Option D (containerize) improves deployment but doesn't achieve microservices benefits. Strangler Fig steps: Prioritize services (high value, low dependency), Define contracts (APIs between services), Implement new service, Route subset of traffic, Monitor, Expand. Tools: AWS App Mesh (service mesh), API Gateway (routing), ECS/EKS (container orchestration), DynamoDB (per-service databases)."
        },
        {
          "id": "D4-T4.3-Q2",
          "question": "Application uses batch processing jobs running nightly on EC2 (8 hours). Jobs are fault-tolerant. AWS migration should optimize cost. What's the BEST compute choice?",
          "options": [
            "On-Demand EC2 instances for predictable pricing",
            "EC2 Spot Instances with Spot Fleet for up to 90% cost savings",
            "Lambda functions for serverless processing",
            "ECS Fargate for managed containers"
          ],
          "correctAnswer": 1,
          "explanation": "EC2 Spot Instances optimal for fault-tolerant batch workloads: Spot pricing up to 90% discount vs On-Demand. Spot Fleet configuration: (1) Define instance types (multiple types for availability), (2) Target capacity (e.g., 20 instances), (3) Allocation strategy (lowest price, diversified), (4) Spot interruption handling (checkpointing). For batch processing: implement checkpointing (save progress periodically), Spot interruption handling (2-minute warning, save state), Job queue (SQS) for work distribution, Auto Scaling based on queue depth. Option A (On-Demand) most expensive for long-running jobs. Option C (Lambda) has 15-minute max execution time - unsuitable for 8-hour jobs. Option D (Fargate) more expensive than Spot EC2 for long-duration workloads. AWS Batch service simplifies: job queues, compute environments (Spot, On-Demand, Fargate), job dependencies, automatic retries. Batch job patterns: array jobs (parallel processing), multi-node jobs (MPI), GPU jobs (ML training). Spot best practices: multiple instance types (flexibility), checkpointing (fault tolerance), Spot Fleet (automatic replacement), monitoring (Spot interruption rate)."
        },
        {
          "id": "D4-T4.3-Q3",
          "question": "Real-time analytics application processes IoT sensor data (100,000 messages/second). Currently batch processes data hourly on-premises. AWS migration should provide real-time insights. Which architecture is MOST appropriate?",
          "options": [
            "IoT Core → Kinesis Data Streams → Lambda → DynamoDB → QuickSight",
            "IoT Core → SQS → EC2 batch processing → RDS",
            "IoT Core → S3 → EMR batch processing → Redshift",
            "IoT Core → Kinesis Data Firehose → S3 → Athena"
          ],
          "correctAnswer": 0,
          "explanation": "Real-time architecture with Kinesis: (1) AWS IoT Core ingests sensor data (MQTT, HTTPS), (2) IoT Rules route to Kinesis Data Streams (scales to millions msg/sec), (3) Lambda or Kinesis Data Analytics processes streams in real-time (aggregations, filtering, enrichment), (4) DynamoDB stores processed results for low-latency queries, (5) QuickSight dashboards visualize real-time metrics. This achieves second-level latency vs hourly batch. Option B (SQS + batch) still batch processing - not real-time. Option C (S3 + EMR) batch analytics. Option D (Firehose + Athena) near real-time but has minute-level delays (Firehose buffers), query latency (Athena) - not suitable for real-time dashboards. Kinesis Data Streams: shard-based scaling, sub-second latency, ordered records per partition key. Use cases: real-time dashboards, alerting, fraud detection, clickstream analytics. Alternative real-time stack: Kafka on MSK (Managed Streaming for Kafka) for Kafka ecosystem, Kinesis Data Analytics with SQL for stream processing, Amazon Timestream for time-series data, Lambda for event-driven processing. Performance: Kinesis shard = 1MB/s ingress or 1000 records/s, Lambda concurrency = shards × parallelization factor (up to 10)."
        }
      ]
    },
    "task_4.4_modernization": {
      "question_count": 8,
      "questions": [
        {
          "id": "D4-T4.4-Q1",
          "question": "Application runs on EC2 with scheduled jobs (Lambda via CloudWatch Events can handle these better). Most functions are stateless, request-response pattern, <5 minute execution. What's the modernization opportunity?",
          "options": [
            "Migrate EC2 to Lambda functions for event-driven, serverless execution with automatic scaling and pay-per-use pricing",
            "Containerize the application using ECS",
            "Keep on EC2 but use Auto Scaling",
            "Migrate to Elastic Beanstalk"
          ],
          "correctAnswer": 0,
          "explanation": "Lambda modernization for suitable workloads: Current: EC2 running 24/7, pay for idle time, manual scaling. Lambda: event-driven execution (EventBridge schedules, API Gateway, S3 events), pay only for execution time (100ms granularity), automatic scaling (concurrent executions), no server management. For this scenario: scheduled jobs (EventBridge → Lambda), <5 min execution (within Lambda 15-min limit), stateless (Lambda paradigm). Benefits: cost savings (vs always-on EC2), simplified operations, high availability (Lambda managed by AWS). Consider Lambda when: stateless workloads, short duration (<15 min), event-driven triggers, variable load. Keep EC2 when: long-running (>15 min), stateful (persistent connections), specific OS requirements, GPU/high memory (>10GB). Option B (ECS) suitable for containerized apps but still requires cluster management. Option C (Auto Scaling) improves EC2 but still paying for servers. Option D (Elastic Beanstalk) PaaS simplification but still server-based. Lambda limitations: 15-minute max, 10GB memory max, /tmp storage (10GB), deployment package size (250MB unzipped). Modernization migration: identify stateless functions, containerize as Lambda deployment package, configure triggers (EventBridge, API Gateway), test concurrency limits, monitor CloudWatch metrics."
        },
        {
          "id": "D4-T4.4-Q2",
          "question": "Self-managed Kubernetes cluster on EC2 (10 worker nodes, multiple operators for logging, monitoring, service mesh). Operations team spends significant time on cluster upgrades, patching, and control plane HA. What's the modernization path?",
          "options": [
            "Migrate to Amazon EKS for managed Kubernetes control plane and integrated AWS services",
            "Migrate to ECS for AWS-native container orchestration",
            "Keep self-managed but automate with Infrastructure as Code",
            "Migrate to Lambda for serverless"
          ],
          "correctAnswer": 0,
          "explanation": "Amazon EKS modernization: EKS manages Kubernetes control plane (HA across 3 AZs, automatic upgrades, patching), integrates with AWS services (ALB/NLB ingress, EBS/EFS storage, IAM authentication, CloudWatch monitoring). Benefits vs self-managed: no control plane management, SLA-backed availability (99.95%), security (automatic security patches), AWS integrations (VPC networking, IAM). Operations team focuses on applications, not cluster infrastructure. For this scenario: 10 worker nodes become EKS-managed, service mesh (App Mesh or continue using existing), logging (CloudWatch Container Insights), monitoring (integrated with CloudWatch). Migration: create EKS cluster, migrate workloads (kubectl apply manifests), test, cutover. Option B (ECS) requires rewriting K8s manifests to ECS task definitions - significant effort if already Kubernetes. Option C (IaC) improves self-managed but doesn't eliminate operational burden. Option D (Lambda) for Kubernetes workloads is major refactoring. EKS features: Managed node groups (automatic patching, upgrades), Fargate for serverless pods, IRSA (IAM Roles for Service Accounts), EKS Add-ons (managed installation of VPC CNI, CoreDNS, kube-proxy). When to use EKS: existing Kubernetes workloads, multi-cloud (Kubernetes portable), need K8s API. When to use ECS: AWS-only, simpler container orchestration, tight AWS integration."
        },
        {
          "id": "D4-T4.4-Q3",
          "question": "Application uses Jenkins on EC2 for CI/CD. Jenkins server requires patching, plugin management, and often is underutilized. AWS-native modernization?",
          "options": [
            "Migrate to AWS CodePipeline, CodeBuild, and CodeDeploy for fully managed CI/CD without server management",
            "Run Jenkins on Elastic Beanstalk",
            "Containerize Jenkins on ECS",
            "Keep Jenkins but use Auto Scaling"
          ],
          "correctAnswer": 0,
          "explanation": "AWS CodePipeline + CodeBuild + CodeDeploy provides serverless CI/CD: CodePipeline (workflow orchestration), CodeBuild (build and test - runs in containers, scales automatically), CodeDeploy (deployment to EC2, ECS, Lambda with blue/green, canary). Benefits vs Jenkins: No server management (fully managed), pay per build minute (vs always-on Jenkins), integrated with AWS (IAM, CloudWatch, S3), automatic scaling. Migration: translate Jenkins pipeline to CodePipeline stages, Jenkinsfile to CodeBuild buildspec.yml, Jenkins deploy scripts to CodeDeploy appspec. Considerations: complex Jenkins pipelines may need phased migration, Jenkins plugins map to CodeBuild Docker images or Lambda functions, Jenkins artifacts migrate to S3. Option B/C (Beanstalk, ECS) still requires Jenkins management. Option D (Auto Scaling) doesn't solve operational burden. Alternative: GitHub Actions or GitLab CI/CD if using those platforms. AWS Developer Tools: CodeCommit (Git repository), CodeBuild (build service), CodeDeploy (deployment), CodePipeline (orchestration), CodeArtifact (artifact repository), CodeGuru (code review AI). When to modernize: reduce operational overhead, improve scalability, leverage AWS-native features. When to keep Jenkins: complex pipelines difficult to migrate, heavy Jenkins plugin dependence, multi-cloud (Jenkins portable)."
        }
      ]
    }
  },
  "note": "Domain 4 complete with 40 detailed questions covering Migration Selection (7 R's, assessment tools), Migration Approach (MGN, DMS, Snowball, DataSync), Architecture Design (microservices, real-time analytics, batch optimization), and Modernization (serverless, managed services)."
}
