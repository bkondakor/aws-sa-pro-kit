{
  "metadata": {
    "totalFiles": 20,
    "totalQuestions": 247,
    "domains": [
      "Domain 1: Organizational Complexity",
      "Domain 2: Design for New Solutions",
      "Domain 3: Continuous Improvement",
      "Domain 3: Continuous Improvement for Existing Solutions",
      "Domain 4: Accelerate Workload Migration and Modernization",
      "Mixed Domains: Advanced Multi-Select Scenarios"
    ],
    "lastUpdated": "2025-11-18T23:23:13.959Z"
  },
  "questionSets": [
    {
      "filename": "advanced-scenarios-batch-1.json",
      "domain": "Domain 1: Organizational Complexity",
      "task": "Advanced Scenarios - Networking, Multi-Account, Security",
      "question_count": 15,
      "questions": [
        {
          "question": "A multinational corporation is migrating from multiple site-to-site VPN connections to AWS Transit Gateway VPN. They have 25 branch offices that need to connect to AWS. Each branch office has dual ISP connections for redundancy. During testing, they notice that aggregate throughput per VPN tunnel is only reaching 1.25 Gbps despite having sufficient bandwidth. What is the PRIMARY reason for this limitation?",
          "options": [
            "Transit Gateway VPN connections are limited to 1.25 Gbps per VPN tunnel due to single-flow IPsec throughput limits",
            "Transit Gateway has a global bandwidth cap of 50 Gbps for all VPN connections combined",
            "The customer gateway devices need hardware acceleration to achieve higher throughput",
            "BGP route limits are causing traffic to be throttled at the Transit Gateway"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Transit Gateway VPN connections have a per-tunnel throughput limit of 1.25 Gbps due to IPsec single-flow encryption overhead. This is a fundamental limitation of IPsec VPN tunnels as they cannot utilize multiple CPU cores for a single tunnel. To achieve higher throughput, you must use ECMP (Equal Cost Multi-Path) routing with multiple VPN tunnels and ensure traffic is distributed across them. Each VPN connection provides two tunnels (for redundancy), and with ECMP, you can add multiple VPN connections to achieve aggregate throughput beyond 1.25 Gbps. Option B is incorrect - Transit Gateway can support up to 50 Gbps per VPN connection with proper ECMP configuration across multiple tunnels. Option C, while hardware acceleration can help, doesn't solve the per-tunnel limit. Option D is unrelated - BGP route limits would cause connectivity issues, not throughput throttling. The key learning is that architects must design for ECMP with multiple VPN tunnels to scale beyond 1.25 Gbps."
        },
        {
          "question": "An enterprise has an existing Direct Connect LAG with two 10 Gbps connections. Due to increasing bandwidth demands, they want to upgrade by adding two 100 Gbps connections to the same LAG while maintaining the existing 10 Gbps connections during the migration period. What will happen when they attempt this configuration?",
          "options": [
            "The LAG will automatically adjust to use all four connections with weighted load balancing based on port speed",
            "The configuration will be rejected because all connections in a LAG must have identical port speeds",
            "The 100 Gbps connections will be throttled to 10 Gbps to match the existing connections",
            "The LAG will operate in hybrid mode, routing different traffic types to different speed connections"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Direct Connect LAG (Link Aggregation Group) has a strict requirement that all connections in a LAG must use the same bandwidth (port speed). You cannot mix 10 Gbps and 100 Gbps connections in the same LAG. This is an IEEE 802.3ad (LACP) standard requirement that AWS enforces. To upgrade from 10 Gbps to 100 Gbps connections, the architect must either: (1) Create a new LAG with 100 Gbps connections, migrate traffic, then decommission the old LAG, or (2) Create individual 100 Gbps connections without LAG, use multiple VIFs with BGP for redundancy. Option A is incorrect - there's no weighted load balancing in LAGs. Option C is false - AWS will reject the configuration entirely rather than throttle. Option D is incorrect - no such hybrid mode exists. The critical learning point is that LAG upgrades require careful planning and cannot be done in-place with mixed speeds, which can catch architects off guard during capacity planning."
        },
        {
          "question": "A Solutions Architect is implementing defense-in-depth security for a multi-account organization. They create an SCP that denies all EC2 instance launches except t3.micro and t3.small. They also implement an IAM permission boundary that allows launching instances up to t3.medium. A developer with full EC2 permissions (within the permission boundary) attempts to launch a t3.medium instance. What will happen?",
          "options": [
            "The instance will launch successfully because the IAM permission allows it",
            "The launch will fail because the SCP takes precedence and denies t3.medium",
            "The instance will launch as t3.small, automatically downgraded by AWS",
            "The launch will fail with an SCP override prompt requiring approval"
          ],
          "correctAnswer": 1,
          "explanation": "In AWS, permissions are evaluated using the intersection of all applicable policies: Identity-based policies AND Permission Boundaries AND SCPs AND Resource-based policies. The effective permissions are the intersection (logical AND) of all these. Service Control Policies (SCPs) from AWS Organizations act as a guardrail - they set the maximum permissions that can be granted, regardless of what IAM policies say. In this scenario: The IAM permissions allow EC2 launches, the permission boundary allows up to t3.medium, but the SCP explicitly denies everything except t3.micro and t3.small. Since SCPs are evaluated as part of the authorization chain, the SCP denial takes precedence and blocks the t3.medium launch. Option A is incorrect because IAM permissions alone don't determine access. Option C is false - AWS doesn't auto-downgrade instance types. Option D is incorrect - there's no SCP override mechanism. This is a tricky scenario because architects might assume permission boundaries are the most restrictive element, but SCPs operate at the account level and can override even tightly scoped IAM permissions. The key insight is that all permissions must allow an action for it to succeed."
        },
        {
          "question": "A media company uses CloudFront with an S3 bucket as the primary origin and an on-premises web server as a secondary custom origin. They configure origin failover to use the on-premises server when S3 is unavailable. During testing, they notice that failover to the custom origin happens even when S3 returns 404 errors for missing objects, causing unexpected behavior. What is the BEST way to fix this?",
          "options": [
            "Configure origin failover to only trigger on 5xx errors (500, 502, 503, 504) and not 4xx errors",
            "Disable origin failover and use Lambda@Edge to implement custom failover logic",
            "Configure S3 bucket policies to return 503 instead of 404 for missing objects",
            "Use multiple distributions with Route 53 health checks for failover instead"
          ],
          "correctAnswer": 0,
          "explanation": "CloudFront origin failover allows you to specify which HTTP status codes should trigger failover to the secondary origin. By default, CloudFront may fail over on both 4xx and 5xx errors, but this behavior can be customized. A 404 error indicates the object doesn't exist at the origin, which is a valid response and shouldn't trigger failover to a different origin - the object simply doesn't exist. However, 5xx errors (500, 502, 503, 504) indicate origin infrastructure problems and should trigger failover. The solution is to configure the origin group to only failover on 5xx status codes. This is done by specifying StatusCodes in the FailoverCriteria (500, 502, 503, 504). Option B is overly complex - Lambda@Edge adds latency and cost when built-in features suffice. Option C is incorrect - changing valid 404 responses to 503 would break HTTP semantics and caching behavior. Option D is unnecessary complexity and wouldn't solve the fundamental issue of inappropriate failover triggers. The key learning is understanding CloudFront's origin failover behavior and properly configuring status codes for failover criteria to avoid false positives."
        },
        {
          "question": "A financial services company uses AWS KMS multi-region keys for encrypting data that must be available in us-east-1 and eu-west-1. They have a central security account that owns the multi-region primary key in us-east-1 and its replica in eu-west-1. Application accounts need to decrypt data in both regions. After granting cross-account access in the key policy, decryption works in us-east-1 but fails in eu-west-1 with an access denied error. What is the MOST likely cause?",
          "options": [
            "Multi-region keys require separate key policies for each region, and the eu-west-1 replica key policy wasn't updated",
            "Cross-account access with multi-region keys requires VPC endpoints in the same region as the replica",
            "The application account's IAM role needs to specify the replica key ARN explicitly for eu-west-1",
            "Multi-region key replicas are read-only and cannot be used for decryption in cross-account scenarios"
          ],
          "correctAnswer": 0,
          "explanation": "AWS KMS multi-region keys are a powerful feature where related keys in different regions have the same key material but are treated as independent resources with their own key policies, aliases, and permissions. When you create a multi-region primary key and replicate it to another region, each key (primary and replicas) has its own key policy. Cross-account access must be explicitly granted in each region's key policy independently. In this scenario, the security account likely updated the primary key policy in us-east-1 to allow cross-account access, but forgot to update the replica key policy in eu-west-1. The solution is to update the eu-west-1 replica key policy to include the same cross-account permissions. Option B is incorrect - VPC endpoints are not required for cross-account KMS access, though they can be used for private connectivity. Option C is partially true (the ARN must be correct for each region) but the root cause is the missing key policy permission in eu-west-1. Option D is false - replicas can be used for all KMS operations including decryption. This scenario tests understanding that multi-region keys share key material but not policies or permissions."
        },
        {
          "question": "A large enterprise with 200 AWS accounts in an AWS Organization needs to implement centralized DNS resolution for on-premises domain names. They configure Route 53 Resolver outbound endpoints and forwarding rules in a central networking account, then use RAM (Resource Access Manager) to share the rules with all accounts. After sharing, some accounts can resolve on-premises domains while others cannot. What is the MOST likely issue?",
          "options": [
            "The VPCs in failing accounts don't have the shared resolver rules associated with them",
            "RAM sharing of resolver rules requires Organizations to be in all-features mode, which wasn't enabled",
            "The outbound endpoints need to be created in each account individually, not shared",
            "Route 53 Resolver has a limit of 100 accounts per shared rule"
          ],
          "correctAnswer": 0,
          "explanation": "When Route 53 Resolver rules are shared via RAM to multiple accounts, the rules become available to those accounts, but they don't automatically apply to VPCs. Each account must explicitly associate the shared resolver rules with their VPCs. This is a common gotcha - architects assume that sharing the rules through RAM automatically enables them across all VPCs in the organization, but there's a second step required. The accounts that can resolve on-premises domains likely manually associated the shared rules with their VPCs, while the failing accounts didn't complete this step. The solution is to ensure each account associates the shared resolver rules with their VPCs via the VPC console or API. Option B is incorrect - while all-features mode is required for some RAM sharing scenarios, it's not the limiting factor here. Option C is false - outbound endpoints don't need to be in every account; they can be centralized and accessed by shared rules. Option D is incorrect - there's no such 100-account limit for shared resolver rules. This tests understanding of the two-step process: sharing rules via RAM, then associating rules with VPCs."
        },
        {
          "question": "A company has Transit Gateways in us-east-1 and eu-west-1 with inter-region peering. They need to route traffic through a security appliance (firewall) VPC in us-east-1 for all traffic flowing between regions. They enable appliance mode on the us-east-1 Transit Gateway attachment for the firewall VPC. Traffic is still bypassing the firewall. What additional configuration is required?",
          "options": [
            "Enable appliance mode on the inter-region peering attachment as well",
            "Configure route tables to explicitly route inter-region traffic through the firewall VPC attachment",
            "Appliance mode only works for intra-region traffic; use AWS Network Firewall for inter-region inspection",
            "Configure the firewall VPC attachment as the default route in both Transit Gateway route tables"
          ],
          "correctAnswer": 1,
          "explanation": "Enabling appliance mode on a Transit Gateway VPC attachment ensures that return traffic for a flow uses the same availability zone as the original traffic, which is essential for stateful appliances like firewalls. However, appliance mode itself doesn't route traffic through the appliance - it only ensures consistent AZ-affinity for flows. To actually route traffic through the firewall VPC, you must configure Transit Gateway route tables with explicit routes that direct traffic to the firewall VPC attachment. For inter-region traffic inspection, the route tables in both regions should have routes pointing to the firewall VPC attachment. For example, the eu-west-1 Transit Gateway route table should have routes for us-east-1 CIDRs pointing to the peering attachment, but the us-east-1 side should route that incoming traffic to the firewall VPC attachment before routing to final destinations. Option A is incorrect - appliance mode is not needed on peering attachments. Option C is false - appliance mode works for inter-region traffic when routes are configured correctly. Option D is partially correct but not specific enough; you need explicit routing logic, not just a default route. This tests understanding that appliance mode solves flow symmetry but doesn't handle traffic routing."
        },
        {
          "question": "An organization uses AWS IAM Identity Center (AWS SSO) with Azure AD as the identity source. They acquire another company that uses Okta. They want users from both Azure AD and Okta to access AWS accounts through SSO without migration. What is the BEST approach?",
          "options": [
            "Configure IAM Identity Center to use multiple identity sources simultaneously",
            "Implement federation with both Azure AD and Okta directly to each AWS account using SAML",
            "Create separate IAM Identity Center instances for each identity provider and use Organizations to manage access",
            "Consolidate both identity providers into a single Azure AD tenant with B2B guest access for Okta users"
          ],
          "correctAnswer": 3,
          "explanation": "AWS IAM Identity Center (formerly AWS SSO) currently supports only ONE external identity source at a time - you can choose either the built-in Identity Center directory, OR an external IdP like Azure AD, OR an Active Directory connector, but not multiple simultaneously. This is a significant limitation that many architects don't realize. Given this constraint, option D is the most practical solution: consolidate both identity providers by using Azure AD's B2B (business-to-business) collaboration feature to invite Okta users as guest users in the Azure AD tenant. These guest users can then authenticate through their Okta credentials while being represented in the Azure AD tenant that IAM Identity Center uses. Option A is incorrect - IAM Identity Center doesn't support multiple identity sources. Option B would work but loses the benefits of centralized SSO management and creates operational complexity with individual SAML setups per account. Option C is incorrect - you cannot have multiple IAM Identity Center instances in the same organization. This scenario tests awareness of IAM Identity Center's single-identity-source limitation and creative solutions for multi-IdP environments."
        },
        {
          "question": "A company has a Direct Connect Gateway (DXGW) connected to multiple Transit Gateways across 3 regions. They want to add VPN backup connectivity to each Transit Gateway for redundancy. When they try to create VPN attachments to the Transit Gateways that already have DXGW associations, the configuration fails. What is the issue?",
          "options": [
            "A Transit Gateway can have either a Direct Connect Gateway association OR VPN attachments, but not both simultaneously",
            "The BGP AS numbers conflict between the Direct Connect connection and VPN configuration",
            "VPN attachments require the Transit Gateway to be in VPN mode, which conflicts with Direct Connect Gateway mode",
            "The issue is that Transit Gateway can have both, but the same on-premises CIDR ranges cannot be advertised over both Direct Connect and VPN connections"
          ],
          "correctAnswer": 3,
          "explanation": "This is a tricky scenario involving routing conflicts. A Transit Gateway CAN have both Direct Connect Gateway associations AND VPN attachments simultaneously - this is actually the recommended architecture for hybrid connectivity with failover. However, the issue arises when the same on-premises CIDR ranges are advertised via BGP over both the Direct Connect connection and the VPN connection to the same Transit Gateway. The Transit Gateway receives conflicting routes for the same CIDR ranges and may reject the configuration or create unpredictable routing behavior. The solution is to use BGP attributes (AS-PATH prepending or local preference) to make one path preferred over the other. Typically, you'd prepend AS numbers on the VPN advertisements to make them less preferred, so Direct Connect is primary and VPN is backup. Option A is false - Transit Gateway supports both connection types simultaneously. Option B might be part of the issue but isn't the primary blocker. Option C is incorrect - there's no such 'VPN mode' or 'Direct Connect Gateway mode' for Transit Gateways. The key learning is that multiple paths to the same destination require proper BGP tuning."
        },
        {
          "question": "A company uses VPC sharing via AWS RAM to share subnets from a central networking account to multiple application accounts. Application teams in Account A and Account B create their own security groups in the shared VPC. Account A's application needs to allow traffic from Account B's application. Account A tries to reference Account B's security group in their security group rules but receives an error. What is the limitation?",
          "options": [
            "Security group references only work within the same AWS account, even in shared VPCs",
            "Cross-account security group references require VPC peering between the accounts",
            "Security groups in shared VPCs must be created in the owner account to be referenceable across participant accounts",
            "Cross-account security group references require explicit RAM sharing of the security groups"
          ],
          "correctAnswer": 0,
          "explanation": "This is a critical limitation of VPC sharing that catches many architects. While VPC sharing allows multiple accounts to create resources (EC2 instances, security groups, etc.) in shared subnets, security group references only work within the same AWS account, even when the security groups are in the same shared VPC. You cannot reference a security group owned by Account B in a security group rule created by Account A, even though both security groups are in the same shared VPC. This limitation exists because security groups are account-specific resources despite being in a shared VPC. The workaround is to use CIDR-based rules instead of security group references, or to create shared security groups in the VPC owner account and grant participant accounts permission to use them (though participants still can't reference each other's security groups). Option B is incorrect - VPC peering isn't relevant for shared VPCs. Option C is partially true but doesn't solve cross-account references between participant accounts. Option D is incorrect - RAM doesn't support sharing individual security groups independently. This tests understanding of VPC sharing limitations regarding security group references."
        },
        {
          "question": "An architect is designing centralized egress filtering for 50 VPCs using AWS Network Firewall. To reduce costs, they consider deploying a single Network Firewall in a central VPC and using Gateway Load Balancer Endpoints (GWLBE) in spoke VPCs to route traffic to it. What is the PRIMARY issue with this approach?",
          "options": [
            "AWS Network Firewall cannot be used with Gateway Load Balancer; it requires direct VPC attachments",
            "Gateway Load Balancer is designed for third-party appliances, not AWS native services like Network Firewall",
            "This architecture would work but requires deploying Network Firewall endpoints in each spoke VPC, negating centralization benefits",
            "The traffic flow would break return path routing because GWLB doesn't support stateful inspection handoff"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Network Firewall is not integrated with Gateway Load Balancer. Network Firewall is deployed directly in VPCs using Network Firewall endpoints, which are ENIs in specified subnets. You cannot route traffic to Network Firewall via GWLB. If you want to centralize egress filtering using Network Firewall for multiple VPCs, the architecture should use a centralized egress VPC with Network Firewall endpoints deployed in it, and spoke VPCs route internet-bound traffic through Transit Gateway to the egress VPC. Gateway Load Balancer is specifically designed for integrating third-party virtual appliances (like Palo Alto, Fortinet, Check Point) that are deployed as EC2 instances. Option B is partially true but not the primary issue - GWLB is for third-party appliances, but the key point is Network Firewall doesn't integrate with it at all. Option C is incorrect - Network Firewall endpoints are needed but that's by design, not a workaround. Option D incorrectly suggests the architectural possibility exists. This tests understanding of when to use Network Firewall versus Gateway Load Balancer with third-party appliances."
        },
        {
          "question": "A large enterprise with 1,500 AWS accounts wants to delegate AWS Security Hub administration to their security team's account. They also want to delegate GuardDuty, Config, and CloudFormation StackSets administration to the same security account for centralized management. What limitation will they encounter?",
          "options": [
            "Each AWS service can only have one delegated administrator per organization, so all four services can share the same delegated admin account",
            "An organization can only have 5 delegated administrators total across all services",
            "AWS Organizations limits delegated administrators to 10 services per account",
            "Each service supports a different maximum number of member accounts that can be managed by a delegated administrator"
          ],
          "correctAnswer": 0,
          "explanation": "This is actually a trick question where the correct answer describes what works correctly, but architects might overthink it. In AWS Organizations, each integrated AWS service can have one delegated administrator account. However, the same account can be the delegated administrator for multiple services simultaneously. There's no limit preventing a single account from being the delegated admin for Security Hub, GuardDuty, Config, and CloudFormation StackSets all at once. This is actually the recommended best practice - use a centralized security tooling account as the delegated admin for all security and compliance services. Option B is false - there's no such organization-wide limit of 5 delegated administrators across all services. Option C is incorrect - there's no 10-service-per-account limit. Option D, while technically true that different services have different member account limits (for example, Security Hub supports up to 5,000 accounts), isn't a limitation they would encounter when designating the delegated admin, and 1,500 accounts is within the limits of all mentioned services. The key insight is recognizing that delegated admin consolidation in one account is supported and recommended."
        },
        {
          "question": "A consulting company wants to share a Transit Gateway with their client's AWS account using AWS Resource Access Manager (RAM). The consulting company's AWS Organization has RAM sharing with external accounts enabled. After creating the RAM share and sending the invitation to the client account, the client accepts it, but cannot attach VPCs to the shared Transit Gateway. What is the MOST likely issue?",
          "options": [
            "The client account must be invited to and accept membership in the consulting company's AWS Organization",
            "External account sharing of Transit Gateways requires the shared Transit Gateway to be in a specific sharing mode that wasn't enabled",
            "Transit Gateways cannot be shared with external accounts via RAM; only VPC resources can be shared externally",
            "The client account needs to enable RAM external sharing in their account settings"
          ],
          "correctAnswer": 2,
          "explanation": "This is a critical limitation of AWS RAM (Resource Access Manager) that many architects miss. While AWS RAM supports sharing many resource types both within an AWS Organization and with external accounts, Transit Gateways can ONLY be shared within the same AWS Organization - they cannot be shared with external accounts. Similarly, AWS License Manager configurations, Route 53 Resolver rules (prior to a recent update), and some other resources have the same limitation. Resources that can be shared externally include VPC subnets (VPC sharing), Aurora DB clusters, CodeBuild projects, and others, but Transit Gateway is explicitly limited to organization-internal sharing. The solution would be either: (1) Have the client join the consulting company's organization as a member account (Option A, but this has significant governance implications), or (2) Use alternative architectures like VPC peering or VPN connections. Option B is incorrect - there's no such 'sharing mode' for Transit Gateway. Option D is incorrect - the receiving account doesn't need to enable anything for external sharing; the limitation is on the resource type itself. This tests awareness of RAM's per-resource-type sharing scope limitations."
        },
        {
          "question": "A SaaS provider hosts their service in us-east-1 behind a Network Load Balancer with an AWS PrivateLink endpoint service. Customers in eu-west-1 want to access the service privately without internet exposure. The provider wants to enable this without deploying duplicate infrastructure in eu-west-1. What is the MOST cost-effective solution?",
          "options": [
            "Create inter-region VPC peering from customer VPCs in eu-west-1 to the provider VPC in us-east-1, then use the PrivateLink endpoint",
            "Deploy an NLB in eu-west-1 as a regional frontend that forwards traffic to the us-east-1 service via PrivateLink",
            "Use AWS PrivateLink endpoint services with cross-region support enabled to allow eu-west-1 consumers to connect directly",
            "Deploy a Network Load Balancer in eu-west-1 that targets the us-east-1 NLB IP addresses, then create a PrivateLink endpoint service from it"
          ],
          "correctAnswer": 3,
          "explanation": "AWS PrivateLink endpoint services are region-specific and do not support direct cross-region connectivity. Customers can only create VPC endpoints in the same region as the endpoint service. For cross-region private connectivity, the most cost-effective solution is to deploy an NLB in eu-west-1 that has target groups pointing to the IP addresses of the NLB in us-east-1. Cross-region traffic between the NLBs uses AWS's private backbone. Then create a PrivateLink endpoint service from the eu-west-1 NLB, allowing customers in eu-west-1 to consume it. This creates a regional proxy pattern. Option A (VPC peering) wouldn't work because PrivateLink endpoints are private to the VPC; peering to the provider's VPC doesn't grant access to the endpoint service. Option B is less cost-effective because it suggests each customer deploys their own NLB. Option C is incorrect - PrivateLink doesn't have cross-region support built-in. The key learning is understanding PrivateLink's regional limitation and the NLB-to-NLB proxy pattern for cross-region enablement."
        },
        {
          "question": "A large financial institution uses AWS Control Tower to provision new accounts through Account Factory. They have 25 custom SCPs, 15 custom CloudFormation StackSets for baseline resources, and 8 AWS Config rules that must be applied to every new account. During account provisioning, some of the CloudFormation StackSets fail to deploy. What is the MOST likely cause?",
          "options": [
            "Control Tower Account Factory has a limit of 10 CloudFormation StackSets per account and the 15 custom StackSets exceed this",
            "The StackSets have dependencies on resources created by other StackSets, and there's no execution order guarantee",
            "Account Factory can only execute AWS-managed StackSets, not custom user-created StackSets",
            "The IAM role used by Account Factory doesn't have permissions to create all the resources defined in the StackSets"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Control Tower Account Factory provisions accounts and applies customizations including CloudFormation StackSets. However, there's no built-in mechanism to control the execution order of multiple StackSets. If StackSet A creates a VPC and StackSet B tries to create subnets in that VPC, StackSet B might execute before StackSet A completes, causing failures. This is a common issue when implementing complex account baselines with many interdependent resources. The solution is to either: (1) Combine dependent resources into single StackSets to ensure ordered creation, (2) Use StackSet dependencies within CloudFormation (DependsOn), or (3) Implement Customizations for Control Tower (CfCT) which provides better control over execution sequencing. Option A is incorrect - there's no such 10-StackSet limit. Option C is false - Account Factory can deploy custom StackSets, not just AWS-managed ones. Option D is possible but less likely to be the primary issue since Account Factory uses the AWSControlTowerExecution role which has broad permissions. This tests understanding of Control Tower customization challenges and StackSet execution behavior."
        }
      ]
    },
    {
      "filename": "advanced-scenarios-batch-2.json",
      "domain": "Domain 2: Design for New Solutions",
      "task": "Advanced Scenarios - Deployment, Architecture Patterns, Reliability",
      "question_count": 15,
      "questions": [
        {
          "question": "A financial trading application uses Lambda functions connected to a VPC to access RDS databases. Even with provisioned concurrency configured for 50 concurrent executions, users experience occasional 10-15 second delays during peak hours. CloudWatch metrics show that provisioned concurrency is never exhausted. What is the MOST likely cause?",
          "options": [
            "Provisioned concurrency doesn't eliminate cold starts for VPC-connected Lambda functions",
            "The Lambda function's memory allocation is too low, causing slow initialization",
            "Application Auto Scaling for provisioned concurrency is reacting too slowly to traffic spikes",
            "Bursts beyond provisioned concurrency still experience ENI creation delays for VPC connections"
          ],
          "correctAnswer": 3,
          "explanation": "While provisioned concurrency keeps Lambda execution environments warm and ready, functions that burst beyond the provisioned concurrency level still need to create new execution environments. For VPC-connected Lambda functions, new execution environments require Hyperplane ENIs to be attached, which can take 10-15 seconds. The scenario states that provisioned concurrency is never exhausted, which means traffic spikes are creating executions beyond the 50 provisioned instances. Option A is incorrect - provisioned concurrency DOES eliminate cold starts for the provisioned instances. Option B is unlikely to cause 10-15 second delays; memory affects execution speed, not initialization time. Option C is possible but the scenario states provisioned concurrency isn't exhausted, suggesting the scaling isn't the issue. The solution is to increase provisioned concurrency to handle peak traffic, or use Lambda's Hyperplane ENI optimization (which since 2019 uses a shared ENI pool, but initial attachment for new environments still has some delay). This tests understanding of Lambda VPC networking and provisioned concurrency limitations."
        },
        {
          "question": "An architect designs an ECS cluster with 10 EC2 instances for a microservices application. They use the binpack placement strategy to maximize resource utilization. During a rolling deployment, several tasks fail to place despite sufficient aggregate cluster resources. What is the PRIMARY issue?",
          "options": [
            "Binpack strategy can create fragmentation where no single instance has enough resources for new task placement",
            "ECS doesn't support rolling deployments with binpack strategy; only spread strategy supports it",
            "The cluster instances need to be in an Auto Scaling group to support binpack placement",
            "Binpack strategy has a hard limit of 5 tasks per instance regardless of available resources"
          ],
          "correctAnswer": 0,
          "explanation": "The binpack placement strategy aims to place tasks on instances to maximize resource utilization, filling up instances before moving to the next. During rolling deployments, this can create a fragmentation problem: instances might each have small amounts of free CPU/memory, but no single instance has enough free resources to place a new task. For example, if a task needs 1 vCPU and 2GB RAM, and all 10 instances each have 0.5 vCPU and 1GB RAM free, the aggregate cluster has enough resources (5 vCPU, 10GB RAM) but no single instance can host the task. The solution is to either: (1) Use spread strategy for better distribution during deployments, (2) Overprovision cluster capacity, (3) Use ECS Cluster Auto Scaling to add instances when needed, or (4) Implement binpack with instanceId spread for better distribution. Option B is false - both strategies support rolling deployments. Option C is incorrect - Auto Scaling groups are recommended but not required for binpack. Option D is false - there's no such 5-task limit. This tests understanding of ECS task placement challenges with different strategies."
        },
        {
          "question": "A company processes millions of IoT sensor events per day. Each event requires a simple 3-step transformation workflow taking 30 seconds. They need exactly-once processing semantics and must maintain an audit trail of all executions for 90 days. Which Step Functions workflow type should they use?",
          "options": [
            "Express workflows in synchronous mode for exactly-once semantics with CloudWatch Logs for audit trail",
            "Standard workflows because they provide exactly-once execution and built-in 90-day execution history",
            "Express workflows in asynchronous mode with DynamoDB for tracking execution state",
            "Standard workflows with cross-region replication for durability and compliance"
          ],
          "correctAnswer": 1,
          "explanation": "Step Functions has two workflow types with distinct characteristics: Standard workflows provide exactly-once execution, have a full execution history stored for 90 days, and support long-running workflows but are limited to 2,000 executions per second per account per region. Express workflows provide at-least-once execution, don't maintain execution history (only CloudWatch Logs), but support much higher execution rates (100,000 per second). The scenario requires exactly-once semantics and 90-day audit trail, which are exclusive features of Standard workflows. While millions of events per day sounds high, it averages to ~12-40 executions per second, well within Standard workflow limits. Option A is incorrect - Express workflows only provide at-least-once semantics, even in synchronous mode. Option C doesn't solve the exactly-once requirement. Option D adds unnecessary complexity with cross-region replication. The key learning is understanding the execution semantics difference: Standard = exactly-once, Express = at-least-once. This tests awareness of Step Functions workflow type selection based on execution guarantees."
        },
        {
          "question": "A DynamoDB table uses on-demand capacity mode. The table has a Global Secondary Index (GSI) with a different partition key. During traffic spikes, write operations to the base table are being throttled even though the table is in on-demand mode. What is the MOST likely cause?",
          "options": [
            "On-demand mode has a per-partition throughput limit that's being exceeded during spikes",
            "The GSI is throttling writes because GSI projections are being written faster than DynamoDB can handle",
            "DynamoDB automatically switches to provisioned mode during extreme spikes, causing throttling",
            "On-demand mode requires time to scale up, and instant traffic spikes exceed the adaptive scaling rate"
          ],
          "correctAnswer": 3,
          "explanation": "DynamoDB on-demand mode provides automatic scaling but not instant unlimited capacity. On-demand mode can accommodate up to double your previous peak traffic within 30 minutes. If you have instant traffic spikes that exceed this adaptive capacity, you'll experience throttling. For example, if your previous peak was 1,000 WCU/s, and you suddenly spike to 5,000 WCU/s, you'll be throttled until the system scales up. This is particularly relevant for GSIs - when you write to a base table with GSIs, DynamoDB must also write to the GSI. If the GSI's capacity cannot scale fast enough, the base table writes are throttled. Option A is partially true (partitions have throughput limits) but on-demand mode handles this with partition splitting; it's not the primary cause here. Option B is incorrectly stated - GSI projections don't have a separate throttling mechanism beyond the GSI's capacity. Option C is false - DynamoDB doesn't automatically switch modes. The solution is to either pre-warm capacity by gradually increasing traffic, use provisioned capacity for predictable spiky workloads, or implement exponential backoff. This tests understanding of on-demand mode scaling limits."
        },
        {
          "question": "A global application uses Aurora Global Database with a primary cluster in us-east-1 and secondary clusters in eu-west-1 and ap-southeast-1. To reduce latency for European users writing data, they enable write forwarding on the eu-west-1 secondary cluster. After enabling it, they notice write performance for European users is worse than before. Why?",
          "options": [
            "Write forwarding requires synchronous replication to the primary, increasing latency compared to direct writes to primary",
            "Write forwarding only works for INSERT operations, not UPDATE or DELETE, causing application errors",
            "The secondary cluster's instance class must match the primary for write forwarding to work efficiently",
            "Write forwarding is incompatible with Aurora Serverless v2 instances in the secondary cluster"
          ],
          "correctAnswer": 0,
          "explanation": "Aurora Global Database write forwarding allows secondary (read) clusters to forward writes to the primary cluster. However, this doesn't improve write latency for users closer to secondary regions - it actually increases latency. When write forwarding is enabled, writes to the secondary cluster are sent over the network to the primary cluster, the primary processes and commits them, then the changes replicate back to the secondary. This round-trip adds latency compared to users directly connecting to the primary. Write forwarding is designed for application architecture simplification (single endpoint for both reads and writes), not for improving write performance. For true low-latency writes in multiple regions, you need multi-master (Aurora MySQL only, still in preview), or application-level write routing to the appropriate primary. Option B is false - write forwarding supports all DML operations. Option C is incorrect - instance class matching isn't required. Option D is false - write forwarding works with Serverless v2. This tests understanding of Aurora Global Database write forwarding purpose and limitations."
        },
        {
          "question": "An architect is configuring AWS service access for EKS pods. They need pods to access S3 and DynamoDB with different IAM permissions per pod. They're choosing between IRSA (IAM Roles for Service Accounts) and EKS Pod Identity. The cluster has 500 pods with 50 different service accounts requiring different permissions. What should they consider?",
          "options": [
            "IRSA has a limit of 100 service account to IAM role mappings per cluster, requiring EKS Pod Identity instead",
            "EKS Pod Identity provides better performance with no webhook latency, making it preferable for large-scale deployments",
            "IRSA requires manual OIDC provider setup per cluster while Pod Identity is automatic, reducing operational overhead",
            "Both solutions work at scale; Pod Identity is newer with simpler configuration but IRSA is more widely supported across Kubernetes distributions"
          ],
          "correctAnswer": 3,
          "explanation": "Both IRSA (IAM Roles for Service Accounts) and EKS Pod Identity solve the same problem of providing AWS credentials to pods. IRSA has been available since 2019 and uses a webhook to intercept AWS SDK calls and inject temporary credentials via OIDC federation. EKS Pod Identity is newer (2023) and uses a different approach with an agent DaemonSet and simpler configuration. Key differences: IRSA requires OIDC provider setup and trust policy configuration, but works across different Kubernetes distributions. Pod Identity is EKS-specific but has simpler configuration with no OIDC provider needed. Neither has the 100-mapping limit mentioned in Option A. Option B is partially true about webhook latency, but it's negligible for most workloads. Option C is partially true but both are manageable operationally. The right choice depends on your environment: IRSA for multi-distribution support, Pod Identity for EKS-native simplicity. This tests understanding of the two approaches and their trade-offs rather than a specific limitation."
        },
        {
          "question": "A company has an API hosted on API Gateway serving customers globally. They use CloudFront with custom domain names and WAF for security. The API is configured as edge-optimized. Their security team wants to use API Gateway resource policies to restrict access to specific VPC endpoints. What issue will they encounter?",
          "options": [
            "Edge-optimized APIs don't support resource policies; they must switch to Regional API endpoints",
            "Resource policies work with edge-optimized APIs but VPC endpoint restrictions only work with Regional APIs",
            "API Gateway resource policies cannot be used together with CloudFront distributions",
            "VPC endpoint restrictions require PrivateLink, which is incompatible with edge-optimized APIs"
          ],
          "correctAnswer": 1,
          "explanation": "API Gateway edge-optimized endpoints automatically create and manage a CloudFront distribution in front of your API. While resource policies work with edge-optimized APIs for general access control, VPC endpoint restrictions (aws:SourceVpc or aws:SourceVpce conditions) only work with Regional API endpoints. This is because edge-optimized APIs route through CloudFront, which doesn't preserve the VPC endpoint source information. If you need to restrict API access to specific VPC endpoints, you must use a Regional API endpoint. The architecture would be: Regional API Gateway → Custom CloudFront distribution → WAF. This gives you control over CloudFront configuration and allows VPC endpoint restrictions on the API Gateway resource policy. Option A is incorrect - resource policies work with edge-optimized APIs for other conditions. Option C is false - you can use resource policies with CloudFront, but not VPC endpoint restrictions on edge-optimized APIs. Option D incorrectly describes PrivateLink compatibility. This tests understanding of API Gateway endpoint types and resource policy capabilities."
        },
        {
          "question": "Organization A needs to send events from their account to Organization B's EventBridge event bus. Organization B creates an event bus policy allowing Organization A's account to PutEvents. After testing, events from Organization A are not appearing in Organization B's bus. The PutEvents calls succeed with no errors. What is missing?",
          "options": [
            "EventBridge requires resource-based policies on both the source and target event buses for cross-account delivery",
            "Organization A must create an EventBridge rule that targets Organization B's event bus ARN",
            "Cross-account event delivery requires AWS Organizations trust relationship between the accounts",
            "Organization A's IAM principals need explicit permissions to PutEvents on the remote event bus in addition to the resource policy"
          ],
          "correctAnswer": 1,
          "explanation": "EventBridge cross-account event delivery requires a two-step configuration: (1) The target account (Organization B) must have a resource-based policy on their event bus allowing the source account to send events, and (2) The source account (Organization A) must create an EventBridge rule with the target set to Organization B's event bus ARN. Simply calling PutEvents with Organization B's bus ARN won't work - events go to your default bus unless a rule routes them. The correct flow is: Events → Organization A's default bus → Rule matches events → Rule targets Organization B's event bus (cross-account) → Events appear in Organization B's bus. Option A is incorrect - only the target bus needs a resource policy. Option C is false - Organizations relationship is not required for cross-account EventBridge. Option D is partially correct (IAM permissions are needed) but the primary missing piece is the rule in the source account. This tests understanding of EventBridge cross-account architecture requiring rules, not just PutEvents."
        },
        {
          "question": "A mobile application uses AWS AppSync with DynamoDB as the data source. To improve performance, they enable caching at the API level with a 1-hour TTL. Users report seeing stale data even after making mutations that should update the data. What is the MOST appropriate solution?",
          "options": [
            "Reduce the cache TTL to 5 minutes to ensure fresher data",
            "Implement cache invalidation logic in mutation resolvers to clear affected cached queries",
            "Disable caching for mutations while keeping it enabled for queries",
            "Use per-resolver caching instead of API-level caching for better control"
          ],
          "correctAnswer": 1,
          "explanation": "AppSync caching stores resolver results to reduce backend calls. When you enable API-level caching, query results are cached based on field arguments and identity. However, mutations don't automatically invalidate related cached queries. If a user queries for data, the result is cached. If they then mutate that data, the mutation succeeds but the cached query result remains until TTL expires, showing stale data. The solution is to implement cache invalidation in mutation resolvers using the $util.cachingInvalidate() function to specify which cache keys to invalidate. You can invalidate specific cache entries based on arguments or clear entire resolver caches. Option A reduces staleness duration but doesn't solve the fundamental problem. Option C is the default behavior - mutations aren't cached, but that doesn't prevent query caches from becoming stale. Option D (per-resolver caching) provides granular control but doesn't solve invalidation; you still need explicit invalidation logic. This tests understanding of AppSync caching behavior and the need for explicit cache invalidation strategies."
        },
        {
          "question": "A serverless application with thousands of Lambda functions connects to an RDS PostgreSQL database through RDS Proxy for connection pooling. During load testing, they still encounter 'too many connections' errors from PostgreSQL despite Proxy being configured for 1000 max connections. What is the issue?",
          "options": [
            "RDS Proxy doesn't support PostgreSQL, only MySQL and Aurora",
            "The RDS instance's max_connections parameter is set lower than the Proxy's max connections setting",
            "Lambda functions are not reusing the RDS Proxy connections properly due to incorrect initialization",
            "RDS Proxy requires all Lambda functions to be in the same VPC subnet for connection sharing"
          ],
          "correctAnswer": 1,
          "explanation": "RDS Proxy provides connection pooling between your applications and the database, but it cannot create more connections to the database than the database allows. The max_connections parameter in RDS determines how many connections the database will accept. If RDS Proxy is configured for 1000 max connections but the RDS instance's max_connections parameter is set to 100, only 100 connections can be established to the database. RDS Proxy will queue additional connection requests. The 'too many connections' error suggests the database's max_connections limit is being hit. The solution is to increase the RDS instance's max_connections parameter (in a custom parameter group) to match or exceed the Proxy configuration. Option A is false - RDS Proxy supports PostgreSQL, MySQL, and Aurora. Option C is about connection reuse which affects efficiency but wouldn't cause 'too many connections' errors from the database. Option D is incorrect - VPC subnet placement doesn't affect connection sharing logic. This tests understanding that RDS Proxy pools connections but is still bound by database-side connection limits."
        },
        {
          "question": "A video streaming platform needs to provide authenticated access to premium content stored in S3. Users should access multiple video files per session without requesting new authorization. The platform has a mix of web and mobile applications. Which approach is MOST appropriate?",
          "options": [
            "CloudFront signed URLs because they provide better security with individual file authorization",
            "CloudFront signed cookies because they allow access to multiple files with a single authentication",
            "CloudFront signed URLs because signed cookies don't work with mobile applications",
            "CloudFront signed cookies because they don't expose the signature in the URL, improving security"
          ],
          "correctAnswer": 1,
          "explanation": "CloudFront signed URLs and signed cookies both provide authenticated access to restricted content, but have different use cases. Signed URLs are best for individual files or when you can't modify the client application (e.g., direct downloads, embedded media with specific URLs). Signed cookies are better for providing access to multiple restricted files without generating URLs for each, which is perfect for scenarios like video streaming where a user session needs access to multiple video segments, playlists, subtitles, etc. The cookies are set once upon authentication and grant access to all matching content. Option A is incorrect - signed cookies provide equivalent security and are actually better for multiple files. Option C is false - signed cookies work fine with mobile apps that support cookie storage. Option D is partially true (not exposing signatures in URLs has marginal security benefit) but the primary advantage is the multiple-file access. The key distinction is: signed URLs = individual resources, signed cookies = multiple resources per session. This tests understanding of when to use each CloudFront security feature."
        },
        {
          "question": "A data processing application consumes from a Kinesis Data Stream with 50 shards. They have 8 Lambda functions processing the stream, each needing dedicated throughput. They enable enhanced fan-out for all consumers. After deployment, some consumers experience throttling. What is the MOST likely cause?",
          "options": [
            "Enhanced fan-out has a limit of 5 registered consumers per stream",
            "Lambda functions cannot use enhanced fan-out; only Kinesis Client Library (KCL) applications can",
            "The account has reached the enhanced fan-out data transfer quota (2 MB/s per shard per consumer)",
            "Enhanced fan-out requires one shard per consumer, and 50 shards can only support 5 consumers with proper distribution"
          ],
          "correctAnswer": 0,
          "explanation": "Kinesis Data Streams enhanced fan-out allows consumers to get dedicated 2 MB/s throughput per shard without sharing with other consumers. However, there's a hard limit of 5 registered enhanced fan-out consumers per stream. In this scenario, 8 Lambda functions are trying to use enhanced fan-out, exceeding the 5-consumer limit. Some consumers will fail registration or experience throttling. The solution is to either: (1) Use standard (shared) consumers for some functions, (2) Combine multiple Lambda functions under a single enhanced fan-out consumer using KCL with multiple workers, or (3) Split data across multiple streams. Option B is false - Lambda supports enhanced fan-out via event source mapping. Option C states the throughput spec incorrectly - 2 MB/s per shard per consumer is the provided throughput, not a quota limit. Option D is incorrect - the number of shards doesn't dictate consumer limits; the 5-consumer limit is independent of shard count. This tests awareness of Kinesis enhanced fan-out consumer limits."
        },
        {
          "question": "An ECS application uses AWS Cloud Map for service discovery with a private DNS namespace. Services in VPC-A can resolve and connect to each other. The company adds services in VPC-B (peered with VPC-A) but those services cannot resolve the Cloud Map DNS names. What is missing?",
          "options": [
            "Cloud Map private DNS namespaces only work within a single VPC and cannot span VPC peering connections",
            "The VPC-B DNS resolver needs to be configured with conditional forwarding rules to VPC-A",
            "Cloud Map requires Route 53 Resolver inbound endpoints in VPC-A for cross-VPC resolution",
            "VPC-B must be associated with the Cloud Map private DNS namespace for DNS resolution to work"
          ],
          "correctAnswer": 3,
          "explanation": "AWS Cloud Map private DNS namespaces create Route 53 private hosted zones under the hood. Private hosted zones must be explicitly associated with VPCs for DNS resolution to work in those VPCs. Even though VPC-A and VPC-B are peered, the private hosted zone created by Cloud Map is initially only associated with VPC-A. Services in VPC-B cannot resolve those DNS names because their VPC isn't associated with the hosted zone. The solution is to associate VPC-B with the Cloud Map namespace (which associates it with the underlying private hosted zone). This can be done through the Cloud Map API or Route 53 console. Option A is incorrect - private hosted zones DO work across peered VPCs when properly associated. Option B is overly complex and unnecessary for peered VPCs with associated hosted zones. Option C is incorrect - Resolver endpoints are for hybrid DNS scenarios, not cross-VPC within AWS. This tests understanding that Cloud Map private namespaces use Route 53 private hosted zones requiring explicit VPC associations."
        },
        {
          "question": "A financial system uses an SQS FIFO queue with content-based deduplication enabled. They send transaction records to the queue. During an incident, the same transaction is sent twice within a 1-minute window, but both messages are delivered to consumers, causing duplicate processing. What is the MOST likely cause?",
          "options": [
            "Content-based deduplication only works for messages sent more than 5 minutes apart",
            "The two transaction messages have different MessageAttributes, which are included in deduplication hash",
            "Content-based deduplication uses the entire message body, and some timestamp or UUID field differs between messages",
            "FIFO queues require explicit MessageDeduplicationId; content-based deduplication is only a fallback"
          ],
          "correctAnswer": 2,
          "explanation": "SQS FIFO queues provide exactly-once processing using deduplication. You can either provide an explicit MessageDeduplicationId or enable content-based deduplication, which generates the ID by hashing the message body. Content-based deduplication uses SHA-256 of the message body - any difference in the body, even a single character, results in a different hash and treats messages as unique. If the application includes timestamps, request IDs, or other variable fields in the message body, identical transactions will have different message bodies and won't be deduplicated. The solution is to either: (1) Exclude variable fields from the message body and put them in MessageAttributes instead, (2) Use explicit MessageDeduplicationId based on business logic (transaction ID), or (3) Normalize the message body before sending. Option A is false - the deduplication window is 5 minutes, not a minimum interval. Option B is incorrect - MessageAttributes are NOT included in content-based deduplication hash. Option D is misleading - both methods are valid primary options. This tests understanding of content-based deduplication behavior and common pitfalls."
        },
        {
          "question": "An ALB routes traffic to Lambda functions. The Lambda function receives HTTP requests with multiple Cookie headers (from different sources like browser, proxy). When the function accesses the headers, it only sees one Cookie value. What is the issue and solution?",
          "options": [
            "ALB limits HTTP headers to single values; use NLB for multi-value header support",
            "ALB combines duplicate headers into a comma-separated list; the Lambda must parse it",
            "Lambda functions receive headers in a different format when invoked by ALB; check the multiValueHeaders field in the event",
            "This is a limitation of Lambda function URLs; use API Gateway instead for full HTTP header support"
          ],
          "correctAnswer": 2,
          "explanation": "When an Application Load Balancer invokes a Lambda function, it sends an event with a specific structure. Multi-value headers (like multiple Cookie headers) are provided in the multiValueHeaders field as an object where each header name maps to an array of values. If your Lambda function only reads the headers field, it only sees a single value (usually the last one). The solution is to check event.multiValueHeaders instead of event.headers. Similarly, multiValueQueryStringParameters exists for query strings with duplicate parameter names. Option A is incorrect - NLB doesn't support Lambda targets. Option B is partially true for some headers in some contexts, but ALB with Lambda specifically uses multiValueHeaders. Option D is incorrect - this is about ALB to Lambda integration, not Lambda function URLs. This tests understanding of the ALB-to-Lambda event structure and the distinction between headers and multiValueHeaders fields, which is a common source of bugs."
        }
      ]
    },
    {
      "filename": "advanced-scenarios-batch-3.json",
      "domain": "Domain 3: Continuous Improvement for Existing Solutions",
      "task": "Advanced Scenarios - Optimization, Operations, Performance, Cost",
      "question_count": 15,
      "questions": [
        {
          "question": "A company stores 500 TB of log data in S3 that must be retained for 7 years for compliance. They enable S3 Intelligent-Tiering to optimize costs. After 6 months, they notice most data is still in the Frequent Access tier despite not being accessed. What is the MOST likely issue?",
          "options": [
            "Intelligent-Tiering only monitors object access at the bucket level, not individual objects",
            "The objects are smaller than 128 KB, which are not eligible for automatic tiering",
            "Archive Access tiers must be explicitly enabled in the Intelligent-Tiering configuration; they're not enabled by default",
            "Lifecycle policies are conflicting with Intelligent-Tiering transitions"
          ],
          "correctAnswer": 2,
          "explanation": "S3 Intelligent-Tiering automatically moves objects between access tiers based on access patterns, but the Archive Access and Deep Archive Access tiers are NOT enabled by default. Objects automatically move between Frequent Access (for accessed objects) and Infrequent Access (for objects not accessed for 30 days) by default. To use Archive Access (90+ days) and Deep Archive Access (180+ days), you must explicitly opt-in by configuring archive settings on the bucket. Many architects assume all tiers are automatic, missing potential cost savings. Option A is incorrect - Intelligent-Tiering monitors individual object access. Option B is true (objects under 128 KB stay in Frequent Access and are charged monitoring fees) but the scenario describes 500 TB of logs which are typically large files. Option D is unlikely - lifecycle policies and Intelligent-Tiering can coexist. The solution is to enable Archive Access and Deep Archive Access tiers in the Intelligent-Tiering configuration. This tests understanding of Intelligent-Tiering's default behavior and optional archive tiers."
        },
        {
          "question": "An application uses RDS MySQL with a read replica for reporting queries. Users report that recently updated data doesn't appear in reports for several minutes. Monitoring shows replica lag averaging 2-3 minutes during business hours. The primary instance has 20% CPU utilization. What is the MOST effective solution?",
          "options": [
            "Upgrade the read replica to a larger instance class to reduce lag",
            "Enable Multi-AZ on the primary to improve replication performance",
            "Reduce the number of write transactions on the primary database",
            "Investigate network connectivity issues between the primary and replica"
          ],
          "correctAnswer": 0,
          "explanation": "RDS read replica lag occurs when the replica cannot apply changes from the primary as fast as they're generated. Even though the primary has low CPU (20%), replication lag is often due to the replica's resources being insufficient to keep up with applying changes. Replication in RDS is single-threaded for MySQL (until MySQL 8.0's parallel replication features), so CPU-intensive operations on the replica during log application can cause lag. Upgrading the replica instance class provides more CPU and I/O capacity for applying changes. Additionally, check if the replica is handling read queries that compete with replication for resources. Option B is incorrect - Multi-AZ doesn't affect read replica performance; it's for high availability of the primary. Option C is impractical - reducing writes defeats the purpose of the database. Option D is possible but less likely given consistent lag; network issues typically cause sporadic lag spikes. The key insight is that replica lag is often a replica-side resource constraint, not a primary-side issue. Consider enabling parallel replication (MySQL 8.0+) or upgrading replica instance size."
        },
        {
          "question": "A security team runs CloudWatch Logs Insights queries against 100 GB of application logs spanning 30 days. Queries take 2-3 minutes to complete and incur high costs. They need to improve performance and reduce costs. What is the BEST approach?",
          "options": [
            "Use CloudWatch Logs subscriptions to stream logs to S3, then query with Athena for better performance",
            "Reduce the time range of queries to 7 days or less to scan less data",
            "Increase the CloudWatch Logs Insights query timeout to allow for more thorough analysis",
            "Create CloudWatch Logs metric filters to pre-aggregate common queries"
          ],
          "correctAnswer": 0,
          "explanation": "CloudWatch Logs Insights charges based on data scanned and can be slow for large datasets. For analysis of large log volumes or historical data, exporting logs to S3 and querying with Amazon Athena provides better performance and lower costs. Athena uses columnar storage (Parquet), partitioning, and distributed processing to scan data efficiently. You can set up a CloudWatch Logs subscription filter to automatically stream logs to Kinesis Data Firehose, which delivers to S3 in Parquet format. This architecture supports complex ad-hoc queries at a fraction of the cost. Option B reduces costs but limits analysis capability - not a solution if they need 30-day analysis. Option C doesn't improve performance or cost, just allows longer wait times. Option D works for known, repetitive queries but doesn't help with ad-hoc security investigations. The key learning is that CloudWatch Logs Insights is designed for interactive debugging and recent logs; for large-scale analytics, export to S3 + Athena is more appropriate. This tests understanding of when to use different log analysis tools."
        },
        {
          "question": "A company enables Point-in-Time Recovery (PITR) on their DynamoDB table for disaster recovery. During a DR test, they attempt to restore the table to a state from 30 seconds ago but find they can only restore to a state from 5 minutes ago. What explains this limitation?",
          "options": [
            "PITR granularity is 5 minutes; you cannot restore to arbitrary seconds-level precision",
            "The most recent 5 minutes of data is not eligible for restoration due to backup processing lag",
            "DynamoDB PITR requires at least 5 minutes between restore points for data consistency",
            "The table is in on-demand mode, which only supports 5-minute PITR granularity"
          ],
          "correctAnswer": 1,
          "explanation": "DynamoDB Point-in-Time Recovery allows you to restore to any point in time within the last 35 days with second-level granularity - but not the most recent 5 minutes. This is because PITR works by continuously backing up data, and there's a lag (approximately 5 minutes) for the backup data to be processed and made available for restoration. The restorable window is from 5 minutes ago to 35 days ago, not the current moment. This is a critical detail for RPO planning: your effective RPO with PITR is 5 minutes, not seconds. Option A is incorrect - granularity is second-level, just not for the most recent 5 minutes. Option C incorrectly suggests a minimum interval requirement. Option D is false - PITR behavior is the same for on-demand and provisioned modes. Architects must understand this 5-minute lag when planning DR strategies. For lower RPO, you need application-level replication or Global Tables. This tests awareness of PITR's operational characteristics and its impact on recovery point objectives."
        },
        {
          "question": "A company runs a mix of EC2 workloads: t3.large for web servers (24/7), m5.xlarge for batch processing (12 hours/day), and r5.2xlarge for analytics (variable usage). They want to maximize savings. Their instance families and regions are stable, but specific instance sizes vary monthly. What's the BEST purchasing strategy?",
          "options": [
            "EC2 Instance Savings Plans for maximum flexibility across instance sizes within families",
            "Compute Savings Plans for maximum flexibility across instance families and regions",
            "Standard Reserved Instances for maximum discount, with Convertible RIs for variable workloads",
            "Mix of EC2 Instance Savings Plans for stable workloads and On-Demand Capacity Reservations for variable ones"
          ],
          "correctAnswer": 0,
          "explanation": "For workloads with stable instance families but variable instance sizes, EC2 Instance Savings Plans provide the optimal balance of flexibility and savings. They offer up to 72% discount (similar to Standard RIs) and apply to any size within a specific instance family in a specific region (e.g., all m5 instances in us-east-1). You can change between t3.small, t3.medium, t3.large without losing the discount. Compute Savings Plans (Option B) offer more flexibility but lower discount (up to 66%), which isn't optimal if your families are stable. Standard RIs (Option C) offer similar discounts but require you to specify exact instance size and commit for 1-3 years with less flexibility. Option D incorrectly suggests On-Demand Capacity Reservations, which provide capacity guarantees but no discount (combine with Savings Plans for discounts). The key decision factors: Instance Savings Plans = family flexibility, Compute Savings Plans = maximum flexibility with lower discount, RIs = highest discount with least flexibility. This tests understanding of the savings options trade-off matrix."
        },
        {
          "question": "An application uses a 500 GB gp2 volume providing 1,500 IOPS (3 IOPS per GB). The team wants to improve performance and considers migrating to gp3. They need 4,000 IOPS and 250 MB/s throughput. What's the MOST cost-effective approach?",
          "options": [
            "Migrate to gp3 500 GB with 4,000 IOPS and 250 MB/s provisioned - lower cost than increasing gp2 volume size",
            "Increase gp2 volume to 1,334 GB to get 4,000 IOPS (3 IOPS per GB), which is more cost-effective than gp3",
            "Use io2 volumes instead as gp3 doesn't support provisioned IOPS above 3,000",
            "Keep gp2 but enable EBS-optimized instances to increase throughput to 250 MB/s"
          ],
          "correctAnswer": 0,
          "explanation": "gp3 volumes fundamentally changed the EBS economics by decoupling volume size from performance. gp2 provides 3 IOPS per GB (minimum 100, maximum 16,000), so to get 4,000 IOPS you'd need a 1,334 GB volume. gp3 provides baseline 3,000 IOPS and 125 MB/s for ANY size, with ability to provision up to 16,000 IOPS and 1,000 MB/s independently. For the scenario: gp3 500 GB with 4,000 IOPS and 250 MB/s provisioned costs significantly less than a 1,334 GB gp2 volume. The gp3 pricing is: base storage cost + additional IOPS cost (above 3,000) + additional throughput cost (above 125 MB/s). Option B is mathematically correct about how to achieve 4,000 IOPS with gp2 but more expensive. Option C is false - gp3 supports up to 16,000 IOPS. Option D is incorrect - EBS-optimized instances affect instance-to-EBS bandwidth, not volume throughput limits. The key insight: for any workload needing IOPS/GB ratio different from 3:1, gp3 is typically more cost-effective. This tests understanding of gp3's independent performance provisioning."
        },
        {
          "question": "A web application uses AWS WAF with a rate-based rule to block IPs making more than 2,000 requests per 5 minutes. During an attack, the rule doesn't block malicious traffic coming from thousands of different IP addresses, each making 100 requests. What should they modify?",
          "options": [
            "Reduce the rate limit to 100 requests per 5 minutes to catch the distributed attack",
            "Change the aggregation key to use a custom header or URI path instead of source IP",
            "Rate-based rules can't defend against distributed attacks; use AWS Shield Advanced instead",
            "Add a second rate-based rule with a lower threshold and combine with AND logic"
          ],
          "correctAnswer": 1,
          "explanation": "AWS WAF rate-based rules count requests based on an aggregation key, which by default is the source IP address. In a distributed attack from thousands of IPs, each IP stays under the threshold individually. To defend against this, you can change the aggregation key to match your use case: for example, aggregate by a session token header, API key, or URI path. This way, you're counting requests per user session or per resource instead of per IP. If an attacker uses thousands of IPs but targets the same API endpoint, aggregating by URI path would catch the attack. Option A would help but causes false positives for legitimate users and doesn't address the fundamental issue. Option C is incorrect - rate-based rules CAN defend against distributed attacks with proper aggregation; Shield Advanced protects against DDoS at network/transport layer, not application-layer rate limiting. Option D won't help - combining rules doesn't change how individual rules aggregate. The key learning is that WAF rate-based rule aggregation keys are customizable beyond just source IP. This tests understanding of advanced WAF configurations."
        },
        {
          "question": "An application uses ElastiCache Redis (cluster mode disabled) with a single shard and 5 read replicas. They're approaching 25 GB memory usage (nearing the r6g.large 26 GB limit) and need to scale. What's the MOST appropriate solution?",
          "options": [
            "Add more read replicas to distribute the data across more nodes",
            "Migrate to cluster mode enabled to shard data across multiple primary nodes",
            "Upgrade to a larger node type like r6g.xlarge for the primary and replicas",
            "Enable Multi-AZ to automatically distribute data across availability zones"
          ],
          "correctAnswer": 1,
          "explanation": "ElastiCache Redis has two cluster modes: (1) Cluster mode disabled - single shard (primary + up to 5 replicas), limited by single-node memory, scales reads but not writes or memory. (2) Cluster mode enabled - multiple shards (each with primary + replicas), distributes data across shards, scales reads, writes, and memory. The scenario describes a memory limit issue. Read replicas (Option A) don't help memory constraints - they replicate the full dataset. Upgrading node type (Option C) helps temporarily but doesn't provide horizontal scaling. Migrating to cluster mode enabled allows sharding data across multiple primary nodes (up to 500 shards), breaking the single-node memory limit. For example, 50 GB data can be sharded across 2 r6g.large nodes (25 GB each). Option D (Multi-AZ) is for availability, not capacity scaling. The key distinction: cluster mode disabled = vertical scaling only, cluster mode enabled = horizontal scaling. The migration requires application changes to support sharding (consistent hashing), so it's a significant architectural change. This tests understanding of Redis scaling limitations and cluster mode capabilities."
        },
        {
          "question": "An e-commerce application uses Aurora Serverless v2 configured with 0.5 to 16 ACUs. During flash sales, response times spike to 5-10 seconds for the first minute before improving. CloudWatch shows ACU scaling from 0.5 to 8 within that minute. What's the issue?",
          "options": [
            "Aurora Serverless v2 takes 30-60 seconds to scale up, causing the latency spike",
            "The minimum ACU of 0.5 is too low; increase to 2 ACUs to maintain better baseline performance",
            "Serverless v2 scaling is not instantaneous; pre-warm capacity by manually scaling before expected traffic",
            "The application connection pool is too small, causing connection exhaustion during scaling"
          ],
          "correctAnswer": 1,
          "explanation": "While Aurora Serverless v2 scales much faster than v1 (increments in seconds vs minutes), it still experiences performance impact when scaling from very low baseline capacity. Starting at 0.5 ACU means the database has minimal resources when the flash sale begins. Even though it scales to 8 ACU within a minute, the initial seconds at low capacity cause query queuing and latency. Increasing the minimum ACU to a higher baseline (e.g., 2-4 ACU) ensures better baseline performance for the initial burst while still providing cost savings during low-traffic periods. Option A overstates scaling time - Serverless v2 scales in ~15-30 seconds typically, not 30-60. Option C is partially valid but not the best solution - scheduled scaling or application warming can help, but maintaining a higher minimum is simpler. Option D is possible but less likely to cause consistent 5-10 second spikes. The key insight: Serverless v2 minimum ACU should be set based on your baseline performance requirements, not just cost minimization. Very low minimums (0.5 ACU) work for dev/test but may not suit production workloads with variable traffic. This tests understanding of Serverless v2 scaling behavior and capacity planning."
        },
        {
          "question": "A Lambda function processes API requests with a 30-second timeout and 128 MB memory. Users occasionally experience timeouts during cold starts. Increasing timeout to 60 seconds doesn't help. CloudWatch shows cold start initialization takes 25-30 seconds. What should they do?",
          "options": [
            "Continue increasing timeout as cold starts are inherently slow and unpredictable",
            "Increase memory allocation to 512 MB or higher to get more CPU and reduce initialization time",
            "Enable provisioned concurrency to eliminate cold starts entirely",
            "Reduce the deployment package size to speed up cold start initialization"
          ],
          "correctAnswer": 1,
          "explanation": "Lambda allocates CPU power proportionally to memory configuration. At 128 MB, the function gets minimal CPU. Cold start initialization time includes downloading and extracting the deployment package, initializing the runtime, and running initialization code. All of these are CPU-bound operations that benefit from more CPU power. Increasing memory to 512 MB or 1024 MB provides more CPU, potentially reducing cold start time from 25-30 seconds to 5-10 seconds. This is often more cost-effective than provisioned concurrency. Option A is incorrect - there are solutions beyond just waiting longer. Option C (provisioned concurrency) works but has ongoing cost; increasing memory is more cost-effective for occasional cold starts. Option D helps but typically provides marginal improvement compared to CPU increase. The key insight: Lambda memory isn't just about RAM - it's the primary way to allocate CPU. The pricing increase for higher memory is often offset by faster execution and reduced cold starts. Best practice: benchmark your function at different memory levels (128, 256, 512, 1024, 1536 MB) and find the cost-performance sweet spot. This tests understanding of Lambda resource allocation and cold start optimization."
        },
        {
          "question": "A company enables S3 Cross-Region Replication (CRR) from us-east-1 to eu-west-1 for a bucket with 10 TB of existing data. After 24 hours, only new objects are replicating; existing objects haven't replicated. What's the issue?",
          "options": [
            "CRR only replicates objects created after CRR is enabled; existing objects need to be copied separately",
            "The replication IAM role lacks permissions to read existing objects",
            "S3 Batch Replication must be initiated separately to replicate existing objects",
            "CRR requires versioning to be enabled on both buckets before any objects are created"
          ],
          "correctAnswer": 2,
          "explanation": "S3 Cross-Region Replication (CRR) and Same-Region Replication (SRR) only replicate objects created AFTER the replication configuration is enabled. Existing objects are not automatically replicated. To replicate existing objects, you must use S3 Batch Replication, which creates a batch job to replicate objects that existed before replication was configured. This is a common gotcha - architects enable CRR expecting all data to replicate automatically. Option A is partially correct but doesn't mention the specific solution (Batch Replication). Option B is unlikely - if the role lacked permissions, new objects wouldn't replicate either. Option D is true that versioning is required, but the question states CRR is working for new objects, so versioning must be configured. The process should be: (1) Enable versioning on both buckets, (2) Configure CRR, (3) Create S3 Batch Replication job for existing objects. Batch Replication allows you to replicate existing objects, objects that previously failed to replicate, or objects that were replicated but have since been deleted. This tests understanding of S3 replication behavior for existing vs new objects."
        },
        {
          "question": "A database team uses RDS Performance Insights to troubleshoot query performance. The dashboard shows 'wait events' accounting for 80% of DB load, with 'CPU' showing only 20%. They upgrade the instance to double the CPU capacity, but performance doesn't improve. Why?",
          "options": [
            "The instance size increase didn't affect the wait events, which are typically caused by lock contention, I/O bottlenecks, or network latency, not CPU",
            "Performance Insights takes 24-48 hours to reflect instance size changes in metrics",
            "RDS requires a reboot after instance type change for Performance Insights to recognize new CPU capacity",
            "The primary bottleneck is storage IOPS, which doesn't scale with instance size"
          ],
          "correctAnswer": 0,
          "explanation": "RDS Performance Insights shows DB load broken down into wait events and CPU. Wait events represent time spent waiting for resources: I/O (storage), locks (row-level or table-level), network, memory, etc. If 80% of load is wait events and only 20% is CPU, adding more CPU won't help - the bottleneck isn't CPU. You need to investigate which specific wait events are dominant. Common wait events: 'io/file/innodb' (storage I/O bottleneck - increase IOPS), 'synch/mutex' (lock contention - optimize queries or schema), 'io/socket' (network - check network performance or query result size). Option B is false - metrics update in real-time. Option C is incorrect - reboot doesn't affect Performance Insights. Option D is partially true (IOPS may be the issue) but too specific; the key point is understanding wait events vs CPU. The lesson: Performance Insights separates resource consumption into categories. Address the actual bottleneck (wait events) rather than assuming CPU is the issue. This tests understanding of database performance analysis beyond just CPU metrics."
        },
        {
          "question": "A company implements cost allocation tags across all resources in January. In February, they run Cost Explorer reports with tag filters, but January costs don't show tag breakdowns - only February costs do. What explains this?",
          "options": [
            "Cost allocation tags require 24-48 hours to propagate and cannot be retroactively applied to historical costs",
            "Cost allocation tags must be activated in the Billing console and only apply to costs incurred after activation",
            "January costs are still being finalized by AWS and tags will appear after the billing period closes",
            "Cost Explorer requires at least 2 months of data before showing tag-based reports"
          ],
          "correctAnswer": 1,
          "explanation": "Cost allocation tags must be activated in the AWS Billing and Cost Management console before they appear in Cost Explorer and cost allocation reports. Importantly, they only apply to costs incurred AFTER the tag is activated - they cannot be retroactively applied to past costs. If you activate a tag on February 1st, only costs from February 1st onward will have that tag dimension available in reports. January costs, even if the resources had the tags applied, won't show the tag breakdown. This is a critical consideration for cost allocation planning: activate tags before deploying resources, not after. Option A is incorrect - tags don't propagate retroactively at all, not even after 48 hours. Option C is false - billing data finalization doesn't affect tag visibility. Option D is incorrect - Cost Explorer works immediately with activated tags. Best practice: activate cost allocation tags (both AWS-generated and user-defined) early in account setup, before deploying production resources. This tests understanding of cost allocation tag activation timing and its impact on cost reporting."
        },
        {
          "question": "A company has a VPC with a single NAT Gateway in us-east-1a handling outbound traffic for workloads across 3 AZs. During peak hours, they experience intermittent connectivity issues and packet loss. CloudWatch shows NAT Gateway throughput at 45 Gbps. What's the issue?",
          "options": [
            "NAT Gateway has a hard limit of 45 Gbps; they need to implement NAT Instances for higher throughput",
            "Cross-AZ traffic to the single NAT Gateway creates bandwidth bottlenecks and increased costs; deploy NAT Gateways in each AZ",
            "NAT Gateway throttles at 45 Gbps during peak hours; request a limit increase from AWS Support",
            "The NAT Gateway's associated Elastic IP has a bandwidth limit that's being exceeded"
          ],
          "correctAnswer": 1,
          "explanation": "While NAT Gateway can scale to 100 Gbps, the architectural issue is having a single NAT Gateway serving workloads across multiple AZs. Cross-AZ data transfer creates several problems: (1) Bandwidth bottleneck at the single AZ, (2) Cross-AZ data transfer costs (significant), (3) Single point of failure. Best practice is to deploy a NAT Gateway in each AZ and configure route tables so resources use the NAT Gateway in their own AZ. This provides redundancy, reduces costs, and distributes bandwidth. Option A is incorrect - NAT Gateway can handle up to 100 Gbps, and NAT Instances would be more complex and likely lower performance. Option C is misleading - 45 Gbps isn't a throttling threshold; NAT Gateway scales automatically. Option D is false - Elastic IPs don't have bandwidth limits separate from the associated resource. The key learning: NAT Gateway architecture should follow AZ-alignment for cost, performance, and resilience. This tests understanding of NAT Gateway scaling and multi-AZ design patterns."
        },
        {
          "question": "A data analytics team uses a Redshift cluster and enables concurrency scaling to handle query spikes. Their monthly Redshift bill increases 300% despite the cluster size remaining constant. What's the MOST likely cause?",
          "options": [
            "Concurrency scaling is billed separately from the cluster and they're incurring significant concurrency scaling charges",
            "Redshift automatically upgraded their cluster size due to concurrency scaling being enabled",
            "Cross-region data transfer costs increased due to concurrency scaling queries",
            "Concurrency scaling requires additional storage which is being billed"
          ],
          "correctAnswer": 0,
          "explanation": "Redshift concurrency scaling automatically adds cluster capacity to handle bursts in query load. While this provides great performance for users, it incurs separate charges based on the seconds of usage. Concurrency scaling charges accumulate when queries are routed to concurrency scaling clusters. AWS provides one hour of free concurrency scaling credits per day per cluster, but beyond that, charges apply. If the team has sustained high query concurrency or long-running queries, they could easily consume far more than the free tier, resulting in significant costs. Option B is false - concurrency scaling doesn't change the base cluster size. Option C is unlikely - concurrency scaling doesn't inherently cause cross-region transfer. Option D is incorrect - concurrency scaling doesn't require additional storage. The solution is to monitor concurrency scaling usage in CloudWatch (ConcurrencyScalingSeconds metric), optimize queries to reduce duration, implement workload management queues to control concurrency, or disable concurrency scaling if the cost isn't justified. This tests understanding of Redshift concurrency scaling billing model and its potential cost impact."
        }
      ]
    },
    {
      "filename": "advanced-scenarios-batch-4.json",
      "domain": "Domain 4: Accelerate Workload Migration and Modernization",
      "task": "Advanced Scenarios - Migration Strategies, Modernization, Tools",
      "question_count": 15,
      "questions": [
        {
          "question": "A company uses AWS DMS to migrate an Oracle database to Aurora PostgreSQL with ongoing replication (CDC). After the initial full load completes successfully, CDC replication starts but only captures changes from some tables. DMS task logs show 'table has no primary key' warnings for tables that aren't replicating. What's the issue?",
          "options": [
            "DMS CDC requires all tables to have primary keys; add primary keys to the missing tables or use table-level transformations",
            "Oracle supplemental logging is not enabled at the database level for tables without primary keys",
            "Aurora PostgreSQL doesn't support CDC for tables without primary keys; add unique indexes instead",
            "DMS task configuration must explicitly enable CDC for tables without primary keys in the table mappings"
          ],
          "correctAnswer": 1,
          "explanation": "AWS DMS Change Data Capture (CDC) from Oracle requires supplemental logging to be enabled. For tables WITH primary keys, minimal supplemental logging at the database level is sufficient. However, for tables WITHOUT primary keys, you must enable supplemental logging at the table level or use database-level supplemental logging with ALL COLUMNS. The warning 'table has no primary key' indicates DMS cannot properly track changes because it doesn't have enough information from Oracle redo logs to identify which row changed. The solution is to enable supplemental logging: ALTER TABLE schema.table ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS; or enable it database-wide. Option A is incorrect - while primary keys help, DMS can handle tables without them if supplemental logging is configured. Option C is false - Aurora PostgreSQL support isn't the issue; Oracle configuration is. Option D is incorrect - table mappings don't have a CDC enable/disable per table based on primary keys. This tests understanding of Oracle-specific DMS requirements for CDC."
        },
        {
          "question": "During an application migration using AWS MGN, the source server shows 'Replication lag: 6 hours' despite having a stable network connection and the replication server running. The source disk has 80% free space. What is the MOST likely cause?",
          "options": [
            "The source server is experiencing high disk write activity that exceeds the replication bandwidth",
            "The replication server instance type is too small to handle the replication workload",
            "MGN replication lag is normal and will catch up after cutover",
            "The source server's MGN agent is not properly configured for continuous replication"
          ],
          "correctAnswer": 0,
          "explanation": "AWS MGN (Application Migration Service, formerly CloudEndure) performs continuous block-level replication. Replication lag occurs when changes on the source are generated faster than they can be replicated to AWS. High disk write activity (database updates, log files, temporary files, etc.) creates change rate that exceeds available bandwidth or replication throughput. Even with sufficient network bandwidth, the replication process must read changed blocks, compress them, transmit, and write to staging disks. If the source has sustained high I/O (e.g., busy database), lag accumulates. Solutions: (1) Increase bandwidth, (2) Reduce source write activity during migration, (3) Exclude high-churn non-essential files from replication, or (4) Schedule cutover during low-activity periods to allow lag to catch up. Option B is possible but less common - MGN auto-sizes replication servers. Option C is dangerous - significant lag means the target is hours behind the source. Option D is unlikely if replication is working, just lagging. This tests understanding of MGN replication dynamics and troubleshooting lag issues."
        },
        {
          "question": "A DMS task migrates a PostgreSQL database containing tables with BYTEA (binary) columns storing images averaging 5 MB each. The task uses 'Full LOB mode' but runs extremely slowly. Switching to 'Limited LOB mode' with 100 KB lob_max_size causes data truncation errors. What's the BEST solution?",
          "options": [
            "Use 'Limited LOB mode' with lob_max_size set to 10 MB to accommodate the largest LOBs",
            "Use 'Inline LOB mode' which handles LOBs more efficiently than Full or Limited modes",
            "Split tables with LOBs into separate DMS tasks using parallel processing",
            "Migrate the table structure with DMS, then use S3 and custom scripts for LOB data migration"
          ],
          "correctAnswer": 0,
          "explanation": "AWS DMS has three LOB handling modes: (1) Full LOB mode - migrates LOBs of any size but very slow (fetches each LOB separately), (2) Limited LOB mode - faster, loads LOBs inline up to lob_max_size, truncates larger ones, (3) Inline LOB mode - treats all LOBs as limited with a default size. For LOBs averaging 5 MB, Limited LOB mode with lob_max_size of 10 MB (to handle variability) provides the best performance without truncation. Full LOB mode's performance issue is that it requires extra round trips to fetch each LOB. Limited LOB mode with appropriate max size gives near-inline performance. Option B is incorrect - Inline LOB is essentially Limited LOB with a fixed default. Option C adds complexity without addressing the fundamental LOB handling issue. Option D is overly complex when DMS can handle it with proper configuration. The key is choosing the right LOB mode and sizing: use Limited LOB with max size set to slightly larger than your largest expected LOB for optimal migration performance. This tests understanding of DMS LOB migration modes and performance tuning."
        },
        {
          "question": "A company uses AWS Migration Hub Strategy Recommendations to analyze their application portfolio. The tool recommends 'Rehost' for a .NET Framework 4.5 application currently running on Windows Server 2012. However, the application team knows the application could easily be containerized. Why might the tool recommend Rehost over Replatform?",
          "options": [
            "Migration Hub only analyzes technical dependencies, not code quality or containerization readiness",
            "The tool prioritizes low-risk migrations and recommends Rehost as the safest option by default",
            "Migration Hub Strategy Recommendations requires application source code access for Replatform recommendations",
            "The tool detected dependencies on Windows-specific features that would complicate containerization"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Migration Hub Strategy Recommendations uses automated analysis (runtime data, dependencies, resource utilization) to provide migration strategy suggestions. It follows the 7 Rs framework: Retire, Retain, Rehost, Relocate, Repurchase, Replatform, Refactor. The tool tends toward conservative recommendations - it suggests Rehost (lift-and-shift) as the default lowest-risk option unless it identifies clear opportunities for other strategies. Just because an application CAN be containerized doesn't mean the tool will recommend it. The tool looks for specific patterns like: stateless applications, modern frameworks, microservices architecture, etc. A .NET Framework 4.5 app on Windows Server 2012 might not show strong signals for containerization in the automated analysis. The recommendations are a starting point - you should apply business and technical judgment to choose the optimal strategy. Option A is partially true but doesn't explain the Rehost recommendation. Option C is false - the tool doesn't require source code. Option D is possible but not the primary reason. This tests understanding that migration tools provide guidance, not prescriptive decisions, and tend toward conservative recommendations."
        },
        {
          "question": "A company needs to migrate 500 VMs from VMware to AWS with minimal downtime (under 30 minutes). They're choosing between AWS SMS and AWS MGN. The VMs include database servers with continuous write activity. What should they choose and why?",
          "options": [
            "AWS SMS because it's specifically designed for VMware migrations with lower cutover time",
            "AWS MGN because it provides continuous block-level replication and supports minimal downtime cutover",
            "AWS SMS because MGN doesn't support VMware source environments",
            "Either service is equally appropriate; the choice depends on licensing preference"
          ],
          "correctAnswer": 1,
          "explanation": "AWS MGN (Application Migration Service) has largely replaced AWS SMS (Server Migration Service) as the recommended migration tool. Key differences: (1) SMS does scheduled snapshot-based replication (incremental after initial), suitable for low-change workloads, longer cutover windows acceptable. (2) MGN does continuous block-level replication, suitable for high-change workloads (like databases), minimal downtime cutover (minutes). For the scenario with database servers requiring under 30 minutes downtime, MGN is appropriate because it continuously replicates changes, keeping the target very close to source (minimal lag), allowing quick cutover. SMS would require a final snapshot replication before cutover, which could take significant time for active databases. Option A is incorrect - SMS has longer cutover times. Option C is false - MGN supports VMware, Physical, and Azure sources. Option D is incorrect - MGN is technically superior for this use case. Note: AWS has announced SMS will reach end of support, making MGN the strategic choice. This tests understanding of migration service selection based on downtime requirements and workload characteristics."
        },
        {
          "question": "A DMS task migrates a 2 TB MySQL database with 200 tables to Aurora MySQL. The task uses a dms.c5.4xlarge replication instance but throughput is only 50 MB/s. CloudWatch shows the replication instance CPU at 25% and network at 30%. What optimization would MOST likely improve throughput?",
          "options": [
            "Increase MaxFullLoadSubTasks to parallelize loading more tables simultaneously",
            "Increase ParallelLoadThreads for each table to use multiple threads per table",
            "Upgrade to a larger replication instance class for more CPU and network capacity",
            "Enable Multi-AZ for the replication instance to distribute load across availability zones"
          ],
          "correctAnswer": 0,
          "explanation": "AWS DMS full load performance can be tuned using two key parameters: (1) MaxFullLoadSubTasks - number of tables loaded in parallel (default 8), (2) ParallelLoadThreads - number of threads used per table for partitioned loads. With 200 tables and low resource utilization (25% CPU, 30% network), the bottleneck is not hardware but parallelism. Increasing MaxFullLoadSubTasks from the default 8 to 16 or 32 allows more tables to be migrated simultaneously, better utilizing the replication instance. The c5.4xlarge has 16 vCPUs, so it can easily handle more parallel tasks. Option B (ParallelLoadThreads) helps when you have a few very large tables, but requires LOB columns or partitioning configuration. With 200 tables, table-level parallelism (MaxFullLoadSubTasks) is more impactful. Option C is premature - the existing instance is underutilized. Option D is incorrect - Multi-AZ is for high availability, not performance. The key insight: DMS performance tuning starts with parallelism settings before hardware scaling. This tests understanding of DMS performance tuning parameters."
        },
        {
          "question": "A company has a 50 TB on-premises file server that needs low-latency access to frequently used files (10 TB) while maintaining access to all data. They have 100 Mbps internet connectivity. Which Storage Gateway configuration is MOST appropriate?",
          "options": [
            "File Gateway with S3 bucket, using caching for frequently accessed files",
            "Volume Gateway in Cached mode with 10 TB local cache",
            "Volume Gateway in Stored mode with all data stored locally and backed up to S3",
            "Tape Gateway for cost-effective long-term storage of infrequently accessed files"
          ],
          "correctAnswer": 0,
          "explanation": "The scenario describes a file server use case with tier-based access patterns (hot 10 TB, total 50 TB). AWS Storage Gateway File Gateway is designed for this: it presents SMB/NFS shares backed by S3, with local cache for frequently accessed files. The cache (sized based on your local hardware) stores hot data for low-latency access, while all data resides in S3. Metadata is cached locally for fast file listing. This is ideal for file servers, backups, content repositories. Volume Gateway (Options B & C) is for block-level storage (iSCSI volumes), typically used for application volumes, not file shares. Cached Volume Gateway keeps primary data in S3 with local cache, but it's block-level, not file-level. Stored Volume Gateway keeps all data locally (need 50 TB local storage) and asynchronously backs up to S3. Option D (Tape Gateway) is for backup applications using VTL, not primary file access. The key distinction: File Gateway = file access (NFS/SMB), Volume Gateway = block access (iSCSI), Tape Gateway = backup (VTL). This tests understanding of Storage Gateway types and their use cases."
        },
        {
          "question": "An organization uses AWS DataSync to transfer 100 TB from on-premises NAS to S3. They schedule transfers during off-hours (8 PM - 6 AM) to avoid impacting business. However, users still complain about slow network during transfers. DataSync bandwidth is configured to 'unlimited.' What should they do?",
          "options": [
            "Configure DataSync bandwidth limit to a specific value (e.g., 500 Mbps) to leave headroom for other traffic",
            "Use AWS Direct Connect instead of internet for DataSync transfers",
            "Schedule DataSync tasks to run in smaller batches spread throughout the night",
            "Enable DataSync network optimizations in the task settings to reduce bandwidth usage"
          ],
          "correctAnswer": 0,
          "explanation": "AWS DataSync, when configured with unlimited bandwidth, will use all available network capacity to maximize transfer speed. This can saturate the internet connection, affecting other traffic even during off-hours (monitoring, backups, remote access, global operations). Configuring a bandwidth limit on the DataSync task (e.g., 500 Mbps on a 1 Gbps link) ensures DataSync doesn't monopolize the connection. You can adjust based on your network capacity and other traffic needs. Option B (Direct Connect) helps by providing dedicated bandwidth but is a much larger architectural change and may not be justified for a one-time 100 TB transfer. Option C (smaller batches) doesn't solve bandwidth saturation during each batch's execution. Option D is incorrect - there's no 'network optimization' setting that reduces bandwidth usage; DataSync is already optimized for efficient transfers. The key learning: DataSync bandwidth configuration is critical for managing network impact. Use bandwidth limits to balance transfer speed with network availability for other services. This tests understanding of DataSync bandwidth management."
        },
        {
          "question": "A company configures AWS Transfer Family SFTP server with a VPC endpoint to allow partners to upload files. Partners report they cannot connect to the SFTP server from the internet. The Transfer Family server is configured with a public endpoint type. What's the issue?",
          "options": [
            "VPC endpoint type is for internal access only; use PUBLIC endpoint type for internet-accessible SFTP",
            "The server's VPC endpoint doesn't have Elastic IPs attached for internet accessibility",
            "Security groups associated with the VPC endpoint are blocking inbound SFTP traffic on port 22",
            "PUBLIC endpoint type and VPC endpoint are mutually exclusive; the configuration is invalid"
          ],
          "correctAnswer": 2,
          "explanation": "AWS Transfer Family supports three endpoint types: (1) PUBLIC - internet-accessible via AWS-managed endpoint, (2) VPC - private access within VPC using VPC endpoint, (3) VPC_ENDPOINT with Elastic IPs - internet-accessible via VPC endpoint with Elastic IPs attached to endpoint's ENIs. The scenario states 'VPC endpoint' and 'public endpoint type,' which is contradictory in the question, but the actual issue in practice is typically security group configuration. When using VPC or VPC_ENDPOINT types, the VPC endpoint has associated security groups that must allow inbound traffic on port 22 (SFTP) from the internet (0.0.0.0/0 for public access, or specific partner IPs for restricted access). Many architects configure the Transfer Family server but forget to update security groups on the VPC endpoint. Option A is partially correct but doesn't address the security group issue. Option B is partially correct - VPC_ENDPOINT type needs EIPs for internet access, but the question is about connectivity being blocked. Option D is incorrect - you can have internet-accessible VPC endpoints with EIPs. This tests understanding of Transfer Family endpoint types and network access control."
        },
        {
          "question": "A company wants to run VMware workloads with strict latency requirements (under 2 ms) to on-premises databases. They're evaluating VMware Cloud on AWS and AWS Outposts. Their data center has limited rack space (4U available). Which solution is MORE appropriate?",
          "options": [
            "VMware Cloud on AWS because it provides native VMware vSphere with lower operational overhead",
            "AWS Outposts because it runs in the customer data center, ensuring ultra-low latency to on-premises systems",
            "VMware Cloud on AWS because Outposts requires minimum 42U rack space, which exceeds availability",
            "Neither solution works; use AWS Wavelength for low-latency edge computing instead"
          ],
          "correctAnswer": 2,
          "explanation": "AWS Outposts comes in two form factors: (1) Outposts racks - minimum 42U rack, provides full AWS infrastructure in customer data center, (2) Outposts servers - 1U or 2U form factors with limited capacity (introduced later). VMware Cloud on AWS runs in AWS data centers, not on-premises, providing VMware-native environment but with typical AWS-to-on-premises latency (not sub-2ms). For sub-2ms latency requirements, the workload needs to run on-premises, making Outposts the logical choice. However, with only 4U rack space available, a standard Outposts rack won't fit. The customer would need to either: (1) Allocate more rack space for Outposts rack, (2) Use Outposts servers (1U/2U) if capacity meets needs, or (3) Reconsider architecture. Option A doesn't meet latency requirements. Option B is technically correct about latency but ignores the rack space constraint. Option D is incorrect - Wavelength is for 5G edge, not data center latency. This tests understanding of hybrid deployment options and their physical and latency constraints."
        },
        {
          "question": "A company uses AWS SCT to migrate from Oracle to Aurora PostgreSQL. SCT's assessment report shows many database objects marked as 'action required' with conversion complexity HIGH. What does this indicate and what should they do?",
          "options": [
            "These objects cannot be automatically converted; manual rewriting in PostgreSQL-compatible syntax is required",
            "SCT requires additional licenses to convert complex objects; purchase SCT Professional edition",
            "The source Oracle database has unsupported features; upgrade to a newer Oracle version first",
            "Run SCT in 'force conversion' mode to automatically convert all objects regardless of complexity"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Schema Conversion Tool (SCT) analyzes source database schemas and provides an assessment report with traffic light indicators: (1) GREEN - automatic conversion, (2) YELLOW - mostly automatic with minor manual fixes, (3) RED/'Action Required' - cannot be automatically converted, requires manual effort. Objects marked HIGH complexity typically include: proprietary Oracle features (DBMS_* packages not available in PostgreSQL), complex PL/SQL that doesn't map to PL/pgSQL, hierarchical queries, certain data types, etc. The solution is to manually rewrite these objects or refactor the application to avoid them. SCT provides recommendations and equivalent PostgreSQL patterns. Option B is false - SCT is free; there's no 'Professional edition.' Option C may help in some cases but doesn't solve fundamental Oracle-to-PostgreSQL incompatibilities. Option D is incorrect - there's no 'force conversion' mode; SCT won't convert what it can't. The key insight: heterogeneous migrations (different database engines) require careful assessment and often significant manual conversion effort. SCT automates what it can but architects must budget for manual work on complex objects. This tests understanding of SCT limitations and migration effort estimation."
        },
        {
          "question": "A DMS task successfully completes full load and begins CDC. Initially, CDC lag is under 1 second. After several days, CDC lag grows to 10+ minutes and continues increasing. The source database write rate hasn't increased. What's the MOST likely cause?",
          "options": [
            "The target Aurora database is experiencing write throttling due to too many concurrent transactions",
            "The DMS replication instance is running out of disk space for transaction logs and change data",
            "Network bandwidth between source and target has degraded over time",
            "The source database's transaction log is not being archived properly, causing DMS to re-read old transactions"
          ],
          "correctAnswer": 1,
          "explanation": "AWS DMS replication instances have local storage used for task logs, cached transactions, and swap space. During CDC, if the target cannot keep up with applying changes (due to write contention, latency, or throttling), DMS queues transactions on the replication instance's disk. Over time, if the apply rate is consistently slower than the capture rate, disk space fills up, slowing DMS performance further. Eventually, disk exhaustion causes severe lag or task failure. This is progressive degradation - starts well, degrades over days. Solutions: (1) Monitor replication instance disk metrics (FreeStorageSpace), (2) Increase storage or instance size, (3) Optimize target database write performance (add indexes, increase IOPS), (4) Tune DMS task settings (BatchApplyEnabled, parallel apply). Option A is possible but would likely show constant lag, not progressive. Option C is unlikely to degrade progressively. Option D is incorrect - archive log issues would prevent CDC from reading new changes. The key insight: DMS replication instances need adequate storage for sustained CDC workloads, especially when target apply performance varies. This tests understanding of DMS operational monitoring and troubleshooting."
        },
        {
          "question": "A company wants to inventory their 5,000 on-premises servers for migration planning. Some servers are physical, some virtual, across multiple data centers. They want to collect detailed dependency information (network connections between servers). What's the BEST discovery approach?",
          "options": [
            "Deploy AWS Application Discovery Service Agents on all servers for detailed dependency and performance data",
            "Use Application Discovery Service Agentless Discovery (vCenter integration) for VMware VMs only",
            "Import server inventory from existing CMDB using Migration Hub import templates",
            "Use a combination of agents for critical servers and agentless for VMs, importing physical server data from CMDB"
          ],
          "correctAnswer": 3,
          "explanation": "AWS provides multiple discovery mechanisms: (1) Application Discovery Service Agent-based - installed on servers (VM or physical), collects detailed data including network connections, processes, performance metrics; works across all platforms but requires installation on each server. (2) Agentless Discovery - integrates with VMware vCenter, collects configuration and utilization data for VMs; no installation required but limited to VMware and less detailed. (3) Migration Hub import - upload CSV files from existing tools/CMDBs; quick but static snapshot. For 5,000 servers across physical and virtual, a hybrid approach is most practical: deploy agents on critical servers where detailed dependency mapping is crucial, use agentless for VMware VMs (easier at scale), and import physical server inventory from existing CMDB. This balances detail with operational feasibility. Option A (agents everywhere) is ideal but operationally challenging for 5,000 servers. Option B misses physical servers. Option C lacks dependency information. The key insight: large-scale discovery requires pragmatic hybrid approaches. This tests understanding of discovery tool selection and trade-offs."
        },
        {
          "question": "A company uses AWS Elastic Disaster Recovery (DRS, formerly CloudEndure DR) for business-critical servers. Their RTO requirement is 1 hour, RPO requirement is 15 minutes. During a DR test, they fail over and discover the recovered server's data is 45 minutes old. What's the issue?",
          "options": [
            "DRS replication lag exceeded 15 minutes due to high change rate on source servers",
            "DRS cannot achieve 15-minute RPO; minimum RPO is 1 hour for block-level replication",
            "The DR drill initiated failover before replication caught up to the current point in time",
            "DRS was configured in 'scheduled snapshot' mode instead of 'continuous replication' mode"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Elastic Disaster Recovery (DRS) provides continuous block-level replication with typical RPO of seconds to minutes, depending on change rate and network conditions. However, if the source server has a high change rate (disk writes) that exceeds the replication throughput, lag accumulates, increasing RPO. The scenario's 45-minute lag suggests replication cannot keep up with source changes. Solutions: (1) Increase bandwidth between source and AWS, (2) Reduce source change rate (pause non-critical writes during DR prep), (3) Exclude high-churn non-critical volumes from replication, (4) Optimize network path. Option B is false - DRS can achieve sub-minute RPO under normal conditions. Option C is possible but the scenario says they 'fail over,' not that they initiated failover prematurely; lag is the root cause. Option D is incorrect - DRS doesn't have 'snapshot mode'; it's continuous replication. The key learning: DR tools provide technical capability for low RPO, but actual RPO depends on workload characteristics (change rate) and infrastructure (bandwidth). Always test DR with realistic workload conditions. This tests understanding of replication-based DR limitations."
        },
        {
          "question": "A company evaluates AWS Mainframe Modernization service for migrating COBOL applications. The service's automated refactoring option promises to convert COBOL to Java. After analysis, what should they expect regarding the automated conversion?",
          "options": [
            "Fully automated conversion with no manual coding required; applications run immediately after conversion",
            "Automated conversion handles 60-80% of code; business logic requires manual review and potential refactoring",
            "Automated conversion only works for COBOL programs under 10,000 lines of code",
            "Conversion is automated but requires rewriting all database access layers and transaction logic"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Mainframe Modernization provides two migration patterns: (1) Replatform - lift-and-shift mainframe applications to managed mainframe runtime on AWS (Micro Focus or Blu Age runtime), minimal code changes; (2) Refactor - automated conversion of COBOL to Java with business logic preserved, runs on modern stack. The automated refactoring is sophisticated but not 100% automated. Typically, the conversion handles 60-80% of code automatically, converting COBOL syntax to Java. However, business logic, complex data transformations, and integration points require review and potential manual refactoring. Additionally, mainframe-specific concepts (like CICS transactions, VSAM files, JCL) need mapping to modern equivalents (microservices, databases, orchestration). Option A is unrealistic - no automated conversion is perfect. Option C is false - there's no such line-of-code limit. Option D overstates the manual work - data access can often be converted, though it needs validation. The key insight: automated mainframe modernization significantly reduces effort but requires experienced developers to review, test, and refine converted code. It's a tool to accelerate migration, not a magic button. This tests realistic expectations of modernization tools."
        }
      ]
    },
    {
      "filename": "advanced-scenarios-multi-select.json",
      "domain": "Mixed Domains: Advanced Multi-Select Scenarios",
      "task": "Advanced Scenario-Based Multi-Select Questions",
      "question_count": 15,
      "questions": [
        {
          "question": "A financial services company is implementing a defense-in-depth security strategy for their public-facing web application hosted on AWS. The application serves customers globally and must protect against DDoS attacks, SQL injection, and credential stuffing while maintaining low latency. The security team requires visibility into all blocked requests and automatic threat intelligence updates. Which THREE AWS services should be implemented as part of this multi-layered security architecture? (Select THREE)",
          "options": [
            "AWS Shield Advanced with AWS WAF integration for DDoS protection and layer 7 filtering",
            "Amazon CloudFront with geo-restriction and custom SSL certificates",
            "AWS Network Firewall with IDS/IPS rules for deep packet inspection",
            "AWS WAF with managed rule groups including Bot Control and ATP (Account Takeover Prevention)",
            "AWS Firewall Manager to centrally manage WAF rules across accounts",
            "VPC Flow Logs with Amazon Athena for traffic analysis"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            3
          ],
          "explanation": "For a comprehensive defense-in-depth security architecture for a public-facing web application, the correct combination is: (1) AWS Shield Advanced provides DDoS protection at layers 3, 4, and 7, and includes 24/7 access to the DDoS Response Team (DRT). When integrated with WAF, it provides enhanced detection and automatic mitigation. (2) Amazon CloudFront acts as the first layer of defense, distributing content globally with low latency, and enables geographic restrictions. CloudFront also integrates tightly with Shield and WAF, allowing security policies to be enforced at edge locations before traffic reaches origin servers. (3) AWS WAF with managed rule groups is essential for protecting against OWASP Top 10 vulnerabilities including SQL injection. The Bot Control managed rule group protects against automated threats, and ATP (Account Takeover Prevention) specifically addresses credential stuffing attacks. These managed rule groups automatically receive threat intelligence updates from AWS Threat Research team. Option C (Network Firewall) operates at the VPC level and is designed for east-west and north-south traffic inspection within VPCs, not for protecting public web applications at the edge - it would add unnecessary latency and cost for this use case. Option E (Firewall Manager) is useful for multi-account management but isn't a security service itself; it's a management layer. In a single-account scenario or where centralized management isn't the primary concern, it's not essential. Option F (VPC Flow Logs) provides network traffic logging but doesn't actively protect against attacks; it's a visibility tool, not a security control. The key insight is that effective defense-in-depth for public web applications requires edge-based protection (CloudFront), DDoS mitigation (Shield Advanced), and application-layer filtering (WAF with managed rules)."
        },
        {
          "question": "An enterprise is designing a hybrid DNS architecture to support 500 VPCs across 4 AWS regions and 3 on-premises data centers. They need bidirectional DNS resolution where AWS resources can resolve on-premises domain names and on-premises systems can resolve private Route 53 hosted zones. They want centralized management and minimal operational overhead. Which THREE components are required for this architecture? (Select THREE)",
          "options": [
            "Route 53 Resolver inbound endpoints in a central networking VPC in each region",
            "Route 53 Resolver outbound endpoints in every VPC that needs to resolve on-premises names",
            "Route 53 Resolver rules shared via AWS RAM to all accounts and associated with VPCs",
            "AWS Transit Gateway with DNS resolution support enabled on VPC attachments",
            "Route 53 private hosted zones associated with all VPCs",
            "VPN connections from each VPC to each on-premises data center for DNS traffic"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2,
            3
          ],
          "explanation": "For a scalable hybrid DNS architecture, the correct components are: (1) Route 53 Resolver inbound endpoints in a central VPC allow on-premises DNS servers to forward queries for AWS private hosted zones to Route 53 Resolver. These endpoints should be deployed in a central networking VPC with redundancy across multiple AZs. On-premises DNS servers configure conditional forwarders pointing to these inbound endpoint IP addresses. (2) Route 53 Resolver rules define which domains should be forwarded to on-premises DNS servers. These rules are created in the central networking account and shared via AWS RAM (Resource Access Manager) to all member accounts. Once shared, each account must associate the rules with their VPCs. This centralized approach eliminates the need to create duplicate rules in every account. The rules point to outbound endpoints for forwarding queries. (3) AWS Transit Gateway with DNS support enabled on VPC attachments is crucial for this architecture. When you enable DNS support on TGW VPC attachments, DNS queries from VPCs can route through the Transit Gateway to reach the central VPC containing the Resolver endpoints. This eliminates the need for VPC peering mesh or redundant endpoint deployments. Option B is incorrect because outbound endpoints should be deployed centrally in the networking VPC, not in every VPC - this is the whole point of the centralized architecture. Resolver rules (shared via RAM) reference the central outbound endpoints. Option E, while private hosted zones are part of the solution, they're not a specific 'component to implement' for the hybrid DNS architecture itself; they're the resources being resolved. Option F (VPN from every VPC) is the opposite of centralized architecture and creates massive operational overhead. The key learning is that Route 53 Resolver with Transit Gateway integration enables hub-and-spoke DNS architecture at scale, and RAM sharing of resolver rules eliminates rule duplication across hundreds of accounts."
        },
        {
          "question": "A global SaaS company is implementing a multi-region disaster recovery strategy for their critical database workload currently running on Amazon Aurora PostgreSQL in us-east-1. The RTO is 15 minutes and RPO is 5 minutes. They require the ability to promote a secondary region to primary with minimal data loss and automatic failover capability. The solution must support read scalability in the DR region during normal operations. Which THREE components should be implemented? (Select THREE)",
          "options": [
            "Aurora Global Database with a secondary region in eu-west-1",
            "Aurora Cross-Region Read Replica with manual promotion process",
            "Amazon RDS Proxy in both regions for connection management and failover",
            "Route 53 health checks with failover routing policy for application endpoints",
            "AWS Backup with cross-region backup copy for point-in-time recovery",
            "Aurora Multi-AZ deployment in the primary region"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2,
            3
          ],
          "explanation": "To meet the RTO of 15 minutes and RPO of 5 minutes with multi-region DR, the correct architecture includes: (1) Aurora Global Database provides the best solution for multi-region disaster recovery. It uses dedicated infrastructure for replicating data to secondary regions with typical lag under 1 second (far better than the 5-minute RPO requirement). Global Database supports managed planned failover (RPO of 0) and unplanned failover (RPO typically less than 1 second). The failover process to promote a secondary region can complete in under 1 minute for the database itself, helping meet the 15-minute RTO. Additionally, the secondary region supports up to 16 read replicas that can serve read traffic during normal operations, meeting the read scalability requirement. (2) Amazon RDS Proxy in both regions is crucial for meeting the 15-minute RTO. RDS Proxy pools and shares database connections, and when an Aurora failover occurs, RDS Proxy maintains connections and automatically directs them to the new primary instance, significantly reducing connection storm issues and application recovery time. Deploying RDS Proxy in both regions ensures applications in each region can connect efficiently to whichever region is currently primary. (3) Route 53 health checks with failover routing policy enable automated DNS-level failover for the application tier. Health checks monitor the application endpoints in the primary region, and when failures are detected, Route 53 automatically updates DNS to point to the DR region endpoint. This provides end-to-end automated failover capability at the application level, complementing the database failover. Option B (cross-region read replica) has a manual promotion process and doesn't meet the automated failover requirement, plus the replication lag is typically higher than Global Database. Option E (AWS Backup with cross-region copy) provides point-in-time recovery but cannot meet a 15-minute RTO as restoring a database from backup takes much longer. It's suitable for backup/archival but not for the primary DR strategy with these aggressive RTO/RPO requirements. Option F (Multi-AZ in primary region) protects against AZ failures within a region but doesn't provide multi-region DR capability. The combination of Aurora Global Database, RDS Proxy in both regions, and Route 53 failover routing provides automated, fast failover with minimal data loss while also enabling read scalability in the DR region."
        },
        {
          "question": "A large organization with 800 AWS accounts needs to implement centralized security monitoring and compliance automation. They require automated security assessments, continuous compliance monitoring against CIS AWS Foundations Benchmark, vulnerability scanning of EC2 instances and container images, and a unified dashboard for the security team. Which THREE AWS services should be configured with delegated administrator architecture? (Select THREE)",
          "options": [
            "AWS Security Hub with delegated administrator in a central security account",
            "Amazon GuardDuty with delegated administrator and automatic member enablement",
            "AWS Config with conformance packs deployed via CloudFormation StackSets",
            "Amazon Inspector with delegated administrator for EC2 and ECR scanning",
            "AWS Systems Manager with OpsCenter for centralized operational insights",
            "Amazon Detective with cross-account investigation capabilities"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            3
          ],
          "explanation": "For comprehensive centralized security monitoring across 800 accounts, the correct services are: (1) AWS Security Hub with delegated administrator provides a centralized view of security findings and compliance status across all accounts and regions. Security Hub aggregates findings from GuardDuty, Inspector, IAM Access Analyzer, Macie, and third-party security tools into a unified dashboard. It includes built-in compliance standards including CIS AWS Foundations Benchmark, PCI DSS, and AWS Foundational Security Best Practices. The delegated administrator architecture allows a central security account to manage Security Hub across all member accounts without using the management account. Security Hub automatically normalizes findings across services into a standard format (AWS Security Finding Format) for easier analysis. (2) Amazon GuardDuty with delegated administrator provides intelligent threat detection using machine learning to analyze VPC Flow Logs, CloudTrail events, and DNS logs across all accounts. The delegated administrator can automatically enable GuardDuty in new accounts as they join the organization (through auto-enable feature), ensuring comprehensive coverage without manual intervention per account. GuardDuty findings automatically flow into Security Hub for centralized visibility. At 800 accounts, the automated enablement feature is crucial for operational efficiency. (3) Amazon Inspector with delegated administrator provides automated vulnerability management by continuously scanning EC2 instances, container images in ECR, and Lambda functions for software vulnerabilities and network exposure. Inspector automatically discovers resources, scans them, and reports findings. The delegated administrator model allows central management, and Inspector findings also integrate with Security Hub for unified visibility. Inspector is specifically designed for vulnerability scanning, which is a stated requirement. Option C (AWS Config with StackSets) would work for compliance monitoring, but it's more complex to manage at scale compared to Security Hub's built-in compliance standards. Security Hub actually aggregates Config findings, so deploying Config separately via StackSets is an additional operational burden when Security Hub already provides the centralized compliance dashboard. Option E (Systems Manager OpsCenter) is for operational issue management, not security monitoring. Option F (Detective) is for security investigation and forensics, which is valuable but not part of the core requirements for continuous monitoring and compliance assessment. The key architecture insight is that Security Hub acts as the aggregation layer for findings from GuardDuty (threat detection) and Inspector (vulnerability scanning), while also providing compliance monitoring through its security standards feature, making these three services the optimal combination for the stated requirements with minimal operational overhead."
        },
        {
          "question": "A media company is migrating a large-scale video processing application to AWS. The application processes 10 PB of video files stored in an on-premises NFS file system. They need to migrate the data to Amazon S3 with minimal downtime, automatically transition older files to cheaper storage tiers, and implement a lifecycle policy where files older than 90 days move to S3 Glacier, and files older than 2 years are deleted. Which THREE approaches should be combined for this migration and lifecycle management? (Select THREE)",
          "options": [
            "AWS DataSync for initial bulk transfer and ongoing synchronization of the 10 PB dataset",
            "AWS Storage Gateway File Gateway to provide NFS access to S3 during migration",
            "AWS Snowball Edge devices for offline data transfer of the initial 10 PB",
            "S3 Lifecycle policies with transitions to S3 Glacier after 90 days and expiration after 2 years",
            "S3 Intelligent-Tiering for automatic cost optimization based on access patterns",
            "AWS Transfer Family (SFTP) to enable file uploads from on-premises systems"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2,
            3
          ],
          "explanation": "For migrating 10 PB of data and implementing lifecycle management, the correct approach combines: (1) AWS Snowball Edge devices for the initial bulk transfer. Transferring 10 PB over the network, even with a 10 Gbps connection, would take months (10 PB = 10,000 TB; at 1 Gbps effective throughput = 10,000+ hours = over 400 days). Snowball Edge devices can hold up to 80 TB each, so you'd need around 125 devices, but AWS allows parallel shipments. Each device can transfer data at local network speeds, and once shipped to AWS, the data is loaded into S3. This approach reduces the initial migration time from months to weeks. (2) AWS DataSync for ongoing synchronization after the bulk transfer. While Snowball handles the initial 10 PB, DataSync is perfect for incremental synchronization of changed and new files. DataSync can be deployed on-premises as a VM or hardware appliance, continuously monitors the source NFS share, and efficiently transfers only changed data to S3. This enables a cutover strategy where: Snowball transfers the bulk data, DataSync synchronizes changes made during the Snowball transfer period, and then final cutover happens with DataSync ensuring all recent changes are captured with minimal downtime. DataSync also automatically handles retries, data verification, and can maintain file metadata. (3) S3 Lifecycle policies provide automated, policy-based data lifecycle management. You configure a single lifecycle rule on the S3 bucket that specifies: transition objects to S3 Glacier Deep Archive (or S3 Glacier Flexible Retrieval) 90 days after creation, and permanently delete objects 2 years (730 days) after creation. This is declarative, requires no custom code, and automatically applies to all current and future objects. S3 lifecycle policies are the native, cost-effective way to implement time-based storage tiering and deletion. Option B (Storage Gateway File Gateway) provides NFS access to S3, which could be useful if the on-premises application needs ongoing NFS access to S3, but the scenario describes a migration where files are moving to S3, not an ongoing hybrid storage architecture. It also doesn't help with the 10 PB initial transfer challenge. Option E (S3 Intelligent-Tiering) automatically moves objects between access tiers based on access patterns (not accessed for 30 days → Infrequent Access tier, etc.), but the requirements specify a time-based policy (90 days → Glacier), not an access-pattern-based policy. Intelligent-Tiering also doesn't support automatic deletion based on age. Option F (Transfer Family) is for enabling SFTP/FTPS/FTP access to S3, which isn't relevant for migrating from an NFS file system - the source is NFS, not FTP-based. The architecture combines offline bulk transfer (Snowball) for the initial dataset, online incremental sync (DataSync) for changes and final cutover, and S3-native lifecycle policies for long-term automated tiering and deletion."
        },
        {
          "question": "A startup is building a serverless microservices application on AWS using Amazon ECS with Fargate. The application consists of 15 microservices that need to communicate securely with each other, with service discovery, mutual TLS authentication, and detailed observability into service-to-service communication. The team wants to avoid managing service mesh infrastructure. Which THREE AWS services/features should be implemented? (Select THREE)",
          "options": [
            "AWS App Mesh for service mesh capabilities with Envoy proxy sidecars",
            "AWS Cloud Map for service discovery and health checking",
            "Amazon ECS Service Connect for simplified service-to-service communication",
            "Application Load Balancer with host-based routing for each microservice",
            "AWS X-Ray for distributed tracing across microservices",
            "Amazon CloudWatch Container Insights for container-level metrics and logs"
          ],
          "type": "multiple",
          "correctAnswer": [
            2,
            4,
            5
          ],
          "explanation": "For a serverless microservices architecture on ECS Fargate with the stated requirements, the optimal combination is: (1) Amazon ECS Service Connect provides service discovery, service-to-service communication, and traffic management specifically designed for ECS workloads. Launched in late 2022, Service Connect simplifies microservices networking by automatically handling service discovery, client-side load balancing, and traffic routing without requiring separate service mesh infrastructure. It deploys a lightweight proxy as a sidecar (based on Envoy) but is fully managed by AWS - you don't operate the control plane. Service Connect integrates with AWS Cloud Map for namespace management but abstracts away the complexity. Importantly, it provides traffic metrics and logs for observability. While it doesn't natively provide mutual TLS in all configurations, it significantly simplifies service-to-service communication compared to manual service mesh operation, aligning with the 'avoid managing infrastructure' requirement. (2) AWS X-Ray provides distributed tracing across the microservices architecture. By instrumenting your application code with the X-Ray SDK, you can trace requests as they flow through the 15 microservices, identifying bottlenecks, latency issues, and errors. X-Ray creates a service map showing dependencies and performance characteristics of each service, provides end-to-end request tracing with detailed timing for each service call, and integrates with ECS/Fargate container metadata. For observability into service-to-service communication patterns and troubleshooting distributed transactions, X-Ray is essential. (3) Amazon CloudWatch Container Insights provides comprehensive monitoring for containerized applications. It automatically collects metrics at the cluster, service, and task level including CPU, memory, disk, and network utilization. Container Insights also aggregates logs from all containers and provides a unified dashboard. For ECS on Fargate, it gives visibility into resource utilization, performance metrics, and helps with troubleshooting. Combined with X-Ray (application-level tracing) and Service Connect (network-level metrics), Container Insights provides infrastructure-level observability, completing the observability stack. Option A (AWS App Mesh) is a full-featured service mesh that provides mutual TLS, advanced traffic management, and observability, but requires managing the App Mesh control plane, configuring Envoy proxies, and more operational overhead. The question specifically states 'avoid managing service mesh infrastructure,' making Service Connect a better fit as it provides managed service mesh capabilities without the operational complexity. If strict mutual TLS is absolutely required, App Mesh would be necessary, but Service Connect meets most requirements with less overhead. Option B (AWS Cloud Map) is used by Service Connect under the hood, but you don't configure it directly when using Service Connect - it's abstracted away. Separately deploying Cloud Map would be needed if you're building a custom service discovery solution, but Service Connect handles this. Option D (Application Load Balancer with host-based routing) provides external-facing load balancing but doesn't provide service discovery, mutual TLS, or service mesh capabilities for service-to-service communication. You'd still need ALB for ingress traffic from the internet, but it's not part of the internal microservices communication architecture. The key insight is that ECS Service Connect is purpose-built for simplifying microservices on ECS/Fargate, X-Ray provides application-level distributed tracing, and Container Insights provides infrastructure monitoring - together they provide comprehensive observability without heavy service mesh operational burden."
        },
        {
          "question": "An e-commerce company running a monolithic application on EC2 instances is planning to modernize to a containerized microservices architecture. They need to minimize refactoring, support both containerized and non-containerized components during migration, enable gradual traffic shifting between old and new versions, and maintain session affinity. Which THREE AWS services/features should be part of the migration strategy? (Select THREE)",
          "options": [
            "Amazon ECS with Application Load Balancer target groups for blue/green deployments",
            "AWS App Runner for automatic container deployment with built-in load balancing",
            "AWS CodeDeploy with ECS blue/green deployment support for gradual traffic shifting",
            "Amazon API Gateway with VPC Link for routing traffic to both EC2 and container backends",
            "AWS Lambda with Application Load Balancer integration for serverless microservices",
            "Elastic Beanstalk with Docker platform for simplified container deployment"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2,
            3
          ],
          "explanation": "For a migration from monolithic EC2 to containerized microservices with the stated requirements, the optimal combination is: (1) Amazon ECS with Application Load Balancer provides the container orchestration platform and routing capabilities needed. ECS allows you to run containerized microservices on either EC2 or Fargate. ALB target groups can route traffic to ECS tasks (containers) while supporting advanced routing rules (path-based, host-based), and crucially, ALB supports sticky sessions (session affinity) using cookie-based stickiness. You can configure multiple target groups behind a single ALB - some pointing to legacy EC2 instances and others to ECS containers - enabling gradual migration. ALB also integrates with ECS service discovery and health checks. (2) AWS CodeDeploy with ECS blue/green deployment support enables safe, controlled deployments with gradual traffic shifting. CodeDeploy for ECS supports blue/green deployments where a new version of the service (green) is deployed alongside the old version (blue), and traffic is gradually shifted from blue to green using linear or canary strategies (e.g., 10% every 10 minutes). This allows validation and monitoring before full cutover, with automatic rollback if CloudWatch alarms trigger. This is essential for minimizing risk during the microservices migration - each service can be migrated and deployed independently with gradual traffic shifting. (3) Amazon API Gateway with VPC Link provides a unified API front-end that can route requests to both legacy EC2 backends (via VPC Link to NLB/ALB) and new containerized microservices. During the migration, you can use API Gateway to implement the strangler fig pattern: route specific API paths to new containerized microservices while routing other paths to the legacy monolith. API Gateway also provides API management capabilities like throttling, authentication (Cognito, Lambda authorizers), request/response transformation, and caching. VPC Link enables private connectivity from API Gateway to resources in your VPC without internet exposure. This architecture allows gradual decomposition of the monolith where API endpoints are migrated one at a time to new microservices. Option B (AWS App Runner) is a simplified container service but doesn't provide the level of control needed for gradual migration strategies, doesn't support blue/green deployments with traffic shifting, and is designed for simple containerized web apps rather than complex migration scenarios. Option D (Lambda with ALB) could be part of the architecture for some microservices, but the question asks about containerized microservices, not serverless functions. Lambda is valuable for certain use cases but doesn't address the core requirement of container orchestration. Option F (Elastic Beanstalk with Docker) provides simplified container deployment but lacks the advanced deployment strategies (gradual traffic shifting, blue/green) that CodeDeploy offers, and doesn't provide the API management and routing flexibility of API Gateway for managing the migration from monolith to microservices. The architecture uses ECS for container orchestration, CodeDeploy for safe deployments with traffic shifting, and API Gateway as the API management layer that can route to both old and new backends during the migration period, enabling the strangler fig pattern for gradual modernization."
        },
        {
          "question": "A financial institution must implement a multi-account AWS environment with strict compliance requirements including: encryption of all data at rest and in transit, centralized key management with automatic key rotation, audit logging of all key usage, and the ability to disable keys across all accounts immediately in case of a security incident. Which THREE approaches should be implemented? (Select THREE)",
          "options": [
            "AWS KMS with customer managed keys (CMKs) created in each account and automatic key rotation enabled",
            "AWS KMS with a centralized key management account and cross-account key policies for resource access",
            "AWS CloudTrail with CloudWatch Logs integration for monitoring KMS API calls across all accounts",
            "AWS Secrets Manager for storing and rotating encryption keys automatically",
            "AWS Certificate Manager for managing SSL/TLS certificates with automatic renewal",
            "AWS Security Hub with AWS Config rules to ensure encryption at rest compliance"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2,
            5
          ],
          "explanation": "For enterprise-grade centralized key management with compliance and security requirements, the correct approach includes: (1) AWS KMS with a centralized key management account provides the best architecture for centralized control. In this model, customer managed keys (CMKs) are created in a dedicated security/key management account, and cross-account access is granted through key policies and grants. This allows the security team to maintain central control over keys while application accounts can use them for encryption/decryption. Key policies can specify which accounts and roles can use keys for which operations. Crucially, this architecture enables the security team to immediately disable or delete keys from the central account in case of a security incident, and the effect is instantaneous across all consuming accounts. Automatic key rotation can be enabled on these centralized keys, rotating the backing key material annually while maintaining the same key ID (ensuring no application changes are needed). (2) AWS CloudTrail with CloudWatch Logs integration provides comprehensive audit logging of all KMS API calls. Every KMS operation (Encrypt, Decrypt, GenerateDataKey, etc.) generates a CloudTrail event that includes details about who made the call, from which account, which key was used, and the timestamp. By configuring an organization trail, you capture KMS API calls across all accounts in a centralized S3 bucket. Integrating CloudTrail with CloudWatch Logs enables real-time monitoring and alerting - you can create metric filters and alarms to detect anomalous KMS usage patterns, unauthorized access attempts, or policy violations. This satisfies the audit logging requirement and provides the security team with visibility into how keys are being used across the organization. (3) AWS Security Hub with AWS Config rules ensures continuous compliance monitoring for encryption at rest. AWS Config rules can be deployed organization-wide (via Config Organizational Rules or StackSets) to check that resources like EBS volumes, S3 buckets, RDS databases, and DynamoDB tables are encrypted. Security Hub aggregates findings from these Config rules into a centralized dashboard and maps them to compliance frameworks (PCI DSS, CIS, etc.). This provides automated, continuous compliance assessment rather than manual periodic audits, and Security Hub can trigger automated remediation through EventBridge when encryption violations are detected. Option A (keys in each account) is the opposite of centralized management and makes incident response difficult - you'd need to disable keys in hundreds of accounts individually. It also makes governance and oversight harder. Option C is close, but the question is about CloudTrail with CloudWatch integration, which is covered in Option B - CloudTrail alone provides audit logs but adding CloudWatch enables real-time monitoring and alerting. Option D (Secrets Manager) is for storing secrets like database passwords and API keys, not for encryption key management - that's KMS's role. Secrets Manager actually uses KMS for encryption. Option E (Certificate Manager) manages SSL/TLS certificates for HTTPS/TLS connections, which addresses encryption in transit for web traffic, but doesn't provide centralized key management for data at rest encryption or the ability to disable keys across all accounts. ACM is a component of a complete solution but isn't one of the core three for centralized key management. The architecture combines centralized KMS key creation and management, comprehensive CloudTrail auditing with real-time monitoring via CloudWatch, and continuous compliance monitoring through Security Hub and Config rules, providing defense-in-depth for key management and encryption compliance."
        },
        {
          "question": "A healthcare organization needs to migrate a 50 TB SQL Server database from on-premises to AWS with minimal downtime. The database is subject to HIPAA compliance, has high transaction volume (10,000 transactions/second), and the migration window allows only 4 hours of downtime. Post-migration, they need automated backups, point-in-time recovery, and the ability to create development database clones quickly. Which THREE components should be part of the migration and operational strategy? (Select THREE)",
          "options": [
            "AWS Database Migration Service (DMS) with ongoing replication for minimal downtime migration",
            "AWS Snowball to transfer the initial 50 TB database dump offline",
            "Amazon RDS for SQL Server with automated backups and Multi-AZ deployment",
            "AWS Backup for centralized backup management across all database instances",
            "Amazon Aurora PostgreSQL with Babelfish for SQL Server compatibility",
            "Amazon RDS read replicas for creating development database clones"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2,
            3
          ],
          "explanation": "For migrating a large, high-transaction SQL Server database with minimal downtime and specific operational requirements, the correct approach is: (1) AWS Database Migration Service (DMS) provides the capability for minimal downtime migration through continuous data replication. The migration strategy would be: perform an initial full load of the database to RDS (which can happen while the source database remains operational), enable ongoing replication/CDC (Change Data Capture) to continuously replicate transactions from the source to target, monitor replication lag until caught up, perform a brief cutover during the 4-hour window to switch applications to the RDS database. DMS supports SQL Server as both source and target, handles schema migration, and can replicate ongoing transactions with low latency. For a 10,000 TPS workload, DMS can be configured with multiple tasks and appropriate instance sizing to handle the throughput. The 50 TB initial load can be expedited using DMS with Snowball Edge (though this adds complexity) or by using a dedicated DMS replication instance with sufficient network bandwidth. (2) Amazon RDS for SQL Server is the managed database service that eliminates operational overhead. RDS provides automated backups with configurable retention (up to 35 days), automatic point-in-time recovery to any second within the retention period, automated patching, Multi-AZ deployment for high availability, and performance monitoring. For HIPAA compliance, RDS supports encryption at rest using KMS and encryption in transit using SSL/TLS. RDS can handle 10,000 TPS with appropriate instance sizing (e.g., db.r6i.8xlarge or larger). The managed nature of RDS means the healthcare organization doesn't need to manage SQL Server licensing, OS patching, or backup infrastructure - AWS handles these operational tasks. (3) AWS Backup provides centralized backup management, which is particularly valuable for HIPAA compliance and governance. While RDS has built-in automated backups, AWS Backup adds a centralized backup policy layer across the organization. You can define backup plans with retention policies, copy backups to other regions for DR, apply backup policies across multiple accounts using AWS Organizations, enforce backup compliance with backup vault lock (preventing deletion of backups for compliance), and generate backup compliance reports for audits. For HIPAA compliance, AWS Backup's vault lock feature is particularly valuable as it enforces WORM (Write Once Read Many) for backups, meeting regulatory requirements. AWS Backup also supports cross-account and cross-region backup copies for additional protection. Option B (Snowball for initial transfer) could work but adds complexity to the migration - you'd need to create a database dump, ship it via Snowball, restore to RDS, then set up DMS for the catch-up replication. For a 50 TB database with good network connectivity (1-10 Gbps), DMS can transfer the initial load over the network in a reasonable timeframe (a few days), and since ongoing replication keeps the databases in sync, the total timeline still fits the minimal downtime requirement. Snowball is more suitable when network bandwidth is severely constrained. Option D (Aurora PostgreSQL with Babelfish) is an alternative to RDS SQL Server where Babelfish provides SQL Server wire protocol compatibility, allowing SQL Server applications to connect to Aurora PostgreSQL. However, Babelfish has limitations and may require application testing and potential code changes for compatibility. Given the high transaction volume and 4-hour cutover window, migrating to RDS SQL Server (same database engine) is lower risk than migrating to a different engine (PostgreSQL), even with Babelfish compatibility. Option E is incorrect - RDS for SQL Server does not support read replicas. Read replicas are available for PostgreSQL, MySQL, and MariaDB, but not for SQL Server. For creating development database clones quickly, RDS supports database snapshots that can be restored to new instances (though this takes time for 50 TB), or you could use RDS Blue/Green deployments for cloning. The optimal strategy uses DMS for minimal-downtime migration with continuous replication, RDS for SQL Server as the managed target platform with built-in HA and PITR, and AWS Backup for centralized, compliant backup management meeting HIPAA requirements."
        },
        {
          "question": "A global media company needs to implement a multi-region content delivery solution that serves 4K video content to users worldwide with low latency, provides real-time analytics on content performance and viewer behavior, and protects video content from unauthorized access and hotlinking. The solution must also reduce origin load by maximizing cache hit ratio. Which THREE AWS services/features should be implemented? (Select THREE)",
          "options": [
            "Amazon CloudFront with field-level encryption for protecting sensitive viewer data",
            "CloudFront signed URLs and signed cookies with custom policies for content access control",
            "AWS Elemental MediaPackage for video packaging and origin protection",
            "Amazon CloudWatch with CloudFront standard logs for basic monitoring",
            "Amazon Kinesis Data Streams with CloudFront real-time logs for detailed analytics",
            "AWS WAF with rate-based rules to prevent content scraping and DDoS"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2,
            4
          ],
          "explanation": "For a global content delivery solution with access control, analytics, and origin protection, the correct architecture includes: (1) CloudFront signed URLs and signed cookies provide robust content access control, preventing unauthorized access and hotlinking. Signed URLs/cookies use cryptographic signing with a private key (you control the key pair) to authorize access to content. You can create custom policies that specify: who can access content (IP address restrictions), when content can be accessed (time-based expiration), which content can be accessed (URL patterns). This prevents hotlinking because each URL is signed and time-limited, preventing other websites from embedding direct links to your content. The application server generates signed URLs/cookies after authenticating users, and CloudFront validates the signature before serving content. For a media company with premium 4K content, this is essential for access control and monetization. (2) AWS Elemental MediaPackage provides video packaging, origin protection, and improved cache efficiency. MediaPackage acts as a just-in-time video packager and origin for CloudFront, converting video from a single source format into multiple adaptive bitrate (ABR) formats (HLS, DASH, CMAF) dynamically. It includes origin protection features like origin access control, preventing direct access to the origin and ensuring all requests come through CloudFront. MediaPackage also implements time-shifted viewing and DVR-like functionality. Critically, it optimizes cache hit ratio by generating consistent segment URLs and supporting large manifest files, which improves CloudFront caching efficiency. For 4K video delivery at scale, MediaPackage handles the complexity of adaptive bitrate streaming while reducing origin load. (3) Amazon Kinesis Data Streams with CloudFront real-time logs provides detailed, real-time analytics on content performance and viewer behavior. CloudFront real-time logs deliver log data within seconds of a viewer request to Kinesis Data Streams, where you can process them with Kinesis Data Analytics, Lambda, or custom applications. Real-time logs include detailed fields like cache behavior, time to first byte, protocol, country, device type, and more. This enables real-time dashboards showing which content is popular, geographic distribution of viewers, cache hit ratios, error rates, and performance metrics. Compared to standard logs (which have 60-minute delay and are written to S3), real-time logs enable immediate operational insights and can trigger alerts for performance degradation or unusual access patterns. For a media company, real-time analytics on viewer behavior and content performance are critical for content strategy and operations. Option A (field-level encryption) protects specific sensitive fields in POST requests (like credit card numbers) during the request lifecycle, but isn't relevant for protecting video content delivery - signed URLs/cookies are the appropriate mechanism for video access control. Option D (CloudWatch with standard logs) provides basic monitoring but standard CloudFront logs are delivered to S3 with a delay of up to 60 minutes, which doesn't meet the 'real-time analytics' requirement. CloudWatch can provide some metrics, but detailed viewer behavior analytics require the full log data that real-time logs provide to Kinesis. Option F (AWS WAF with rate-based rules) provides security against scraping and DDoS, which is valuable, but the primary requirements are content access control (addressed by signed URLs/cookies) and analytics (addressed by real-time logs). WAF would be a good additional layer but isn't one of the core three components for the stated requirements. The architecture combines signed URLs/cookies for access control and anti-hotlinking, MediaPackage for efficient video packaging and origin protection, and Kinesis with real-time logs for detailed analytics, creating a comprehensive content delivery solution."
        },
        {
          "question": "A financial services company is implementing a cost optimization strategy for their AWS environment with 300 accounts. They need to achieve 30% cost reduction through a combination of right-sizing underutilized resources, implementing automated scheduling for non-production environments, and maximizing commitment-based discounts. They require visibility into cost allocation by business unit and project. Which THREE AWS services/features should be implemented? (Select THREE)",
          "options": [
            "AWS Cost Explorer with rightsizing recommendations and reserved instance purchase recommendations",
            "AWS Compute Optimizer for EC2, Lambda, and EBS volume rightsizing analysis",
            "AWS Cost Anomaly Detection with automated alerts for unusual spending patterns",
            "AWS Budgets with budget actions to automatically stop resources exceeding thresholds",
            "AWS Organizations with consolidated billing and Cost Allocation Tags for business unit tracking",
            "AWS Savings Plans (Compute and EC2 Instance Savings Plans) for commitment-based discounts"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            4,
            5
          ],
          "explanation": "For a comprehensive cost optimization strategy achieving 30% reduction across 300 accounts, the optimal combination is: (1) AWS Compute Optimizer provides machine learning-powered rightsizing recommendations that go beyond simple metrics. Compute Optimizer analyzes historical utilization data (CloudWatch metrics) for EC2 instances, Auto Scaling groups, EBS volumes, and Lambda functions to recommend optimal resource configurations. Unlike Cost Explorer's basic rightsizing (which looks primarily at CPU), Compute Optimizer analyzes CPU, memory, disk I/O, and network patterns to provide more accurate recommendations. It identifies over-provisioned resources and can recommend downsizing instances, changing instance families, or moving to Graviton processors. For Lambda, it recommends optimal memory configurations. At scale across 300 accounts, Compute Optimizer can identify significant savings opportunities - studies show 20-30% average savings from rightsizing alone. Compute Optimizer can be enabled organization-wide and provides recommendations centrally. (2) AWS Organizations with consolidated billing and Cost Allocation Tags provides the foundation for cost visibility and allocation. Consolidated billing across 300 accounts enables: single bill with aggregated usage for volume discounts, shared Reserved Instance and Savings Plans benefits across accounts, centralized payment method, and cost reporting at organization/OU/account levels. Cost Allocation Tags (both AWS-generated and user-defined tags) enable cost tracking by business unit, project, environment, cost center, and application. You can activate tags organization-wide and then use Cost Explorer and AWS Cost and Usage Reports to filter, group, and analyze costs by these dimensions. For a 300-account enterprise, this visibility is essential for chargeback/showback models and identifying which business units or projects are driving costs. Without proper tagging and consolidated billing, achieving organization-wide cost optimization is nearly impossible. (3) AWS Savings Plans (Compute and EC2 Instance Savings Plans) provide commitment-based discounts that can deliver 20-40% savings compared to On-Demand pricing. Savings Plans require committing to a consistent amount of usage (measured in $/hour) for a 1- or 3-year term. Compute Savings Plans (most flexible) apply to EC2, Fargate, and Lambda across any region, instance family, size, OS, or tenancy. EC2 Instance Savings Plans (less flexible but higher discount) apply to a specific instance family in a specific region. For a large organization with steady-state workloads, Savings Plans should be purchased to cover the baseline usage, with On-Demand for variable workloads. Organizations can share Savings Plans benefits across accounts through consolidated billing. Combined with rightsizing (reducing the baseline) and non-production scheduling (reducing hours), Savings Plans on the optimized baseline can contribute 15-25% of the 30% target reduction. Option A (Cost Explorer) is valuable and includes some rightsizing recommendations, but Compute Optimizer provides more comprehensive and accurate ML-powered recommendations across more service types, making it the better choice for the rightsizing component. Cost Explorer is still useful for visualizing costs and RI recommendations, but Option B is more directly aligned with the rightsizing requirement. Option C (Cost Anomaly Detection) helps identify unusual spending but doesn't directly contribute to the 30% cost reduction target - it's more about governance and preventing budget overruns than optimization. Option D (AWS Budgets with budget actions) can automate stopping resources when budgets are exceeded, which helps with cost control but is reactive rather than proactive optimization. The requirement mentions 'automated scheduling for non-production environments,' which would typically be implemented with Instance Scheduler, Lambda functions with EventBridge rules, or Auto Scaling scheduled actions - Budgets with actions is more about emergency cost controls than planned optimization. The architecture uses Compute Optimizer for identifying rightsizing opportunities (targeting 15-20% savings), Organizations with consolidated billing and cost allocation tags for visibility and sharing of discounts, and Savings Plans for commitment-based discounts on the optimized baseline (targeting 10-15% savings), collectively enabling the 30% cost reduction goal while providing business unit cost visibility."
        },
        {
          "question": "A manufacturing company is implementing an IoT solution for 100,000 factory sensors sending telemetry data every 5 seconds. The solution must ingest high-velocity data, perform real-time anomaly detection to identify equipment failures, store time-series data for 7 years for compliance, and visualize metrics on dashboards. The architecture must be cost-effective at scale. Which THREE AWS services should be implemented? (Select THREE)",
          "options": [
            "AWS IoT Core for device connectivity with MQTT protocol support",
            "Amazon Kinesis Data Streams for ingesting high-velocity sensor data",
            "AWS IoT Analytics for device data processing and analytics",
            "Amazon Timestream for efficient time-series data storage with automated tiering",
            "Amazon Kinesis Data Analytics with Apache Flink for real-time anomaly detection",
            "Amazon QuickSight for creating interactive dashboards and visualizations"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            3,
            4
          ],
          "explanation": "For a large-scale IoT telemetry solution with real-time analytics and long-term storage, the optimal architecture includes: (1) AWS IoT Core provides managed device connectivity and messaging for IoT devices at scale. IoT Core supports MQTT (the standard IoT protocol), MQTT over WebSocket, and HTTPS for device communication. It handles device authentication using X.509 certificates or IAM, manages device registry, and supports device shadows for tracking device state. Critically, IoT Core includes a rules engine that can route device data to various AWS services (Kinesis, Lambda, DynamoDB, Timestream, etc.) without writing custom code. For 100,000 sensors sending data every 5 seconds, IoT Core can easily handle the message throughput (100,000 devices × 12 messages/min = 1.2M messages/min = 20,000 messages/sec), and it scales automatically. IoT Core provides the managed infrastructure for device connectivity that would otherwise require custom MQTT brokers and scaling logic. (2) Amazon Timestream is a purpose-built time-series database optimized for IoT telemetry, application metrics, and operational data. For this use case, Timestream offers several advantages: columnar storage optimized for time-series queries, automatic data lifecycle management with memory store (recent data) and magnetic store (historical data), built-in time-series analytics functions, and data compression that reduces storage costs by 90% compared to relational databases. Critically, Timestream can store data for 7 years cost-effectively through automatic tiering - recent data stays in the fast memory store, and older data automatically moves to the lower-cost magnetic store. Timestream integrates directly with IoT Core rules engine, QuickSight for visualization, and other analytics tools. For 100,000 devices × 12 messages/min × 7 years, Timestream's compression and tiering make it far more cost-effective than storing raw data in S3 or a relational database. (3) Amazon Kinesis Data Analytics with Apache Flink provides real-time stream processing for anomaly detection. Kinesis Data Analytics can consume data from IoT Core (via Kinesis Data Streams or directly), apply real-time SQL queries or Flink applications to detect anomalies, and send alerts when anomalies are detected (via Lambda, SNS, or directly to operational systems). Flink supports sophisticated anomaly detection algorithms including statistical methods, machine learning models, and pattern matching. The managed service handles scaling automatically based on data throughput. For equipment failure prediction, you can implement algorithms that detect when sensor values deviate from normal ranges, when patterns change suddenly, or when correlations between sensors indicate impending failures. Kinesis Data Analytics can write anomaly detection results back to Timestream, S3, or trigger alerts via SNS/Lambda. Option B (Kinesis Data Streams) could be part of the architecture if IoT Core rules route data to Kinesis Data Streams first, but IoT Core can route data directly to Timestream and Kinesis Data Analytics, making a separate Data Streams component optional unless you need the buffer for processing flexibility. The question asks for the three core components, and IoT Core + Timestream + Kinesis Data Analytics provides a more complete answer. Option C (AWS IoT Analytics) provides pre-built data processing pipeline for IoT data including cleansing, filtering, enrichment, and analysis. However, it overlaps significantly with Timestream (for storage) and Kinesis Data Analytics (for real-time processing). IoT Analytics is valuable when you need its specific features like data set versioning and Jupyter notebooks for data science, but for this use case, Timestream (optimized time-series database with 7-year retention) + Kinesis Data Analytics (real-time anomaly detection) provides better cost and performance characteristics. Option F (QuickSight) is the right choice for visualization and dashboards, but when limited to three core services, the ingestion (IoT Core), storage (Timestream), and real-time analytics (Kinesis Data Analytics) are more fundamental. QuickSight would be the fourth component - it integrates directly with Timestream for building time-series dashboards. The architecture uses IoT Core for managed device connectivity at scale, Timestream for cost-effective long-term time-series storage with automatic tiering, and Kinesis Data Analytics for real-time anomaly detection, providing a complete IoT analytics solution."
        },
        {
          "question": "A SaaS company serving enterprise customers needs to implement a tenant isolation strategy for their multi-tenant application. Each tenant's data must be logically isolated, tenant-specific encryption keys must be used, and they need detailed audit logs showing which tenant accessed what data. The solution must scale to 10,000 tenants without significant operational overhead. Which THREE approaches should be implemented? (Select THREE)",
          "options": [
            "Amazon DynamoDB with tenant ID as partition key and fine-grained access control using IAM policies",
            "Separate AWS accounts for each tenant using AWS Control Tower for account provisioning",
            "Amazon S3 with bucket per tenant and S3 Bucket Keys for tenant-specific encryption",
            "AWS KMS with tenant-specific customer managed keys (CMKs) and key policies for tenant isolation",
            "Amazon Cognito with user pools per tenant for authentication and tenant context",
            "AWS CloudTrail with S3 object-level logging for detailed tenant data access auditing"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            3,
            5
          ],
          "explanation": "For a scalable multi-tenant SaaS architecture with data isolation, tenant-specific encryption, and audit logging for 10,000 tenants, the correct approach is: (1) Amazon DynamoDB with tenant ID as partition key and fine-grained access control provides efficient data isolation at scale. In this pattern, the tenant ID is part of the partition key (e.g., 'TENANT#12345#USERID#67890'), ensuring tenant data is logically separated. DynamoDB's fine-grained access control using IAM policies with conditions enables you to restrict users to only access data for their tenant. For example, IAM policies can use DynamoDB condition keys to ensure users can only query items where the partition key contains their tenant ID. This is called the 'pool model' where all tenants share the same tables but data is logically partitioned. This approach scales to thousands of tenants without operational overhead of managing separate tables/databases per tenant. DynamoDB's scalability and performance characteristics make it ideal for multi-tenant SaaS applications. (2) AWS KMS with tenant-specific customer managed keys (CMKs) provides the tenant-specific encryption required for isolation. In this architecture, each tenant has a dedicated KMS CMK. Application code uses the tenant's specific key for encrypting/decrypting their data using envelope encryption. KMS key policies can restrict which IAM roles can use which keys, and key usage is logged in CloudTrail, providing an audit trail of encryption operations per tenant. While managing 10,000 KMS keys requires careful architecture (you can programmatically create and manage keys via API/CloudFormation), it's feasible and provides strong tenant isolation - even if there's a data breach or misconfiguration, data encrypted with Tenant A's key cannot be decrypted by Tenant B. This is critical for enterprise SaaS where tenants demand cryptographic isolation. Some SaaS providers use a key-per-tenant model stored in a centralized key table, but the question specifically asks for tenant-specific encryption keys, making KMS CMKs per tenant the appropriate choice. (3) AWS CloudTrail with S3 object-level logging provides detailed audit logs for data access. CloudTrail logs all API calls including DynamoDB and KMS operations. For DynamoDB, enabling CloudTrail data events captures read/write operations with details about which user/role accessed which items. For S3 (if used for tenant file storage), object-level logging captures GetObject, PutObject, and DeleteObject calls. For KMS, CloudTrail automatically logs all key usage including Encrypt, Decrypt, and GenerateDataKey operations, showing which tenant's key was used for which operation. These logs can be analyzed to create tenant-specific audit reports showing exactly what data was accessed, when, by whom, and for which tenant. For enterprise SaaS customers (especially in regulated industries), this audit capability is a requirement. CloudTrail logs can be centralized, analyzed with Athena, and retained for compliance periods. Option B (separate accounts per tenant) provides the strongest isolation (known as the 'silo model') but creates massive operational overhead at 10,000 tenants. Managing 10,000 AWS accounts, even with Control Tower automation, involves significant complexity in billing, cross-account access, resource deployment, updates, and monitoring. This approach is typically used for high-tier enterprise customers (tens to hundreds), not for scaling to thousands of tenants. Option C (S3 bucket per tenant) faces similar challenges - while S3 Bucket Keys improve encryption performance and reduce KMS costs, managing 10,000 S3 buckets creates operational overhead (bucket policies, lifecycle policies, versioning configuration, etc.). A more scalable approach is using a shared bucket with prefixes per tenant (TENANT#12345/files/) combined with IAM policies restricting access to specific prefixes and using tenant-specific KMS keys for encryption. Option D (Cognito user pools per tenant) provides tenant-specific authentication but creates operational overhead at 10,000 tenants. A more scalable approach is a single Cognito user pool with custom attributes indicating tenant ID, or using a centralized IdP (like Auth0, Okta) with tenant context. While Cognito per tenant provides isolation, it's not necessary for the stated requirements and complicates user management at scale. The architecture uses DynamoDB with partition key-based data isolation (pool model), tenant-specific KMS CMKs for cryptographic separation, and CloudTrail for comprehensive audit logging, providing tenant isolation that scales to thousands of tenants with manageable operational overhead."
        },
        {
          "question": "A global e-commerce company needs to migrate 5,000 on-premises Windows and Linux servers to AWS over a 12-month period. They require automated discovery of server dependencies, application grouping for wave-based migration planning, and continuous tracking of migration progress. The migration will use a combination of rehosting and replatforming strategies. Which THREE AWS services should be used for discovery, planning, and migration execution? (Select THREE)",
          "options": [
            "AWS Migration Hub for centralized migration tracking and progress monitoring",
            "AWS Application Discovery Service for automated discovery of server inventory and dependencies",
            "AWS Migration Evaluator (formerly TSO Logic) for total cost of ownership analysis",
            "AWS Application Migration Service (MGN) for lift-and-shift rehosting of servers",
            "AWS Server Migration Service (SMS) for incremental replication-based migration",
            "AWS Database Migration Service (DMS) for database replatforming"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            3
          ],
          "explanation": "For a large-scale server migration with automated discovery, planning, and execution, the correct combination is: (1) AWS Migration Hub provides centralized tracking and visibility across the entire migration. Migration Hub acts as the command center where you can: discover existing servers using Application Discovery Service, group servers into applications for wave planning, track the status of migrations across multiple tools (MGN, DMS, etc.), view migration progress in a unified dashboard, and integrate with AWS migration partners. For a 5,000-server migration over 12 months, Migration Hub is essential for program management, stakeholder reporting, and ensuring nothing falls through the cracks. It provides the single pane of glass across the migration program. (2) AWS Application Discovery Service automates the discovery process for on-premises infrastructure. Discovery Service has two modes: Agentless Discovery (via VMware vCenter) collects configuration and utilization data, and Agent-based Discovery (via lightweight agents installed on servers) collects detailed data including server specs, performance metrics, network connections, and running processes. Critically, agent-based discovery maps server dependencies by observing network connections, identifying which servers communicate with each other. This dependency mapping is essential for application grouping and wave planning - you can't migrate a web server without also migrating its database and cache servers. Discovery Service exports data to Migration Hub and can generate server dependency maps showing application architectures, enabling intelligent wave planning that respects dependencies. For 5,000 servers, automated discovery is the only scalable approach; manual discovery is error-prone and time-consuming. (3) AWS Application Migration Service (MGN) is AWS's primary tool for rehosting (lift-and-shift) migrations. MGN has replaced SMS as the recommended solution. MGN performs continuous, block-level replication of source servers to AWS, creates low-cost staging instances for testing, enables non-disruptive testing of migrated servers, and performs final cutover with minimal downtime (typically minutes). MGN supports both Windows and Linux, works with physical, virtual, and cloud servers, and is agentless from the AWS perspective (you install a lightweight replication agent on source servers). For rehosting strategy at scale, MGN is the current best practice - it's simpler than SMS, supports more source types, and provides better testing capabilities. MGN integrates with Migration Hub for tracking. Option C (Migration Evaluator) provides business case development and TCO analysis, which is valuable for justifying the migration and rightsizing targets, but isn't part of the core 'discovery, planning, and execution' workflow described in the question. Migration Evaluator would typically be used before the migration program starts to build the business case. Option E (SMS) has been superseded by MGN (Application Migration Service) as AWS's recommended rehosting solution. While SMS still works, AWS is directing new customers to MGN. If this were an older exam question, SMS would be correct, but for current best practices, MGN is the answer. Option F (DMS) is for database migration and replatforming (e.g., Oracle to Aurora, SQL Server to RDS), which may be part of the overall program, but the question specifically asks about discovery, planning, and migration of servers (compute workloads). While DMS might be used for some databases, it's not one of the core three for the server migration program - MGN handles the server rehosting including application databases on those servers, and DMS would be a supplementary tool for database-specific replatforming scenarios. The architecture uses Application Discovery Service for automated server inventory and dependency mapping, Migration Hub for centralized tracking and wave planning across the program, and Application Migration Service (MGN) for executing the rehosting migrations, providing end-to-end capabilities for a large-scale server migration program."
        },
        {
          "question": "A healthcare provider is migrating a legacy on-premises application to AWS that processes Protected Health Information (PHI). The application must comply with HIPAA regulations, including encryption of data at rest and in transit, audit logging of all access to PHI, network isolation, and automatic security patching. They need to minimize operational overhead while maintaining compliance. Which THREE AWS services/features should be implemented as part of the compliance architecture? (Select THREE)",
          "options": [
            "AWS Systems Manager Patch Manager for automated patch management of EC2 instances",
            "Amazon Macie for automated discovery and protection of PHI stored in S3",
            "AWS Config with HIPAA-specific conformance packs for continuous compliance monitoring",
            "AWS Artifact for accessing HIPAA compliance documentation and BAA agreements",
            "AWS Shield Standard for DDoS protection of healthcare applications",
            "Amazon GuardDuty for threat detection and continuous security monitoring"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            2
          ],
          "explanation": "For HIPAA-compliant migration with automated security and compliance, the correct services are: (1) AWS Systems Manager Patch Manager automates the patching process for EC2 instances running Windows and Linux. Patch Manager enables you to define patch baselines (which patches to apply), create maintenance windows (when patching occurs), scan instances for missing patches, automatically apply patches, and generate compliance reports showing patch status across all instances. For HIPAA compliance, automatic security patching is critical to prevent vulnerabilities that could lead to PHI breaches. Patch Manager integrates with AWS Config to report compliance status and can be configured to automatically patch instances on a schedule (e.g., weekly), meeting the 'minimize operational overhead' requirement. For a healthcare provider migrating from on-premises, automating patch management removes significant operational burden while improving security posture. (2) Amazon Macie provides automated discovery and protection of sensitive data including PHI. Macie uses machine learning and pattern matching to automatically discover PHI stored in S3 buckets (e.g., patient names, medical record numbers, health insurance information). Macie continuously monitors S3 for sensitive data, evaluates bucket policies and access controls for security risks, detects overly permissive access to sensitive data, generates findings when sensitive data is discovered or security risks are identified, and integrates with Security Hub and EventBridge for alerting. For HIPAA compliance, knowing where PHI is stored and ensuring it's properly protected is fundamental. Macie automates this discovery process, which would otherwise require manual data classification - with potentially thousands of S3 buckets, automated discovery is the only scalable approach. (3) AWS Config with HIPAA-specific conformance packs provides continuous compliance monitoring against HIPAA requirements. AWS Config conformance packs are pre-built collections of Config rules that map to compliance frameworks. The Operational Best Practices for HIPAA Security conformance pack includes rules that check: encryption at rest for EBS, S3, RDS; encryption in transit with HTTPS/TLS; CloudTrail logging enabled; VPC flow logs enabled; MFA enabled for root account; security groups don't allow unrestricted access; and many other HIPAA-related security controls. Config continuously evaluates resources against these rules and reports non-compliant resources, enabling you to remediate issues before they become audit findings. For the stated requirements (encryption, audit logging, network isolation), Config conformance packs provide automated, continuous verification that these controls are in place, reducing compliance risk and audit preparation effort. Option D (AWS Artifact) provides access to AWS compliance reports, HIPAA attestations, and the Business Associate Addendum (BAA) required for HIPAA compliance. While signing a BAA with AWS is a prerequisite for hosting PHI, Artifact is a documentation portal, not an active compliance service that enforces security controls or provides automated compliance capabilities. It's a necessary step during setup but not part of the ongoing compliance architecture. Option E (AWS Shield Standard) provides DDoS protection and is automatically enabled for all AWS customers at no additional cost. While DDoS protection contributes to availability (which is important for healthcare applications), Shield Standard doesn't specifically address the HIPAA requirements listed (encryption, audit logging, patching, network isolation). Shield Advanced (not Standard) would provide enhanced DDoS protection and 24/7 support, but neither Shield Standard nor Advanced are among the core services for this HIPAA compliance architecture focused on data protection and compliance monitoring. Option F (GuardDuty) provides threat detection by analyzing VPC Flow Logs, CloudTrail logs, and DNS logs to identify malicious or unauthorized activity. GuardDuty is valuable for security monitoring and can detect threats like cryptocurrency mining, communication with known malicious IPs, or compromised instances. However, when limited to three core services for the stated requirements, Patch Manager (addresses 'automatic security patching'), Macie (addresses 'PHI discovery and protection'), and Config with HIPAA conformance pack (addresses 'encryption, audit logging, network isolation' through continuous compliance checking) provide more direct alignment with the specific HIPAA requirements listed. GuardDuty would be an excellent fourth service for defense-in-depth threat detection. The architecture uses Systems Manager Patch Manager for automated security patching, Macie for PHI discovery and data protection monitoring, and Config with HIPAA conformance packs for continuous compliance validation, collectively addressing HIPAA requirements with minimal operational overhead."
        }
      ]
    },
    {
      "filename": "domain-1-task-1.1-network-connectivity.json",
      "domain": "Domain 1: Organizational Complexity",
      "task": "Task 1.1: Network Connectivity",
      "question_count": 12,
      "questions": [
        {
          "question": "A global financial services company has four 100 Gbps AWS Direct Connect connections in a Link Aggregation Group (LAG) at their primary location. They need to enable MACsec encryption for security compliance. After reviewing the requirements, what is the PRIMARY limitation they will face?",
          "options": [
            "MACsec is not supported on 100 Gbps connections, only on 10 Gbps and 400 Gbps",
            "Each connection in the LAG can use a different MACsec key for enhanced security",
            "LAGs with 100 Gbps connections can only have a maximum of two connections, not four",
            "MACsec requires dynamic CAK mode which is not supported on Direct Connect"
          ],
          "correctAnswer": 2,
          "explanation": "According to AWS Direct Connect limits, LAGs can have a maximum of 4 connections when the port speed is 1 Gbps or 10 Gbps, but only 2 connections when the port speed is 100 Gbps or 400 Gbps. This means they would need to reduce from four to two connections. Option A is incorrect because MACsec IS supported on 100 Gbps (also 10 Gbps and 400 Gbps). Option B is incorrect because only a single MACsec key can be used across all LAG links at any time (multiple keys are only for rotation). Option D is incorrect because Direct Connect supports static CAK mode, which is what's required (dynamic CAK is not supported, but static is)."
        },
        {
          "question": "An enterprise with a hub-and-spoke network architecture using AWS Transit Gateway across multiple regions is experiencing routing issues. They have 15,000 routes that need to be advertised from on-premises through a transit virtual interface. What is the MOST likely cause of their connectivity problems?",
          "options": [
            "Transit Gateway route tables have a hard limit of 10,000 routes, exceeding which causes route drops",
            "Transit virtual interfaces support only 100 prefixes from AWS to on-premises by default",
            "Transit Gateway VPN connections have a hard limit of 100 BGP routes, causing random BGP session resets",
            "The MTU size of 8500 bytes on Transit Gateway is causing packet fragmentation issues"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Transit Gateway route tables can hold up to 10,000 routes (static or propagated combined). With 15,000 routes being advertised, this exceeds the limit and will cause routing issues. Option B is partially correct about limits but outdated - the prefix limit per Transit Gateway from AWS to on-premises on a transit virtual interface was increased to 200 in early 2023, and this relates to routes FROM AWS, not TO AWS. Option C is true about VPN connections but the scenario mentions a transit virtual interface (Direct Connect), not VPN. Option D is incorrect because 8500 byte MTU is supported for Direct Connect attachments and wouldn't cause connectivity problems; rather it's a feature for jumbo frames."
        },
        {
          "question": "A company is designing a multi-region network architecture and is evaluating between AWS Transit Gateway with cross-region peering and AWS Cloud WAN. They have workloads in 8 AWS regions with plans to expand to 15 regions, require automated VPC attachments, and need centralized network policy management. Which solution is MOST appropriate and why?",
          "options": [
            "AWS Transit Gateway because it provides better cross-region performance and lower latency than Cloud WAN",
            "AWS Cloud WAN because it provides centralized management, automated VPC attachments, and global network automation that scales across multiple regions",
            "AWS Transit Gateway because Cloud WAN doesn't support integration with existing Transit Gateway infrastructure",
            "AWS Cloud WAN because Transit Gateway has a hard limit of 5 regions per deployment"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Cloud WAN is specifically designed for multi-region, global network deployments with centralized management and automation. It provides automated VPC attachments, centralized policy management, and automatic inter-region connectivity without manual peering configuration. With 8+ regions and plans for 15, Cloud WAN's automated management significantly reduces operational overhead compared to manually managing Transit Gateway peering connections across 15 regions. Option A is incorrect - both services provide similar performance characteristics. Option C is false - Cloud WAN can federate with Transit Gateways and replace manual peering. Option D is false - Transit Gateway has no such 5-region limit; you can use it in all AWS regions, but managing many regions becomes operationally complex."
        },
        {
          "question": "A Solutions Architect is designing a hybrid network with redundant connectivity. The company has two AWS Direct Connect connections at different locations and wants to implement backup VPN connectivity. For both Direct Connect connections, they're using BGP with the same AS number, and they want the VPN to only be used when both Direct Connect connections fail. Which configuration achieves this MOST effectively?",
          "options": [
            "Configure the VPN with a longer AS path prepend to make it less preferred than Direct Connect routes",
            "Set the Direct Connect BGP routes with a local preference of 200 and VPN routes with local preference of 100",
            "Use the same BGP weight on all connections and rely on the inherent Direct Connect route preference",
            "Configure Direct Connect to advertise routes with MED value of 50 and VPN with MED value of 100"
          ],
          "correctAnswer": 0,
          "explanation": "AS path prepending is the correct approach for making VPN backup routes less preferred. When you prepend additional AS numbers to the VPN route advertisements, the BGP path becomes longer, making it less preferred in BGP path selection. Direct Connect routes will naturally be preferred due to shorter AS path. This ensures VPN is only used when Direct Connect fails. Option B discusses local preference, which is configured on the AWS side and controls outbound traffic preference from AWS, but the question implies controlling both directions and ensuring proper failover. Option C is incorrect because while Direct Connect routes are generally preferred over VPN, relying solely on implicit preferences without explicit configuration isn't a reliable design pattern. Option D (MED) works for influencing incoming traffic from a single AS, but AS path prepending is more universally effective across different routing scenarios."
        },
        {
          "question": "An organization has overlapping CIDR ranges (10.0.0.0/16) in two VPCs that cannot be re-addressed due to legacy application constraints. Both VPCs need to communicate with a central shared services VPC. The shared services VPC should be able to initiate connections to specific subnets in both VPCs. What is the MOST operationally efficient solution?",
          "options": [
            "Use Transit Gateway with separate route tables and route propagation to handle overlapping CIDRs automatically",
            "Deploy AWS PrivateLink endpoints in both VPCs, allowing the shared services VPC to access services without direct network routing",
            "Implement NAT Gateways in each VPC with Elastic IPs and use IP-based routing in the shared services VPC",
            "Use VPC Peering with longest prefix match routing to route to the correct VPC based on more specific subnet ranges"
          ],
          "correctAnswer": 1,
          "explanation": "AWS PrivateLink is specifically designed to solve the overlapping IP problem. Services in the overlapping VPCs can be exposed through PrivateLink endpoints, which are accessed via unique DNS names and endpoint-specific IP addresses that don't overlap. The shared services VPC can connect to these endpoint services without requiring direct network routing between overlapping CIDR ranges. Option A is incorrect because Transit Gateway does NOT support overlapping CIDRs between attached VPCs - this is a fundamental limitation. Option C is overly complex and doesn't truly solve the bidirectional communication problem efficiently. Option D is incorrect because VPC Peering also does not support overlapping CIDR blocks - this is explicitly documented as a limitation."
        },
        {
          "question": "A company using AWS Site-to-Site VPN with BGP routing to their corporate data center is experiencing issues where their Transit Gateway VPN connection randomly drops and re-establishes BGP sessions every few hours. They have 150 BGP prefixes being advertised from on-premises. What is the MOST likely root cause?",
          "options": [
            "The VPN tunnel encryption overhead is causing packet loss at high throughput",
            "Transit Gateway VPN has a hard limit of 100 BGP routes, and exceeding this causes random BGP session resets",
            "BGP keepalive timers are misconfigured, causing the sessions to time out prematurely",
            "The VPN connection is experiencing MTU issues because Transit Gateway doesn't support PMTUD on VPN"
          ],
          "correctAnswer": 1,
          "explanation": "This is a critical and tricky limitation: Transit Gateway VPN connections have the same hard limit of 100 BGP routes as classic VGW VPN. When BGP prefixes exceed 100, the TGW VPN randomly resets the BGP session, leading to unpredictable network outages. With 150 prefixes being advertised, this exceeds the limit and would cause exactly the behavior described. The solution would be to summarize routes or use static routing. Option A is unlikely to cause random BGP resets. Option C could cause issues but wouldn't specifically correlate with the number of routes. Option D is true (Transit Gateway doesn't support PMTUD on VPN) but this would cause fragmentation issues, not random BGP session resets."
        },
        {
          "question": "A global corporation needs to connect 6,000 VPCs across multiple AWS accounts and regions. They require network segmentation, where only certain groups of VPCs can communicate with each other. They want to minimize operational overhead. Which architecture should they implement?",
          "options": [
            "Deploy multiple Transit Gateways, one per segment, with VPC attachments and cross-region peering",
            "Use a single AWS Cloud WAN with segment-based policies and automated VPC attachment rules",
            "Implement VPC Peering with a hub-and-spoke topology using a central inspection VPC",
            "Cannot be achieved as Transit Gateway has a hard limit of 5,000 VPC attachments"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Cloud WAN is the optimal solution for this scale and requirement. Cloud WAN supports network segmentation through segments (isolated routing domains) and can handle thousands of VPC attachments with automated attachment policies. It provides centralized configuration and policy management across regions, significantly reducing operational overhead compared to managing multiple Transit Gateways. Option A would work but creates significant operational overhead managing multiple Transit Gateways and their peering connections at this scale. Option C (VPC Peering) is not scalable - you'd need thousands of individual peering connections. Option D contains a true fact (Transit Gateway limit is 5,000 VPCs) but that's why this scenario exceeds a single TGW capacity and Cloud WAN is needed, which can scale beyond a single TGW's limits through its distributed architecture."
        },
        {
          "question": "A company has a Direct Connect connection with a private virtual interface attached to a Virtual Private Gateway (VGW) for a single VPC. They want to expand connectivity to 50 VPCs in the same region without creating 50 separate virtual interfaces. What is the MOST scalable solution?",
          "options": [
            "Create a Transit Gateway, migrate the VGW attachment to a Transit Virtual Interface, and attach all VPCs to the Transit Gateway",
            "Use VPC Peering to connect all 50 VPCs to the original VPC that has the Direct Connect connection",
            "Create 50 private virtual interfaces on the same Direct Connect connection, one for each VPC",
            "Use AWS PrivateLink to share the Direct Connect connectivity across all VPCs"
          ],
          "correctAnswer": 0,
          "explanation": "Migrating to Transit Gateway with a Transit Virtual Interface is the correct and most scalable approach. A single Direct Connect connection with a Transit Virtual Interface can connect to a Transit Gateway, which can then attach up to 5,000 VPCs. This provides a hub-and-spoke model with centralized routing. Option B (VPC Peering) would require 49 peering connections from the primary VPC and doesn't provide a scalable routing model for on-premises connectivity. Option C technically works but is operationally nightmare - managing 50 virtual interfaces and their BGP sessions is not scalable and you're limited by the number of virtual interfaces per connection (50 private VIFs limit). Option D is incorrect - PrivateLink is for service connectivity, not for providing network-layer Direct Connect connectivity."
        },
        {
          "question": "A company is implementing AWS Direct Connect with MACsec encryption for compliance. They are using 10 Gbps dedicated connections. During the security review, the CISO asks which encryption cipher will be used. What should the Solutions Architect respond?",
          "options": [
            "AES-128-GCM only, as it's the standard for 10 Gbps connections",
            "Either GCM-AES-256 or GCM-AES-XPN-256, both are supported for 10 Gbps connections",
            "GCM-AES-XPN-256 only, as it's required for all MACsec implementations",
            "TLS 1.3 with AES-256, as Direct Connect uses TLS for encryption"
          ],
          "correctAnswer": 1,
          "explanation": "For 10 Gbps Direct Connect connections, AWS MACsec supports both GCM-AES-256 and GCM-AES-XPN-256 cipher suites. The XPN (Extended Packet Numbering) variant provides extended packet numbering for very high-volume traffic scenarios. Only 256-bit keys are supported (not 128-bit). For 100 Gbps and 400 Gbps connections, only GCM-AES-XPN-256 is supported. Option A is incorrect because 128-bit is not supported; only 256-bit keys are supported. Option C is incorrect because for 10 Gbps, you have a choice between standard and XPN variants. Option D is fundamentally wrong - MACsec operates at Layer 2 (data link layer) and uses GCM-AES encryption, not TLS which is a Layer 4/7 protocol."
        },
        {
          "question": "An enterprise is designing a hybrid DNS architecture using Amazon Route 53 Resolver. They need on-premises servers to resolve AWS private hosted zone queries and AWS resources to resolve on-premises DNS queries. The on-premises network is connected via Direct Connect. Which components are required? (Select THREE)",
          "options": [
            "Route 53 Resolver inbound endpoints in AWS VPCs",
            "Route 53 Resolver outbound endpoints in AWS VPCs",
            "Resolver rules forwarding on-premises domains to on-premises DNS servers",
            "VPC DNS resolution enabled (enableDnsSupport)",
            "A separate NAT Gateway for DNS traffic",
            "Route 53 public hosted zones configured as private"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            2
          ],
          "explanation": "This requires three main components: (1) Inbound endpoints - allow on-premises DNS servers to forward queries to Route 53 Resolver for private hosted zones, (2) Outbound endpoints - allow AWS resources to forward queries for on-premises domains to on-premises DNS servers, and (3) Resolver rules - define which domains should be forwarded to on-premises DNS servers. While VPC DNS resolution (Option D) must be enabled as a prerequisite, the question asks for the three main components you actively configure. Option E (NAT Gateway) is not needed - DNS traffic flows through the Direct Connect connection using the Resolver endpoints. Option F is incorrect - you don't convert public hosted zones to private; private hosted zones are created separately for internal DNS resolution."
        },
        {
          "question": "A company has a Transit Gateway with three route tables: Production, Development, and Shared-Services. The Production VPCs should be able to access Shared-Services but NOT Development. Development VPCs should access both Shared-Services and Production for read-only database access. Shared-Services should reach both. What is the CORRECT route table association and propagation strategy?",
          "options": [
            "Associate each VPC with its own route table, propagate Shared-Services routes to all tables, propagate Production to Development and Shared-Services tables only",
            "Associate each VPC with its own route table, propagate routes bidirectionally between all tables to ensure full connectivity",
            "Use a single route table with security groups to control access between environments",
            "Associate Production and Development with separate tables, use blackhole routes in Production table for Development CIDRs, propagate all routes to Shared-Services table"
          ],
          "correctAnswer": 0,
          "explanation": "Transit Gateway route table association and propagation works as follows: Each VPC attachment is associated with ONE route table (which determines where traffic FROM that VPC can go). Route propagation determines which VPC routes appear in which route tables. For this scenario: Production VPCs associate with Production route table (which has Shared-Services routes propagated, but NOT Development routes). Development VPCs associate with Development route table (which has both Shared-Services AND Production routes propagated). Shared-Services VPCs associate with Shared-Services route table (which has both Production and Development routes propagated). Option B creates full mesh which violates the requirement. Option C is incorrect - security groups don't work across VPCs through Transit Gateway; routing controls the connectivity. Option D's blackhole approach is more complex than necessary and doesn't address the Development-to-Production read access requirement properly."
        },
        {
          "question": "A media streaming company requires their AWS resources to communicate with their on-premises data center using private IP addresses for services like S3 and DynamoDB, without traversing the public internet. They have Direct Connect established. Which architecture components are required? (Select THREE)",
          "options": [
            "VPC Gateway Endpoints for S3 and DynamoDB in each VPC",
            "AWS Transit Gateway with Direct Connect Gateway attachment",
            "VPC Interface Endpoints (AWS PrivateLink) for S3 and DynamoDB",
            "Direct Connect public virtual interface for AWS service access",
            "Route tables in each VPC routing S3 and DynamoDB prefixes to the Transit Gateway",
            "NAT Gateway for outbound connectivity to AWS services"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            4
          ],
          "explanation": "This scenario requires: (1) VPC Gateway Endpoints for S3 and DynamoDB - these create route table entries that direct traffic to these services through AWS's private network, (2) Transit Gateway with Direct Connect Gateway - this connects on-premises to the VPCs through private connectivity, and (3) Route table entries routing the VPC endpoint prefixes to the Transit Gateway so on-premises traffic can reach the gateway endpoints. The gateway endpoints use AWS's private IP space and don't traverse the internet. Option C (Interface Endpoints) could technically work but are more expensive than gateway endpoints for S3/DynamoDB and the question implies using gateway endpoints (the standard solution). Option D (public VIF) would traverse public AWS network space, not meeting the requirement. Option F (NAT Gateway) is for internet access, not AWS service access via private IPs."
        }
      ]
    },
    {
      "filename": "domain-1-task-1.2-security-controls.json",
      "domain": "Domain 1: Organizational Complexity",
      "task": "Task 1.2: Security Controls",
      "question_count": 12,
      "questions": [
        {
          "question": "A company has implemented AWS Organizations with multiple OUs. The security team has created an IAM policy allowing EC2:* actions and attached it to developers' roles. However, there's an SCP at the OU level denying ec2:TerminateInstances. A developer with the IAM policy tries to terminate an instance but receives an access denied error. After investigation, the security team updates the IAM policy to explicitly allow ec2:TerminateInstances. What will happen?",
          "options": [
            "The developer will now be able to terminate instances because the explicit IAM allow overrides the SCP deny",
            "The developer still cannot terminate instances because SCPs are at the top of the permission hierarchy and IAM policies cannot override SCP denies",
            "The developer can terminate instances only in the specific region where the IAM policy was updated",
            "The developer can terminate instances because IAM policies are evaluated before SCPs in the permission evaluation logic"
          ],
          "correctAnswer": 1,
          "explanation": "SCPs sit at the top of the AWS permission hierarchy. Even if an IAM policy explicitly grants a permission, an SCP can override this by denying it. If an SCP denies an action on an account, no entity in that account can perform that action, regardless of their IAM permissions. SCPs act as a permission filter - they set the maximum permissions available. The intersection of allowed permissions (IAM policy allows ec2:TerminateInstances) and SCP permissions (SCP denies ec2:TerminateInstances) results in a deny. The only way to fix this is to modify the SCP, not the IAM policy."
        },
        {
          "question": "An organization wants to implement ABAC (Attribute-Based Access Control) to reduce the number of IAM policies they manage. They have 50 development teams, each working on different projects. Currently, they have separate IAM roles for each team-project combination (200+ roles). Which ABAC implementation would be MOST effective for reducing policy management complexity?",
          "options": [
            "Create one IAM role per team with policies granting access only to resources where the resource tag 'Team' matches the principal's tag 'Team', and tag resources with project names",
            "Create one IAM role per project with policies checking both team and project tags, reducing roles from 200 to 50",
            "Create a single developer role with a policy that grants access when both principal tags (Team and Project) match the corresponding resource tags",
            "Keep separate roles but use ABAC to validate that resource tags match principal tags at runtime"
          ],
          "correctAnswer": 2,
          "explanation": "The most effective ABAC implementation is option C: a single IAM role with a policy using conditions like 'StringEquals: {\"aws:PrincipalTag/Team\": \"${aws:ResourceTag/Team}\", \"aws:PrincipalTag/Project\": \"${aws:ResourceTag/Project}\"}'. When developers federate into AWS, their Team and Project attributes from the IdP become session tags. The single policy grants access when tags match, eliminating the need for 200+ roles. This scales automatically - when new teams or projects are created, no policy updates are needed, just proper tagging. Option A still requires multiple roles (50). Option B only partially reduces roles. Option D doesn't actually reduce the number of roles. The key ABAC benefit is: you can allow actions on all resources if the resource's tag matches the principal's tag, dramatically reducing policy count."
        },
        {
          "question": "A security team needs to implement cross-account access for an application in Account A to read objects from an S3 bucket in Account B. The bucket contains highly sensitive data. What is the MOST secure implementation that follows AWS best practices?",
          "options": [
            "Create an IAM user in Account B with access keys, grant S3 read permissions, and store the credentials in AWS Secrets Manager in Account A",
            "Enable S3 bucket public access with an S3 bucket policy restricting access to the source IP addresses of Account A's resources",
            "Create an IAM role in Account B with S3 read permissions, configure a trust policy allowing Account A to assume it, and have the application in Account A assume the role using STS",
            "Use S3 bucket ACLs to grant the Account A root account read permissions on all objects"
          ],
          "correctAnswer": 2,
          "explanation": "Cross-account access using IAM roles with AssumeRole is the AWS best practice and most secure approach. The IAM role in Account B has a trust policy specifying Account A as a trusted entity. The application in Account A assumes this role using STS AssumeRole, receiving temporary credentials. This approach: (1) uses temporary credentials (not long-lived access keys), (2) can include ExternalId for additional security, (3) can include conditions like source IP or MFA, (4) provides clear audit trails in CloudTrail. Option A uses long-lived credentials which are less secure and harder to rotate. Option B making the bucket public is a severe security risk even with IP restrictions. Option D using ACLs is deprecated and AWS recommends using bucket policies and IAM policies instead. Additionally, bucket ACLs can't enforce the same granular controls as IAM roles."
        },
        {
          "question": "A company implements AWS SSO (IAM Identity Center) integrated with their corporate Active Directory. They need some users to access AWS with elevated privileges only after MFA verification, while others can access without MFA for read-only operations. How should this be implemented in IAM Identity Center?",
          "options": [
            "Create two permission sets: one requiring MFA at the permission set level for elevated access, and one without MFA for read-only access",
            "Configure MFA at the IAM Identity Center identity source level, making it required for all users, then use attribute-based access control to bypass MFA for read-only users",
            "Create one permission set with conditions using 'aws:MultiFactorAuthPresent' to grant elevated permissions when MFA is used and read-only permissions otherwise",
            "IAM Identity Center enforces MFA at the login level only, so use separate AWS accounts for elevated and read-only access"
          ],
          "correctAnswer": 2,
          "explanation": "The correct approach is to create a single permission set with conditional policies using 'aws:MultiFactorAuthPresent'. The policy grants elevated permissions when 'aws:MultiFactorAuthPresent': 'true' and grants only read-only permissions when this condition is false or when MFA wasn't used. Users can choose to sign in with or without MFA, and their permissions adjust accordingly. This provides flexibility and follows the principle of progressive access. Option A would work but requires users to be assigned to different permission sets based on their intended action, which is less flexible. Option B is incorrect - you can't selectively bypass MFA requirements for certain users if it's enforced at the identity source level. Option D is overly complex and not necessary. The key is understanding that IAM conditions can differentiate permissions based on MFA presence in the same session."
        },
        {
          "question": "An enterprise must ensure that no IAM role in their organization can be created or modified to allow iam:PassRole to 'AdminRole' without security team approval. They want to prevent this across all accounts in their AWS Organization proactively. What is the MOST effective implementation? (Select TWO)",
          "options": [
            "Create an SCP that denies iam:CreateRole and iam:PutRolePolicy if the policy being created contains iam:PassRole for AdminRole",
            "Use AWS Config with a custom rule that detects iam:PassRole permissions for AdminRole and automatically remediates",
            "Implement IAM Access Analyzer custom policy checks in a CI/CD pipeline to validate policies before deployment",
            "Use AWS Control Tower guardrails to prevent creation of policies with iam:PassRole for AdminRole",
            "Enable AWS CloudTrail and create EventBridge rules to detect and alert on iam:PassRole usage",
            "Configure AWS Organizations to require approval workflows for all IAM changes"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2
          ],
          "explanation": "The most effective preventive controls are: (1) An SCP that denies creating/modifying roles containing iam:PassRole for AdminRole - this provides organization-wide preventive control at the permission boundary level. In September 2025, AWS Organizations added full IAM policy language support for SCPs, including conditions and resource ARNs, making it possible to deny policies based on their content. (2) IAM Access Analyzer custom policy checks in CI/CD pipelines provide proactive validation before deployment, detecting violations early. Options B and E are detective controls (detect after the fact) rather than preventive. Option D (Control Tower guardrails) could work but is less granular than SCPs for this specific use case. Option F doesn't exist - Organizations doesn't have built-in approval workflows. The key is preventing the issue before it happens (preventive) vs detecting it after (detective)."
        },
        {
          "question": "A company uses AWS Secrets Manager for database credentials rotation. Their application runs on ECS Fargate across multiple environments (dev, staging, prod). They want to ensure that the dev environment can only access dev secrets, staging can only access staging secrets, etc. What is the MOST secure and maintainable approach?",
          "options": [
            "Create separate AWS accounts for each environment and store secrets in each account",
            "Use a single Secrets Manager with resource-based policies on each secret restricting access to specific ECS task roles",
            "Tag secrets with environment tags and use IAM policies with conditions checking that the principal tag matches the secret's resource tag",
            "Store secrets in Parameter Store instead and use different AWS KMS keys for each environment with key policies restricting access"
          ],
          "correctAnswer": 2,
          "explanation": "ABAC with tag-based access control (Option C) is the most scalable and maintainable approach. Tag secrets with 'Environment:dev', 'Environment:staging', etc., and tag ECS task roles with the same. The IAM policy uses: 'Condition': {'StringEquals': {'aws:PrincipalTag/Environment': '${aws:ResourceTag/Environment}'}}. This scales automatically - new environments require no policy updates, just consistent tagging. Option A (separate accounts) works but is heavy-weight for environment separation within the same workload. Option B (resource policies on each secret) doesn't scale well and requires updating policies for each new secret or task role. Option D (Parameter Store with different KMS keys) could work but is more complex than necessary and doesn't leverage ABAC's scalability benefits. The tag-based approach also makes it easy to audit and visualize access patterns."
        },
        {
          "question": "A security audit reveals that several IAM policies in the organization grant iam:PassRole with a wildcard (*) in the Resource element. IAM Access Analyzer flags this as a security warning. Why is this a security concern, and what is the recommended remediation?",
          "options": [
            "It's not actually a security risk; IAM Access Analyzer is overly cautious. The Action element restrictions are sufficient",
            "It allows privilege escalation - users could pass highly privileged roles to services like Lambda or EC2, gaining those privileges indirectly. Restrict the Resource to specific role ARNs",
            "It only affects CloudFormation deployments. Remediation is to use service-specific PassRole permissions",
            "The warning is about performance. Wildcards in PassRole slow down IAM evaluation. Use explicit role ARNs for better performance"
          ],
          "correctAnswer": 1,
          "explanation": "iam:PassRole with wildcard resource is a critical security finding because it enables privilege escalation. A user with this permission can pass ANY role (including highly privileged admin roles) to AWS services. For example, they could: (1) Create a Lambda function and pass it an AdminRole, then invoke the function to execute admin actions, or (2) Launch an EC2 instance with an AdminRole, then access the instance to gain admin privileges. This bypasses direct permission grants. The remediation is to explicitly specify which roles can be passed: 'Resource': ['arn:aws:iam::account:role/SpecificAppRole']. This is why IAM Access Analyzer flags it as a SECURITY WARNING (not just a suggestion). Options C and D are incorrect - this is not about CloudFormation or performance. Option A is dangerously wrong - this IS a genuine security risk. The principle: iam:PassRole should be as restrictive as direct permission grants, as it's effectively an indirect way to gain those permissions."
        },
        {
          "question": "An organization with 500+ AWS accounts wants to implement centralized security findings aggregation from AWS Security Hub. They want a security team in a central account to view and manage findings from all accounts. What configuration is required? (Select THREE)",
          "options": [
            "Enable AWS Security Hub in all 500+ accounts",
            "Designate one account as the Security Hub administrator account in AWS Organizations",
            "Create cross-account IAM roles for Security Hub to assume in each member account",
            "Enable auto-enabling for Security Hub to automatically enable it in new accounts",
            "Configure Security Hub finding aggregation across all AWS regions to the administrator account",
            "Use AWS Config aggregators to collect Security Hub findings"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            3
          ],
          "explanation": "The required configuration includes: (1) Enable Security Hub in all accounts - required for findings generation, (2) Designate a Security Hub administrator account - this central account can view and manage findings from all member accounts in the organization, (3) Enable auto-enabling - ensures new accounts automatically have Security Hub enabled and associated with the administrator account. Option C is not needed - when using AWS Organizations integration, Security Hub uses service-linked roles automatically, not cross-account IAM roles. Option E relates to cross-region aggregation, which is a separate feature and not strictly required for multi-account setup (though useful). Option F is incorrect - AWS Config aggregators are for Config data, not Security Hub. Security Hub has its own built-in aggregation mechanism when you designate an administrator account."
        },
        {
          "question": "A company needs to enforce that all EBS volumes and RDS databases created in their AWS Organization must be encrypted with customer-managed KMS keys (CMKs), not AWS-managed keys. What is the MOST effective enforcement mechanism?",
          "options": [
            "Create an SCP that denies ec2:CreateVolume and rds:CreateDBInstance unless the KMS key ARN matches a specific customer-managed key pattern",
            "Use AWS Config rules that detect unencrypted or AWS-managed-key-encrypted resources and automatically remediate by re-encrypting",
            "Enable default encryption for EBS and RDS in each account, specifying the customer-managed KMS key",
            "Implement AWS Control Tower detective guardrails that alert when resources aren't encrypted with CMKs"
          ],
          "correctAnswer": 0,
          "explanation": "An SCP with a deny statement is the most effective preventive control. The SCP can deny CreateVolume and CreateDBInstance unless the request includes encryption with a customer-managed KMS key. Example condition: 'StringNotEquals': {'ec2:KmsKeyId': 'arn:aws:kms:*:*:key/*'} combined with denying unencrypted volumes. Since September 2025, SCPs support full IAM policy language including conditions and individual resource ARNs, making this highly granular control possible. Option B is detective (detects after creation) not preventive, and re-encrypting RDS requires recreation. Option C sets defaults but doesn't ENFORCE - users can still override. Option D is purely detective/alerting, not enforcement. The key principle: preventive controls (SCPs) are superior to detective controls (Config, Control Tower detective guardrails) for security requirements that must never be violated."
        },
        {
          "question": "A development team uses AWS Certificate Manager (ACM) to manage SSL/TLS certificates. They need some certificates to be exportable for use on on-premises servers, while others remain non-exportable for AWS services. What approach should they use?",
          "options": [
            "Use ACM for all certificates; certificates generated by ACM are exportable by default",
            "Use ACM Private CA for exportable certificates and ACM for non-exportable certificates",
            "Import externally generated certificates into ACM for exportable certificates, use ACM-generated certificates for non-exportable ones",
            "ACM certificates cannot be exported; use AWS Systems Manager Parameter Store for exportable certificate storage"
          ],
          "correctAnswer": 1,
          "explanation": "ACM-generated certificates are not exportable and can only be used with integrated AWS services (ELB, CloudFront, API Gateway). For exportable certificates, you must use ACM Private CA, which issues certificates that can be exported and used anywhere, including on-premises. Option A is incorrect - ACM certificates are NOT exportable. Option C is partially correct (imported certificates can be exported) but creates operational complexity managing external CAs. Option D misunderstands the requirement - Parameter Store is for storing secrets, not for certificate issuance. The distinction is critical: ACM (free) provides certificates locked to AWS services for security; ACM Private CA (paid) provides a private CA that can issue exportable certificates. For a hybrid environment, you'd use both: ACM Private CA for on-premises needs and regular ACM for AWS service integrations."
        },
        {
          "question": "A company implements permission boundaries for all IAM roles created by developers. The permission boundary allows only S3 and DynamoDB actions. A developer creates a role with a policy allowing S3, DynamoDB, and EC2 actions, then tries to launch an EC2 instance using this role. What happens?",
          "options": [
            "The EC2 instance launches successfully because the IAM policy explicitly allows EC2 actions",
            "The EC2 instance launch fails because permission boundaries set the maximum permissions, and EC2 actions are not included in the boundary",
            "The EC2 instance launches but the role cannot perform any actions because permission boundaries override IAM policies completely",
            "The permission boundary is ignored because IAM policies take precedence over boundaries"
          ],
          "correctAnswer": 1,
          "explanation": "Permission boundaries set the maximum permissions that an IAM entity can have. The effective permissions are the intersection of the identity-based policy and the permission boundary. In this case: IAM policy allows S3, DynamoDB, and EC2. Permission boundary allows only S3 and DynamoDB. Effective permissions = intersection = S3 and DynamoDB only. The role can be used to launch an EC2 instance (if the developer has permission to launch instances), but when the instance tries to perform EC2 API actions using this role, those actions will be denied because EC2 actions are not in the intersection. Option A is incorrect - the IAM policy alone doesn't determine permissions. Option C is incorrect - boundaries don't override policies; they intersect with them. Option D is wrong - boundaries are always enforced when present. Permission boundaries are powerful for delegating user/role creation while maintaining security - developers can create roles but cannot grant permissions beyond the boundary."
        },
        {
          "question": "An organization wants to automatically detect when an IAM policy change grants more permissive access than the previous version, preventing accidental privilege escalation. Which AWS service and feature should they use?",
          "options": [
            "AWS Config with managed rule 'iam-policy-no-statements-with-admin-access'",
            "IAM Access Analyzer custom policy checks using the 'Check for new access' feature",
            "AWS CloudTrail Insights to detect unusual IAM API activity patterns",
            "AWS Security Hub with CIS AWS Foundations Benchmark controls"
          ],
          "correctAnswer": 1,
          "explanation": "IAM Access Analyzer custom policy checks with the 'Check for new access' feature is specifically designed for this use case. It uses automated reasoning (provable security based on mathematical logic) to determine whether an updated policy grants new access compared to the existing version. This provides comprehensive findings about what new permissions the updated policy grants. You can integrate this into CI/CD pipelines to prevent deploying more permissive policies. Option A (Config rule) only checks if policies grant admin access, not whether they're more permissive than before. Option C (CloudTrail Insights) detects unusual API activity, not policy permission changes. Option D (Security Hub/CIS) provides security best practice compliance checks but doesn't compare policy versions for new access. The key differentiator: Access Analyzer uses provable security to mathematically prove what access a policy grants, making the comparison definitive, not heuristic-based."
        }
      ]
    },
    {
      "filename": "domain-1-task-1.3-reliable-resilient.json",
      "domain": "Domain 1: Organizational Complexity",
      "task": "Task 1.3: Reliable and Resilient Architectures",
      "question_count": 10,
      "questions": [
        {
          "question": "A global gaming company needs to route UDP traffic for their multiplayer game servers to the optimal AWS region with sub-second failover capabilities. They require static IP addresses for allowlisting by enterprise customers. Players are distributed worldwide. Which solution meets these requirements?",
          "options": [
            "Amazon CloudFront with custom origins pointing to game servers in multiple regions",
            "AWS Global Accelerator with endpoints in multiple regions and health checks configured",
            "Application Load Balancer with cross-zone load balancing in multiple regions",
            "Route 53 latency-based routing with health checks to game server endpoints"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Global Accelerator is the correct choice for this scenario. It provides: (1) Support for non-HTTP protocols including UDP (required for gaming), (2) Two static anycast IP addresses that don't change, making them ideal for allowlisting, (3) Sub-30-second failover to healthy endpoints when health checks fail, (4) Routing through AWS's private global network for lower latency and better performance. CloudFront (Option A) is for HTTP/HTTPS only and caches content - not suitable for real-time game traffic. ALB (Option C) is regional and only supports HTTP/HTTPS/gRPC. Route 53 (Option D) can route UDP but doesn't provide static IPs (DNS returns different IPs) and failover is slower (depends on DNS TTL). Global Accelerator continually monitors endpoint health and redirects traffic to healthy endpoints in less than 30 seconds, making it ideal for high-availability gaming workloads."
        },
        {
          "question": "An e-commerce company operates in US, EU, and Asia regions using Aurora PostgreSQL. They need an RPO of 1 second and RTO of under 5 minutes for regional failures. The application must automatically failover to the nearest healthy region. However, during planned maintenance, they need zero data loss. Which Aurora deployment strategy meets ALL requirements?",
          "options": [
            "Aurora Multi-AZ deployment in each region with Route 53 health checks for cross-region failover",
            "Aurora Global Database with managed planned switchover for maintenance and manual failover for disasters",
            "Aurora Multi-AZ with read replicas promoted manually during regional failures",
            "Aurora Global Database with automated cross-region failover using Route 53 Application Recovery Controller"
          ],
          "correctAnswer": 1,
          "explanation": "Aurora Global Database with both managed planned switchover and manual failover capabilities is the correct answer. Aurora Global Database provides: (1) RPO of ~1 second for unplanned outages (replication lag typically < 1 second), (2) RTO of approximately 1-5 minutes for manual cross-region failover, (3) Most importantly, managed planned switchover provides RPO of 0 (zero data loss) for planned maintenance by synchronizing secondary DB clusters with the primary before failover. Option A (Multi-AZ) only protects against AZ failures, not regional failures. Option C doesn't meet the RPO requirement and requires significant manual effort. Option D doesn't exist - Aurora Global Database doesn't have automated cross-region failover; failover must be manually initiated (though Route 53 ARC can help orchestrate it). The key insight: the question requires BOTH low RPO/RTO for disasters AND zero data loss for planned maintenance - only Aurora Global Database's managed switchover provides RPO=0 for planned events."
        },
        {
          "question": "A financial services company requires cross-region replication for their DynamoDB application with an RPO of 0 (zero data loss) and the ability to read the most recent data from any region after a write. As of 2025, which DynamoDB configuration supports these requirements?",
          "options": [
            "DynamoDB Global Tables with Multi-Region Eventual Consistency (MREC) and strongly consistent reads",
            "DynamoDB Global Tables with Multi-Region Strong Consistency (MRSC) deployed across exactly 3 regions",
            "DynamoDB with DynamoDB Streams and Lambda for custom cross-region replication",
            "DynamoDB Global Tables cannot achieve RPO of 0; the minimum RPO is 1 second with eventual consistency"
          ],
          "correctAnswer": 1,
          "explanation": "As of June 2025, DynamoDB Global Tables supports Multi-Region Strong Consistency (MRSC), which provides: (1) RPO of zero - writes are synchronously replicated to at least one other region before returning success, (2) Strongly consistent reads always return the latest version from any replica. However, MRSC has specific constraints: must be deployed in exactly 3 regions, does not support transaction APIs, and has higher latencies for writes and strongly consistent reads. Option A is incorrect - MREC (default mode) provides asynchronous replication with sub-second RPO but not zero RPO. Option C (custom replication) is overly complex and difficult to achieve true zero RPO. Option D was true before June 2025 but is now incorrect with the introduction of MRSC. Important: You cannot change a global table's consistency mode after creation, so this must be chosen at table creation time."
        },
        {
          "question": "A media streaming company uses S3 Cross-Region Replication (CRR) for disaster recovery. They need to ensure that metadata changes and deletions are replicated, and they want to replicate existing objects that were present before CRR was enabled. What configuration is required? (Select TWO)",
          "options": [
            "Enable Delete Marker Replication in the CRR configuration",
            "Enable S3 Versioning on both source and destination buckets",
            "Use S3 Batch Replication to replicate existing objects",
            "Enable S3 Lifecycle policies to move objects to the destination bucket",
            "Configure S3 Event Notifications to trigger Lambda for object replication",
            "Enable S3 Inventory for tracking replicated objects"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2
          ],
          "explanation": "The required configurations are: (1) S3 Versioning must be enabled on both source and destination buckets - this is a prerequisite for CRR, and (2) S3 Batch Replication is needed to replicate existing objects because CRR only replicates new objects uploaded after CRR is enabled. For delete markers, you'd also enable Delete Marker Replication (Option A), but the question specifically asks about metadata and existing objects. Option D (Lifecycle policies) doesn't replicate objects; it transitions or expires them. Option E (custom Lambda replication) is unnecessary complexity when CRR is available. Option F (S3 Inventory) is for reporting, not replication. Key points: CRR requires versioning, only replicates NEW objects by default (objects uploaded after enabling CRR), and S3 Batch Replication is the AWS-native solution for replicating existing objects. Note: S3 Replication Time Control (RTC) can provide SLA of 99.99% for replication within 15 minutes."
        },
        {
          "question": "An enterprise is implementing chaos engineering using AWS Fault Injection Simulator (FIS) to test their multi-AZ RDS deployment resilience. They want to simulate an AZ failure but prevent any real impact to production databases. What is the SAFEST approach?",
          "options": [
            "Run FIS experiments directly in production during low-traffic hours with rollback actions configured",
            "Create a production-like staging environment with identical architecture and run FIS experiments there first",
            "Use FIS stop conditions with CloudWatch Alarms to automatically stop the experiment if RTO exceeds 5 minutes",
            "Enable RDS automated backups before running FIS experiments in production"
          ],
          "correctAnswer": 2,
          "explanation": "Using FIS stop conditions with CloudWatch Alarms is the safest approach for production chaos engineering. Stop conditions continuously monitor specified CloudWatch Alarms during the experiment and automatically stop the experiment if the alarm breaches, preventing cascading failures or extended outages. You might configure alarms for: database connection errors exceeding threshold, query latency exceeding SLA, or CPU reaching critical levels. This allows you to safely test in production while having guardrails. Option A (running without stop conditions) risks real production impact. Option B (staging only) is safer but doesn't validate real production behavior, including actual traffic patterns, data volumes, and dependencies. Option D (backups) provides recovery but doesn't prevent the outage. The key principle: chaos engineering in production requires automated stop conditions to limit blast radius. FIS integrates with CloudWatch Alarms, AWS CloudWatch Evidently, and other monitoring tools for this purpose."
        },
        {
          "question": "A SaaS company needs to implement disaster recovery for their application spanning multiple AWS services: EC2 instances, RDS databases, DynamoDB tables, and S3 buckets. They need point-in-time recovery within the last 35 days with automated backup policies. Which AWS service should they use for centralized backup management?",
          "options": [
            "AWS Backup with backup plans defining retention policies and schedules for all supported resources",
            "AWS CloudFormation with backup and restore scripts in Lambda functions",
            "Native service-specific backups (RDS snapshots, DynamoDB backups, S3 versioning) managed separately",
            "AWS Systems Manager Automation Documents to orchestrate backups across services"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Backup is the purpose-built, centralized backup service that supports EC2, EBS, RDS, DynamoDB, EFS, S3, and many other services. Key benefits: (1) Centralized backup policies and scheduling, (2) Cross-region backup copy for disaster recovery, (3) Point-in-time recovery support for supported services, (4) Compliance reporting and backup lifecycle management, (5) Tag-based backup policies allowing automatic backup of resources based on tags. For 35-day retention, you'd create a backup plan with appropriate retention rules. Option B (CloudFormation with Lambda) is overly complex and you'd be building what AWS Backup already provides. Option C (native backups) works but lacks centralized management, cross-service consistency, and unified compliance reporting. Option D (Systems Manager) can orchestrate tasks but isn't designed for comprehensive backup management. AWS Backup also supports AWS Organizations integration, allowing centralized backup policies across accounts."
        },
        {
          "question": "A video processing company uses Route 53 for DNS with health checks on their application endpoints in three regions: us-east-1, eu-west-1, and ap-southeast-1. They want traffic to go to the geographically nearest healthy region, but if all regions fail, they want to serve a static maintenance page from S3. How should they configure this?",
          "options": [
            "Use Route 53 geolocation routing with health checks, and configure evaluate target health on each record set",
            "Use Route 53 latency-based routing with health checks on application endpoints, and create a failover record pointing to S3 as secondary",
            "Configure Route 53 geoproximity routing with health checks and bias settings for each region",
            "Use Route 53 multivalue answer routing returning all healthy endpoints and letting the client choose"
          ],
          "correctAnswer": 1,
          "explanation": "The correct configuration is latency-based routing with a failover record as backup. Here's how: Create latency-based routing records for each region's endpoint with health checks. Then create a Route 53 failover routing policy as the parent, with the latency-based records as PRIMARY and an S3 static website as SECONDARY. When all health checks fail, Route 53 automatically fails over to the S3 maintenance page. Option A (geolocation) routes based on user geographic location but not network latency, which can be suboptimal. Option C (geoproximity) requires manual bias configuration and doesn't inherently route to the lowest latency endpoint. Option D (multivalue) returns multiple IP addresses but leaves the client to choose, not providing true failover to S3. The key: combining routing policies (latency for performance + failover for disaster scenario) provides both optimal performance and graceful degradation."
        },
        {
          "question": "A global financial application requires active-active deployment across two regions with automatic synchronization of user sessions. The application uses Application Load Balancer, ECS Fargate containers, and needs session persistence. Which architecture provides BOTH active-active capability AND session persistence?",
          "options": [
            "Use ALB sticky sessions with DynamoDB Global Tables (MREC) for session storage, replicated across both regions",
            "Store sessions in ElastiCache Redis with Redis Global Datastore for cross-region replication",
            "Use ALB sticky sessions at the cookie level; sessions remain in the region where they originated",
            "Store sessions in Aurora Global Database with write forwarding enabled from both regions"
          ],
          "correctAnswer": 1,
          "explanation": "ElastiCache for Redis with Redis Global Datastore is the optimal solution for active-active session management. Redis Global Datastore provides: (1) Cross-region replication with sub-second replication latency, (2) Active-active topology where both regions can serve reads and writes, (3) Automatic failover and promotion, (4) Low-latency session access from containers in both regions. Users can be served from either region and their sessions remain available. Option A (DynamoDB Global Tables) works but has higher latency than ElastiCache for session access. Option C (ALB sticky sessions alone) doesn't sync sessions across regions - if a region fails, users lose sessions. Option D (Aurora with write forwarding) works but is overengineered for session storage and has higher latency than in-memory Redis. For active-active deployments, sessions must be replicated in near-real-time, making Redis Global Datastore ideal with its sub-second replication and in-memory performance."
        },
        {
          "question": "An IoT company processes sensor data through Amazon Kinesis Data Streams, which feeds into multiple Lambda functions for processing. They need to ensure that if Lambda processing fails, data is not lost and can be reprocessed. What configuration ensures maximum reliability?",
          "options": [
            "Increase Kinesis stream retention period to 365 days and configure Lambda retry attempts to 0",
            "Configure Lambda with an on-failure destination pointing to an SQS Dead Letter Queue (DLQ), and set maximum retry attempts to 2",
            "Enable Kinesis Data Streams Enhanced Fan-Out and configure Lambda event source mapping with bisect on function error and maximum record age",
            "Use Kinesis Data Firehose instead of Lambda for processing to ensure reliable delivery"
          ],
          "correctAnswer": 2,
          "explanation": "The correct configuration uses Lambda event source mapping advanced features: (1) Bisect on function error - when Lambda fails to process a batch, Kinesis splits the batch in half and retries each half separately, isolating the problematic record(s), (2) Maximum record age - prevents repeatedly processing very old records that might be causing issues, (3) Enhanced Fan-Out - provides dedicated throughput for each consumer, preventing slow processing from affecting others. Additionally, you should configure on-failure destination to capture records that exceed retry attempts. Option A with 0 retries means failures immediately lose data. Option B's configuration is incomplete without bisect batch on error for stream-based sources. Option D (Kinesis Firehose) is for delivery to destinations like S3/Redshift, not custom Lambda processing. The key: stream-based event sources (Kinesis, DynamoDB Streams) have different failure handling than queue-based sources; bisect on error is critical for isolating bad records while continuing to process good ones."
        },
        {
          "question": "A company wants to implement automated DR testing for their multi-tier application without impacting production. They use Infrastructure as Code (CloudFormation) and want to validate that they can recover from region failure within their 4-hour RTO. What is the MOST effective testing strategy?",
          "options": [
            "Manually promote RDS read replicas and fail over to the DR region once per quarter",
            "Use AWS Backup to restore resources in the DR region and test application functionality, then delete the DR resources",
            "Implement continuous DR environment in the DR region, periodically swap production traffic using Route 53 weighted routing (20% DR, 80% primary) for validation",
            "Create a scheduled Systems Manager Automation Document that deploys the full stack in DR region, runs synthetic tests, validates RTO, and tears down resources"
          ],
          "correctAnswer": 3,
          "explanation": "Option D provides true automated DR testing without production impact. Systems Manager Automation can: (1) Deploy the full CloudFormation stack in DR region, (2) Restore latest data from backups or replicas, (3) Execute synthetic transaction tests to validate functionality, (4) Measure and validate that RTO is met, (5) Automatically tear down test resources to minimize cost. This can run on a schedule (monthly/quarterly) ensuring DR readiness. Option A (manual quarterly) doesn't validate RTO effectively and is error-prone. Option B (AWS Backup restore) is partially correct but lacks automation and RTO validation. Option C (continuous DR with traffic splitting) incurs high costs running duplicate infrastructure continuously and risks production impact. The key: DR testing should be automated, scheduled, validate both data and application integrity, measure RTO/RPO, and not impact production. Systems Manager Automation integrated with CloudFormation, AWS Backup, and CloudWatch makes this achievable."
        }
      ]
    },
    {
      "filename": "domain-1-task-1.4-multi-account.json",
      "domain": "Domain 1: Organizational Complexity",
      "task": "Task 1.4: Multi-Account Environment",
      "question_count": 10,
      "questions": [
        {
          "question": "A company has an AWS Organization with 200+ accounts structured in OUs: Production, Development, Sandbox, and Security. They want to deploy AWS Config rules across all accounts to ensure compliance, with the rules automatically deployed to new accounts created in the future. The deployment should happen from a central compliance account. What is the MOST operationally efficient approach?",
          "options": [
            "Create AWS Config rules in each account manually and use AWS Systems Manager to maintain consistency",
            "Use CloudFormation StackSets with service-managed permissions targeting OUs, enable automatic deployments for new accounts",
            "Deploy AWS Config Aggregator in the central account and configure each member account to push data",
            "Use AWS Control Tower guardrails to deploy Config rules across all enrolled accounts"
          ],
          "correctAnswer": 1,
          "explanation": "CloudFormation StackSets with service-managed permissions is the optimal solution. When integrated with AWS Organizations, StackSets: (1) Uses service-managed permissions (no need to create IAM roles manually), (2) Can target entire OUs, deploying to all current accounts in those OUs, (3) Supports automatic deployments - when enabled, new accounts added to targeted OUs automatically receive the stack instances, (4) Centralized management from a single account. The compliance team can create one StackSet containing Config rules and target all OUs. Option A is not scalable for 200+ accounts. Option C (Config Aggregator) aggregates compliance data but doesn't deploy Config rules. Option D (Control Tower) could work if they're using Control Tower, but StackSets provides more flexibility and granular control for this specific use case. StackSets allow parallel deployment control and failure tolerance configuration."
        },
        {
          "question": "An enterprise wants to automate AWS account provisioning for development teams. New accounts should be created with baseline security controls (CloudTrail, GuardDuty, Security Hub), networking (VPC, subnets), and custom applications deployed. The solution should integrate with their existing Terraform workflow. Which approach best meets these requirements?",
          "options": [
            "Use AWS Control Tower Account Factory with Account Factory Customization (AFC) blueprints",
            "Create custom Lambda functions triggered by AWS Service Catalog to provision accounts and resources",
            "Implement AWS Control Tower Account Factory for Terraform (AFT) with account customization pipelines",
            "Use AWS Organizations CreateAccount API with CloudFormation StackSets for resource deployment"
          ],
          "correctAnswer": 2,
          "explanation": "Account Factory for Terraform (AFT) is specifically designed for this use case. AFT: (1) Integrates AWS Control Tower's governance with Terraform workflows, (2) Automates account lifecycle management with Terraform-based customizations, (3) Supports account-specific customizations through Git-based pipelines, (4) Handles baseline Control Tower configurations plus custom resources, (5) Enables teams to use familiar Terraform syntax. AFT creates a pipeline that automatically provisions Control Tower accounts and applies Terraform-defined customizations including VPCs, security controls, and applications. Option A (AFC with CloudFormation) works but doesn't integrate with existing Terraform workflow. Option B (custom Lambda) requires building and maintaining complex orchestration. Option D (Organizations API + StackSets) doesn't provide the integrated account vending and customization pipeline that AFT offers. AFT v1.15.0 (2025) added enhanced configuration options."
        },
        {
          "question": "A company has 500 accounts in AWS Organizations. They need to enforce that all accounts must have CloudTrail logging to a central S3 bucket in the security account, with log file validation enabled. An SCP is in place preventing CloudTrail modification. However, 50 older accounts don't have CloudTrail configured yet. What is the MOST efficient remediation?",
          "options": [
            "Manually create organization trail from the management account, which automatically applies to all accounts",
            "Use CloudFormation StackSets with service-managed permissions to deploy CloudTrail in all accounts, with the SCP ensuring configurations can't be modified",
            "Create an AWS Config rule to detect accounts without CloudTrail and use Systems Manager Automation for remediation",
            "Use AWS Control Tower to enable CloudTrail baseline on all OUs, automatically enrolling accounts"
          ],
          "correctAnswer": 0,
          "explanation": "Creating an organization trail from the management account is the most efficient solution. An organization trail: (1) Automatically applies to all accounts in the organization, including existing and future accounts, (2) Logs all events from all accounts to a centralized S3 bucket, (3) Cannot be disabled or modified by member accounts (automatically enforced, complementing the SCP), (4) Requires only one trail creation operation. This immediately brings all 500 accounts (including the 50 without CloudTrail) into compliance with a single action. Option B (StackSets) would work but requires 500 stack instances when one organization trail suffices. Option C (Config + remediation) is more complex and slower. Option D (Control Tower) requires all accounts to be enrolled in Control Tower, which may not be the case. Important: Organization trails are created in the management account and automatically replicate to all member accounts, making them ideal for centralized compliance requirements."
        },
        {
          "question": "A financial services company has accounts in AWS Organizations with an OU structure: Root → Production OU → AppTeam-A OU. There are SCPs at each level. The Root OU has an SCP allowing all services. Production OU has an SCP denying s3:DeleteBucket. AppTeam-A OU has an SCP allowing only S3 and EC2 services. What are the effective permissions for accounts in AppTeam-A OU?",
          "options": [
            "S3 and EC2 services are allowed because the AppTeam-A SCP explicitly allows them, overriding parent SCPs",
            "S3 (except DeleteBucket) and EC2 services only, as SCPs are inherited and intersected down the OU hierarchy",
            "All services are allowed because the Root SCP allows all services and takes precedence",
            "No services are allowed because the deny in Production OU propagates and blocks all S3 access"
          ],
          "correctAnswer": 1,
          "explanation": "SCPs are inherited and the effective permissions are the intersection (logical AND) of all SCPs from the root to the account. For AppTeam-A accounts: Root SCP allows all services (no restriction). Production OU SCP denies s3:DeleteBucket. AppTeam-A OU SCP allows only S3 and EC2. The intersection is: S3 (minus DeleteBucket) and EC2 only. The AppTeam-A SCP's restriction to S3 and EC2 is the most restrictive, so other services are blocked. Within S3, the Production OU's deny on DeleteBucket further restricts permissions. Important SCP principles: (1) SCPs never grant permissions, they only filter/restrict, (2) Explicit denies cannot be overridden, (3) The most restrictive combination applies, (4) SCPs affect all users and roles in the account, including the root user. Even if an IAM policy grants DynamoDB access, accounts in AppTeam-A cannot use DynamoDB due to the SCP restriction."
        },
        {
          "question": "An organization needs to share a private Application Load Balancer in a central networking account with application accounts. Application teams should be able to register their targets with the ALB but NOT modify the ALB configuration or security groups. Which AWS service enables this capability?",
          "options": [
            "AWS Resource Access Manager (RAM) sharing the ALB with target account",
            "VPC Peering between the networking account and application accounts",
            "AWS PrivateLink to expose the ALB to other accounts",
            "Cross-account IAM roles allowing application accounts to access the ALB"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Resource Access Manager (RAM) supports sharing Application Load Balancers (and Network Load Balancers) across accounts. When you share an ALB: (1) Participant accounts can register their resources (EC2, ECS, Lambda) as targets, (2) The owner account maintains control over ALB configuration, listeners, and security groups, (3) Participants cannot modify ALB settings or delete the ALB. This provides the exact separation of concerns required: central team manages infrastructure (ALB, networking), application teams manage their targets. RAM supports sharing within AWS Organizations or with specific accounts. Option B (VPC Peering) provides network connectivity but doesn't address the permission boundary for ALB management. Option C (PrivateLink) is for exposing services, not for sharing infrastructure resources. Option D (IAM roles) could theoretically work but would require complex policies and doesn't provide the clean separation that RAM offers."
        },
        {
          "question": "A company wants to implement cross-account CloudWatch log aggregation from 100 application accounts to a central logging account for compliance and analysis. The solution should minimize configuration in each application account and automatically include new accounts. What architecture should they implement?",
          "options": [
            "Create CloudWatch log groups in each account with subscription filters sending to Kinesis in the central account",
            "Use CloudFormation StackSets to deploy CloudWatch log groups with cross-account permissions to the central account",
            "Configure CloudWatch Logs cross-account data sharing with a centralized log data account, using CloudFormation StackSets for automation",
            "Use AWS Organizations integration with CloudWatch Logs to automatically stream logs from all accounts to a central destination"
          ],
          "correctAnswer": 2,
          "explanation": "CloudWatch Logs cross-account data sharing allows a centralized logging account to access log data from multiple accounts. The architecture: (1) Create a destination in the central logging account that specifies an access policy allowing source accounts, (2) Use CloudFormation StackSets with service-managed permissions and automatic deployments to create subscription filters in all accounts (current and future), (3) Subscription filters in each account send logs to the central destination (typically Kinesis Data Streams or Kinesis Data Firehose). Option A is partially correct but doesn't mention the automation aspect via StackSets. Option D doesn't exist - Organizations doesn't have native CloudWatch Logs integration like it does for CloudTrail. Option B is incomplete - just creating log groups doesn't aggregate logs. The key is combining: (1) CloudWatch Logs destination with cross-account access policy, (2) StackSets for automated subscription filter deployment, (3) Service-managed permissions and auto-deployment for new accounts."
        },
        {
          "question": "An enterprise has implemented AWS Control Tower with automatic account enrollment enabled on production OUs. When they move an account from Development OU to Production OU, what happens to the account's baseline controls and resources?",
          "options": [
            "Nothing changes; baseline controls remain from the Development OU until manually updated",
            "AWS Control Tower automatically applies the Production OU's enabled baseline resources and controls to the account",
            "The account must be de-enrolled and re-enrolled to receive Production OU controls",
            "CloudFormation StackSets must be manually updated to change the account's baseline"
          ],
          "correctAnswer": 1,
          "explanation": "As of 2025, AWS Control Tower supports automatic account enrollment and baseline updates when accounts move between OUs. When you move an account to a new OU: (1) Control Tower automatically applies the destination OU's enabled baseline resources and controls, (2) Removes or updates controls that differ from the previous OU, (3) This happens automatically without manual intervention. This feature significantly improves operational efficiency for large organizations reorganizing their account structure. Option A describes pre-2025 behavior. Option C was required in older versions but is no longer necessary. Option D misunderstands the relationship - Control Tower manages baselines, not StackSets directly (though it may use StackSets internally). Important: This requires that the AWSControlTowerBaseline is enabled on the destination OU, which enables automatic enrollment and baseline management."
        },
        {
          "question": "A company needs to implement consolidated billing with detailed cost allocation across 200 accounts organized by business units (BUs). Each BU has multiple projects. They want to enforce mandatory cost allocation tags and generate monthly cost reports by BU and project. Which implementation provides the MOST comprehensive solution? (Select TWO)",
          "options": [
            "Enable AWS Organizations consolidated billing and create a cost allocation tag policy requiring 'BusinessUnit' and 'Project' tags",
            "Activate cost allocation tags in the management account and ensure they're activated in all member accounts",
            "Use CloudFormation StackSets to deploy AWS Budgets in each account with alerts for cost overruns",
            "Create AWS Cost and Usage Reports (CUR) with hourly granularity and deliver to S3 with cost allocation tags",
            "Implement SCPs denying resource creation without required cost allocation tags",
            "Use AWS Cost Explorer with saved reports filtered by cost allocation tags"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            3
          ],
          "explanation": "The comprehensive solution requires: (1) Tag policy in AWS Organizations to enforce mandatory tags - tag policies define required tags and allowed values across the organization. When applied, resources must have specified tags (BusinessUnit, Project) to be compliant. (2) Cost and Usage Reports (CUR) with cost allocation tags provides detailed billing data with tags for analysis. CUR can be ingested into Athena, QuickSight, or third-party tools for sophisticated cost reporting by BU and project. Option B (activating tags) is a prerequisite but insufficient alone - doesn't enforce tagging. Option C (Budgets) helps with cost control but doesn't solve cost allocation reporting. Option E (SCP to enforce tags) sounds good but SCPs cannot currently enforce tagging at resource creation (they can deny if conditions aren't met, but tag policies are the proper mechanism for tag governance). Option F (Cost Explorer) is useful for visualization but doesn't provide the enforcement or detailed reporting that tag policies + CUR provide."
        },
        {
          "question": "A security team needs to create a cross-account CI/CD pipeline where CodePipeline in Account A deploys to Account B. The pipeline includes CodeBuild, CodeDeploy, and deployment to S3 and ECS in Account B. What is the MINIMUM set of cross-account configurations required?",
          "options": [
            "Create an IAM role in Account B that CodePipeline can assume, granting permissions to S3, ECS, and CodeDeploy",
            "Configure S3 bucket policy in Account B allowing Account A access, create IAM role in Account B for CodePipeline with S3, ECS, and CodeDeploy permissions, and configure KMS key policy for cross-account encryption if using encrypted artifacts",
            "Use AWS Organizations to enable cross-account service access between accounts",
            "Create identical IAM users in both accounts with same access keys for authentication"
          ],
          "correctAnswer": 1,
          "explanation": "Cross-account CI/CD requires multiple components: (1) S3 bucket policy in Account B allowing Account A to access artifact buckets (CodePipeline stores artifacts in S3), (2) IAM role in Account B with trust policy allowing Account A's CodePipeline to assume it, with permissions for S3, ECS, and CodeDeploy operations, (3) If using encryption (common practice), KMS key policy in Account B allowing Account A to decrypt/encrypt with the key used for artifacts. Additionally, the CodePipeline service role in Account A needs permission to assume the role in Account B. Option A is incomplete - missing S3 bucket policy and KMS configuration. Option C (Organizations integration) doesn't automatically configure the specific permissions needed. Option D (shared IAM users) violates AWS best practices - never share credentials; use role assumption. The KMS component is frequently overlooked but critical - encrypted S3 artifacts require cross-account KMS key permissions, otherwise pipeline fails during artifact handling."
        },
        {
          "question": "An organization wants to use AWS Organizations to manage 500+ accounts but is concerned about the impact of a compromised management account. Which security best practices should they implement to minimize risk? (Select THREE)",
          "options": [
            "Enable MFA delete on the S3 bucket storing CloudTrail logs from the management account",
            "Delegate administrative capabilities to member accounts using delegated administrator feature for Security Hub, GuardDuty, and other services",
            "Limit access to the management account to only a few administrators with strong MFA requirements",
            "Store all application workloads in the management account since it has the highest privileges",
            "Implement SCPs that prevent the management account from accessing member account resources",
            "Never use the management account for workloads; use it only for organization management and billing"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2,
            5
          ],
          "explanation": "Management account security best practices include: (1) Delegate administrative functions - AWS allows delegating administrator privileges for services like Security Hub, GuardDuty, CloudFormation StackSets, reducing the need to access the management account, (2) Strictly limit access - only essential personnel should have management account access, with strong MFA and potentially hardware MFA devices, (3) Never run workloads in management account - it should be used exclusively for organizational management, billing, and security functions. Workloads increase attack surface. Option A (MFA delete on S3) is a good practice but not specific to management account protection. Option D directly violates best practices. Option E is incorrect - SCPs don't apply to the management account itself; the management account is exempt from SCPs, which is why protecting it is critical. Additional practices: use AWS Control Tower for guardrails, implement break-glass procedures, monitor with CloudTrail, and use separate accounts for different administrative functions."
        }
      ]
    },
    {
      "filename": "domain-1-task-1.5-cost-optimization.json",
      "domain": "Domain 1: Organizational Complexity",
      "task": "Task 1.5: Cost Optimization and Visibility",
      "question_count": 8,
      "questions": [
        {
          "question": "A company has variable compute workloads that run on a mix of EC2 instance families (c5, m5, r5) across multiple regions and also uses AWS Fargate and Lambda. They want to commit to steady-state usage to reduce costs but need maximum flexibility as their architecture evolves. They currently spend $100/hour on compute. Which commitment strategy provides the BEST balance of savings and flexibility for 2025?",
          "options": [
            "Purchase Standard Reserved Instances for the most-used instance type in each region (72% discount)",
            "Purchase Compute Savings Plans with a $70/hour commitment (up to 66% discount with full flexibility)",
            "Purchase EC2 Instance Savings Plans for each instance family separately",
            "Purchase Convertible Reserved Instances to allow instance type changes"
          ],
          "correctAnswer": 1,
          "explanation": "Compute Savings Plans is the optimal choice for 2025. It provides: (1) Up to 66% discount (comparable to Convertible RIs), (2) Flexibility across instance families, sizes, operating systems, and regions, (3) Coverage for EC2, Fargate, and Lambda without separate commitments, (4) Automatic discount application as workloads shift between services. With $100/hour spend, a $70/hour commitment covers steady-state usage while maintaining flexibility for the remaining $30/hour. Option A (Standard RIs) provides slightly higher discount (72% vs 66%) but locks to specific instance types/regions - risky given their evolving architecture and only ~3% additional savings. Option C (EC2 Instance Savings Plans) provides more savings than Compute but less flexibility - requires separate commitments per family. Option D (Convertible RIs) offers flexibility but is legacy; AWS recommends Savings Plans. 2025 guidance: Savings Plans for almost all scenarios due to flexibility and automatic application across services."
        },
        {
          "question": "A financial services company with 200 AWS accounts needs to implement cost allocation and chargeback to business units. Each business unit has multiple projects and environments (dev, staging, prod). They want to enforce tagging compliance and generate monthly cost reports by business unit and project. Which combination of services and configurations is MOST effective? (Select THREE)",
          "options": [
            "Create and activate cost allocation tags for 'BusinessUnit', 'Project', and 'Environment' in the management account",
            "Implement AWS Organizations tag policies requiring mandatory tags on all resources",
            "Enable AWS Cost and Usage Reports (CUR) with resource-level granularity and deliver to S3 for analysis",
            "Use AWS Budgets to enforce spending limits per business unit",
            "Deploy AWS Cost Categories to group costs by business unit and project combinations",
            "Use AWS Cost Explorer saved reports filtered by cost allocation tags"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2,
            4
          ],
          "explanation": "The comprehensive solution requires: (1) Tag policies in AWS Organizations enforce mandatory tags organization-wide, ensuring compliance by preventing non-compliant resource creation or flagging violations, (2) CUR provides detailed cost data with resource-level tags that can be analyzed using Athena/QuickSight for detailed chargeback reports, (3) Cost Categories allow grouping costs into logical categories based on tag combinations (e.g., 'BU-Engineering-Production'), simplifying reporting and budgeting. Option A (activating tags) is necessary but doesn't enforce compliance. Option D (Budgets) helps control costs but doesn't solve allocation/reporting. Option F (Cost Explorer) is useful but doesn't provide the detailed, automated reporting that CUR + Cost Categories + tag policies provide. Best practice: Tag policies (enforcement) + Cost Categories (grouping) + CUR (detailed reporting) creates a comprehensive cost allocation system. Cost Categories can use rules like: IF tag:BusinessUnit = 'Engineering' AND tag:Project = 'DataPlatform' THEN 'Engineering-DataPlatform'."
        },
        {
          "question": "A company analyzes their AWS Cost and Usage Report and discovers they're spending $50,000/month on data transfer charges. After investigation, they find: 40% is cross-AZ data transfer within the same region, 35% is cross-region replication, and 25% is data transfer to the internet. Which optimization strategy would provide the GREATEST cost reduction?",
          "options": [
            "Implement VPC endpoints for AWS services to eliminate data transfer charges",
            "Redesign the architecture to minimize cross-AZ traffic by placing interdependent services in the same AZ with proper backup strategies",
            "Use CloudFront for content delivery to reduce data transfer to internet charges",
            "Consolidate all workloads in a single region to eliminate cross-region transfer costs"
          ],
          "correctAnswer": 1,
          "explanation": "Minimizing cross-AZ traffic addresses the largest cost component (40% = $20,000/month). AWS charges for data transferred between AZs (typically $0.01/GB each direction). Strategies: (1) Place tightly coupled services in the same AZ, (2) Use VPC endpoints to avoid cross-AZ traffic for AWS service calls, (3) Implement caching to reduce database queries across AZs. However, maintain Multi-AZ for stateful services (RDS, etc.) for resilience. Option C (CloudFront) only addresses 25% of costs and may not be applicable to all workloads. Option D (single region) reduces 35% but eliminates disaster recovery capabilities - unacceptable for most enterprises. Option A (VPC endpoints) helps but typically has smaller impact than architectural redesign. Important: Cross-AZ data transfer within a region is often overlooked but accumulates significantly in high-throughput applications. Balance cost optimization with resilience requirements."
        },
        {
          "question": "An organization enabled AWS Cost Anomaly Detection in July 2025 with the latest model enhancements. They receive anomaly alerts for a $5,000 spike in EC2 costs, but investigation shows this is due to their planned quarterly load testing that occurs every 3 months. How should they configure Cost Anomaly Detection to reduce false positives for known recurring events?",
          "options": [
            "Disable Cost Anomaly Detection during planned load testing periods",
            "Rely on the ML model's automatic learning - the 2025 enhancements distinguish between one-time and recurrent cost events over time",
            "Create separate monitors with higher alert thresholds for services used in load testing",
            "Configure suppression rules in the AWS User Notifications integration to filter alerts during testing windows"
          ],
          "correctAnswer": 1,
          "explanation": "The July 2025 AWS Cost Anomaly Detection model enhancements specifically address this scenario. The improved ML model: (1) Better understands organization's typical spend patterns, (2) Distinguishes between one-time and recurrent cost events, (3) Maintains accuracy in detecting cost changes that require attention. After several occurrences, the model should learn the quarterly pattern and reduce false positives. However, for immediate optimization, Option D (suppression rules via AWS User Notifications, introduced May 2025) provides a complementary approach. Option A (disabling) removes protection during testing. Option C (higher thresholds) reduces sensitivity for all spikes, not just planned ones. Best practice: Let the ML model learn patterns while using AWS User Notifications for advanced filtering. The integration with AWS User Notifications (available since May 2025) enables sophisticated alert management with verified contact management and reusable alert configurations."
        },
        {
          "question": "A media company has 500 TB of data in S3 Standard storage. Analysis shows: 60% of data is accessed frequently in the first 30 days, then rarely accessed. 30% has unpredictable access patterns. 10% is archival data not accessed for 90+ days. Which S3 storage optimization strategy minimizes costs while maintaining access requirements?",
          "options": [
            "Move all data to S3 Glacier Flexible Retrieval after 30 days to minimize storage costs",
            "Use S3 Lifecycle policies: transition to S3 Standard-IA after 30 days, then to S3 Glacier Flexible Retrieval after 90 days",
            "Enable S3 Intelligent-Tiering for the entire dataset to automatically optimize storage classes based on access patterns",
            "Use S3 Lifecycle policy for the 60% (Standard → Standard-IA after 30 days), S3 Intelligent-Tiering for the 30% with unpredictable patterns, and move 10% archival to Glacier Deep Archive"
          ],
          "correctAnswer": 3,
          "explanation": "The optimal strategy uses different approaches for different access patterns: (1) For the 60% with predictable patterns, use Lifecycle policies (Standard → Standard-IA after 30 days) - this is cost-effective for known patterns, (2) For the 30% with unpredictable access, S3 Intelligent-Tiering automatically moves data between tiers based on actual usage without retrieval fees, preventing costly Glacier retrievals for occasionally accessed data, (3) For 10% archival, Glacier Deep Archive offers lowest storage cost ($0.00099/GB vs $0.004/GB for Glacier Flexible). Option A over-archives data, causing expensive retrieval fees for the 30% with unpredictable access. Option B uses one-size-fits-all approach, suboptimal for varied patterns. Option C (all Intelligent-Tiering) incurs monitoring fees ($0.0025/1000 objects) unnecessarily for predictable patterns. Key insight: S3 Intelligent-Tiering is ideal for unpredictable access patterns (no retrieval fees between frequent/infrequent tiers), while Lifecycle policies are more cost-effective for predictable patterns."
        },
        {
          "question": "An enterprise wants to optimize EC2 costs and receives AWS Compute Optimizer recommendations suggesting: downsize 30% of instances (oversized), change instance families for 40% (better price-performance), and no changes for 30%. However, the application teams are hesitant due to concerns about performance impact. What is the BEST approach to safely implement these recommendations?",
          "options": [
            "Implement all Compute Optimizer recommendations immediately during a maintenance window to maximize savings",
            "Start with instances in development/staging environments, validate performance, then gradually roll out to production with monitoring",
            "Only implement the downsizing recommendations (30%) and ignore the instance family changes due to higher risk",
            "Reject all recommendations because application teams understand their workloads better than automated tools"
          ],
          "correctAnswer": 1,
          "explanation": "The safe, phased approach is: (1) Test in lower environments first (dev/staging) to validate Compute Optimizer recommendations without production risk, (2) Monitor performance metrics (CPU, memory, disk, network) to confirm the changes don't degrade performance, (3) Gradually roll out to production, starting with less critical workloads, (4) Implement CloudWatch alarms and dashboards to detect issues early. Compute Optimizer uses ML analysis of actual utilization metrics (CloudWatch data) and can identify optimization opportunities, but validation is prudent. Option A (immediate implementation) risks production outages if recommendations don't account for periodic load spikes or application-specific behaviors. Option C ignores potentially significant savings from family changes. Option D wastes optimization opportunities - Compute Optimizer analyzes actual metrics over 14+ days, often identifying waste humans miss. Best practice: Compute Optimizer provides data-driven recommendations, but implement with testing, monitoring, and gradual rollout for production safety."
        },
        {
          "question": "A company using AWS Organizations wants to implement Reserved Instance (RI) and Savings Plan sharing across accounts to maximize utilization. They have production accounts (high priority) and development accounts (low priority). How should they configure sharing to ensure production workloads receive commitment benefits first?",
          "options": [
            "Purchase all RIs and Savings Plans in the management account; AWS automatically prioritizes based on account creation order",
            "Disable RI/Savings Plan sharing and purchase separately in each account to ensure allocation",
            "Enable RI/Savings Plan sharing (default for Organizations); AWS automatically shares across the organization with the purchasing account having first priority",
            "RI/Savings Plan sharing cannot be controlled by priority; they distribute equally across all accounts"
          ],
          "correctAnswer": 2,
          "explanation": "RI and Savings Plan sharing in AWS Organizations works as follows: (1) When sharing is enabled (default), discounts are first applied to the purchasing account, (2) Remaining unused discounts automatically share to other accounts in the organization, (3) Sharing can be disabled if complete isolation is needed, but this reduces utilization efficiency. For the scenario: purchasing RIs/Savings Plans in production accounts ensures production gets first priority for those commitments. Remaining unused discounts (e.g., during low production load) automatically benefit development accounts, maximizing utilization. Option A is incorrect - there's no automatic prioritization by account creation order. Option B (disabling sharing) prevents efficient utilization of unused commitments. Option D is wrong - the purchasing account always has first priority. Best practice: Purchase commitments in high-priority accounts, enable sharing organization-wide to maximize utilization. Advanced: you can disable sharing for specific accounts if strict isolation is required, but this typically reduces overall efficiency and increases costs."
        },
        {
          "question": "A global company analyzes their AWS bill and discovers that 20% of costs are from inter-region data transfer. They use S3 Cross-Region Replication (CRR) for compliance and CloudFront for content delivery with multiple regional origins. Which optimization provides GREATEST data transfer cost reduction while maintaining functionality?",
          "options": [
            "Replace S3 CRR with S3 Same-Region Replication to eliminate cross-region transfer costs",
            "Consolidate CloudFront to use a single origin region and leverage CloudFront's edge locations for global distribution",
            "Enable S3 Transfer Acceleration for cross-region transfers to reduce costs",
            "Use AWS Direct Connect with Direct Connect Gateway to route inter-region traffic through private connectivity"
          ],
          "correctAnswer": 1,
          "explanation": "Consolidating CloudFront to use a single origin region is the optimal cost optimization. Here's why: (1) CloudFront caches content at edge locations worldwide, so most requests are served from edge cache, not the origin, (2) When edge fetch from origin is needed, CloudFront-to-S3 data transfer in the same region is free within AWS, (3) CloudFront origin fetches use AWS's private network efficiently. Multiple regional origins increase cross-region traffic unnecessarily. Option A (SRR) violates the compliance requirement for cross-region replication. Option C (S3 Transfer Acceleration) actually increases costs - it's designed for faster uploads, not cost savings, and adds fees. Option D (Direct Connect) doesn't reduce inter-region data transfer costs; it's for on-premises connectivity. Important: Data transfer FROM CloudFront to users is charged at CloudFront rates (often lower than EC2/S3 rates), and CloudFront-to-S3 in same region is free for origin fetches. Best practice: Use CloudFront with single origin region for cost-effective global distribution."
        }
      ]
    },
    {
      "filename": "domain-2-all-remaining.json",
      "domain": "Domain 2: Design for New Solutions",
      "task": "task_2.2_business_continuity",
      "taskKey": "task_2.2_business_continuity",
      "question_count": 14,
      "questions": [
        {
          "id": "D2-T2.2-Q1",
          "question": "A company needs to migrate a 50TB Oracle database to Amazon Aurora PostgreSQL with minimal downtime (< 1 hour). The database experiences 10,000 transactions per hour. Which migration approach minimizes downtime while ensuring data consistency?",
          "options": [
            "Use AWS DMS with full load followed by CDC (Change Data Capture) for ongoing replication, then cutover during low-traffic window",
            "Export Oracle database to S3, then import into Aurora PostgreSQL using native tools",
            "Use AWS SCT to convert schema, then DMS Serverless for automated capacity scaling during migration",
            "Create Oracle read replica, convert it using AWS SCT, then promote to Aurora PostgreSQL"
          ],
          "correctAnswer": 2,
          "explanation": "For heterogeneous migrations (Oracle to PostgreSQL), AWS recommends a two-step process: (1) AWS SCT (Schema Conversion Tool) to convert schema and code to match Aurora PostgreSQL, (2) AWS DMS for data migration. DMS Serverless (released in 2023, with 2025 enhancements for premigration assessments and automatic storage scaling) automatically provisions, monitors, and scales migration resources to optimal capacity, removing manual instance sizing. For minimal downtime with ongoing transactions: Use DMS full load + CDC to capture changes during migration, then perform cutover. Option C specifying DMS Serverless is optimal as it handles capacity automatically for the 50TB dataset and 10K TPS workload, with April 2025 automatic storage scaling eliminating the previous 100GB limit. Option A is correct approach but doesn't leverage Serverless automation. Option B would require significant downtime. Option D doesn't work - you can't directly convert Oracle replica to PostgreSQL."
        },
        {
          "id": "D2-T2.2-Q2",
          "question": "On October 30, 2025, AWS Backup announced a new capability for database snapshots. A company wants to copy their RDS snapshots from us-east-1 to both eu-west-1 and ap-southeast-1 for disaster recovery. What is the MOST operationally efficient method available as of late 2025?",
          "options": [
            "Create two sequential copy actions: us-east-1 → eu-west-1, then us-east-1 → ap-southeast-1",
            "Use AWS Backup to copy database snapshots to multiple AWS Regions in a single copy action",
            "Use Lambda function triggered by RDS snapshot completion to copy to multiple regions",
            "Create manual snapshots and use AWS CLI to copy to each region sequentially"
          ],
          "correctAnswer": 1,
          "explanation": "In October 2025, AWS Backup added support for copying database snapshots (RDS, Aurora, Neptune, DocumentDB) across AWS Regions and accounts using a single copy action, eliminating the need for sequential copying steps. This significantly simplifies cross-region DR strategies. You can now specify multiple destination regions in a single AWS Backup copy action. Option A describes the old approach (pre-October 2025) requiring sequential operations. Option C adds unnecessary complexity with custom Lambda code. Option D is manual and operationally inefficient. The new capability provides: (1) Single operation for multiple region copies, (2) Automatic re-encryption with destination vault's KMS key, (3) Incremental copies for supported services, (4) Integrated with backup plans for automation."
        },
        {
          "id": "D2-T2.2-Q3",
          "question": "A healthcare company must retain EBS snapshots and RDS backups for 7 years for HIPAA compliance. They want automated lifecycle management and the ability to restore to any point within that period. Which AWS Backup configuration meets these requirements MOST cost-effectively?",
          "options": [
            "Create backup plan with retention of 7 years and lifecycle transition to cold storage after 90 days",
            "Use AWS Backup Vault Lock with compliance mode to enforce 7-year retention with WORM protection",
            "Configure both: backup plan with 7-year retention + lifecycle to cold storage after 90 days + Backup Vault Lock in compliance mode for WORM",
            "Store snapshots in S3 Glacier Deep Archive with lifecycle policy"
          ],
          "correctAnswer": 2,
          "explanation": "For HIPAA compliance with 7-year retention, the comprehensive solution combines: (1) Backup plan with 7-year retention period defining when backups are taken, (2) Lifecycle policy transitioning to cold storage after 90 days for cost optimization (cold storage is up to 90% cheaper), (3) Backup Vault Lock in compliance mode for WORM (Write-Once-Read-Many) protection preventing deletion until retention expires, meeting regulatory requirements. Option A lacks WORM protection required for compliance. Option B provides WORM but doesn't optimize costs with cold storage. Option D doesn't use AWS Backup's centralized management. AWS Backup cold storage supports EBS, EFS, and VMware backups. Important: Vault Lock compliance mode cannot be disabled once enabled - it provides irrevocable protection, which is required for regulatory compliance but should be tested in governance mode first."
        },
        {
          "id": "D2-T2.2-Q4",
          "question": "A company uses S3 Cross-Region Replication (CRR) from us-west-2 to eu-central-1. They enable S3 Replication Time Control (RTC) for compliance SLA. What guarantee does RTC provide?",
          "options": [
            "99.9% of objects replicate within 15 minutes with SLA-backed guarantee, replication metrics, and event notifications",
            "100% of objects replicate within 15 minutes guaranteed",
            "99.99% design target with replication metrics but no formal SLA",
            "Synchronous replication with zero RPO"
          ],
          "correctAnswer": 0,
          "explanation": "S3 Replication Time Control (RTC) is backed by an SLA guaranteeing 99.9% (not 99.99%) of objects replicated within 15 minutes during any billing month. While the design target is 99.99%, the formal SLA commitment is 99.9%. RTC also provides: (1) Replication metrics visible in CloudWatch, (2) Event notifications when objects don't meet the 15-minute SLA, (3) Visibility through S3 console showing missed SLA thresholds. The 15-minute SLA is critical for compliance requirements with specific RPO needs. Option B is incorrect - 100% is impossible to guarantee in distributed systems. Option C describes the design goal but not the SLA commitment. Option D is incorrect - S3 replication is asynchronous, not synchronous; true synchronous replication would severely impact performance. RTC costs more than standard CRR but provides SLA guarantees. Note: The SLA doesn't apply when replication data transfer rate exceeds the default 1 Gbps quota."
        },
        {
          "id": "D2-T2.2-Q5",
          "question": "A financial services application requires RPO of 5 minutes and RTO of 15 minutes for their MySQL database. The database is 2TB with moderate write activity. Which solution meets these requirements MOST cost-effectively?",
          "options": [
            "Aurora MySQL with Aurora Global Database providing ~1 second RPO and <1 minute RTO",
            "RDS MySQL Multi-AZ with automated backups every 5 minutes",
            "RDS MySQL with read replica in another region, promoted manually during failures",
            "Aurora MySQL with cross-region read replica and automated backups every 5 minutes"
          ],
          "correctAnswer": 3,
          "explanation": "Aurora MySQL with cross-region read replica provides: (1) Continuous replication with typical lag of seconds (well within 5-minute RPO), (2) Fast promotion of read replica to standalone cluster (within 15-minute RTO), (3) More cost-effective than Aurora Global Database for this RPO/RTO requirement. Aurora Global Database (Option A) provides superior metrics (~1s RPO, <1min RTO) but costs more due to the globally distributed architecture - overengineered for 5min/15min requirements. Option B is incorrect - RDS automated backups are continuous via transaction logs, not every 5 minutes, and provide point-in-time recovery, but restoring from backup takes longer than 15 minutes for 2TB. Option C (RDS with cross-region replica) works but Aurora provides faster failover. Key decision: Balance requirements vs cost - don't overprovision DR capabilities beyond requirements."
        },
        {
          "id": "D2-T2.2-Q6",
          "question": "A company has encrypted RDS instances in Account A (us-east-1) and needs to create cross-region, cross-account backups to Account B (eu-west-1) for DR. What configuration is required for encrypted backups? (Select THREE)",
          "options": [
            "Share the source KMS key from Account A with Account B",
            "Create a backup vault in Account B (eu-west-1) with its own KMS key",
            "Configure AWS Backup in Account A with a backup plan that copies to Account B's vault",
            "Disable encryption on RDS before creating backups",
            "Use AWS Backup resource-based policy on the destination vault to allow Account A to copy backups",
            "Enable RDS snapshot sharing and manually copy snapshots"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2,
            4
          ],
          "explanation": "Cross-region, cross-account encrypted backup requires: (1) Backup vault in destination account/region (Account B, eu-west-1) with its own KMS key for re-encryption, (2) Backup plan in source account (Account A) configured to copy to the destination vault, (3) Resource-based policy on destination vault allowing source account to copy backups. AWS Backup automatically re-encrypts backups using the destination vault's KMS key, so you don't share the source KMS key (Option A is incorrect). Option D is wrong - you never disable encryption for compliance/security reasons; AWS Backup handles encrypted backups natively. Option F (manual snapshot sharing) works but is not using AWS Backup's automated cross-account copy feature. Important: The destination vault's resource-based policy must grant permissions to the source account, and the source account's IAM role must have permissions to write to the destination vault."
        },
        {
          "id": "D2-T2.2-Q7",
          "question": "An e-commerce company experiences a regional failure in their primary region (us-east-1). They have pilot light DR in us-west-2 with minimal infrastructure running. They need to scale up capacity to handle production traffic. In which order should they execute their DR runbook to minimize RTO?",
          "options": [
            "1) Update DNS 2) Scale up compute 3) Promote database replica 4) Test application",
            "1) Promote database replica 2) Scale up compute 3) Test application 4) Update DNS to route traffic",
            "1) Test application 2) Promote database replica 3) Update DNS 4) Scale up compute",
            "1) Scale up compute 2) Promote database replica 3) Update DNS 4) Test application"
          ],
          "correctAnswer": 1,
          "explanation": "The correct DR execution order minimizes RTO while ensuring system integrity: (1) Promote database replica FIRST - this is typically the longest operation (promoting RDS/Aurora replica) and must complete before application can function, (2) Scale up compute (Auto Scaling group desired capacity, ECS task count) - while database is promoting or immediately after, (3) Test application functionality to verify everything works before customer impact, (4) Update DNS to route traffic only after confirming the DR environment is functional. Option A (DNS first) sends traffic to an environment that's not ready, causing customer impact. Option C (test before database/compute) is impossible - can't test without functional infrastructure. Option D (DNS before testing) risks routing customers to broken environment. Best practice: Automate DR runbook with AWS Systems Manager Automation Documents that execute these steps in order, with validation gates between each step."
        },
        {
          "id": "D2-T2.2-Q8",
          "question": "A company uses DynamoDB with Point-in-Time Recovery (PITR) enabled. They accidentally delete critical data at 2:00 PM. The deletion is discovered at 2:30 PM. What is the BEST recovery approach?",
          "options": [
            "Restore from PITR to 1:59 PM into a new table, then copy the deleted items back to the production table",
            "Contact AWS Support to recover the deleted data",
            "Restore from the most recent on-demand backup",
            "Enable DynamoDB Streams and replay events from 1:59 PM to 2:00 PM"
          ],
          "correctAnswer": 0,
          "explanation": "DynamoDB Point-in-Time Recovery (PITR) allows restoring to any point within the last 35 days with second-level granularity. The recovery approach: (1) Restore table to 1:59 PM (one minute before deletion) into a new table - this creates a new DynamoDB table with data as it existed at that timestamp, (2) Query the new table for deleted items, (3) Copy/write those items back to the production table using BatchWriteItem or DynamoDB import/export. PITR always restores to a NEW table, never in-place. Option B (AWS Support) cannot recover data; PITR is customer-managed. Option C (on-demand backup) works only if you took a backup between 1:59 PM and 2:00 PM, unlikely for a specific minute. Option D misunderstands DynamoDB Streams - Streams capture changes for 24 hours and are for triggering Lambda/processing, not for replay-based recovery. Important: PITR has a 5-minute lag (backup is current to within 5 minutes of present time)."
        },
        {
          "id": "D2-T2.2-Q9",
          "question": "A company migrates an on-premises Oracle database (10TB) to AWS using AWS DMS. The DMS replication instance keeps running out of storage during full load. What should they do to resolve this?",
          "options": [
            "Increase the DMS replication instance size to a larger class",
            "Enable multi-threading on the DMS task for faster load",
            "Increase the storage allocated to the DMS replication instance",
            "Use DMS Serverless which automatically scales storage"
          ],
          "correctAnswer": 2,
          "explanation": "DMS replication instances come with default storage (50GB or 100GB depending on instance class) used for log files and cached changes. During large migrations or busy source systems, this storage fills up. The solution is to increase allocated storage on the replication instance, not the instance size/class. Storage and compute are independent configurations. Option A (larger instance class) provides more CPU/memory but not necessarily more storage. Option B (multi-threading) speeds up migration but doesn't address storage. Option D (DMS Serverless) automatically scales compute and capacity but the question implies they're using instance-based DMS already deployed. Best practice for large migrations: (1) Estimate storage needs based on transaction volume during migration, (2) Monitor CloudWatch metrics for storage usage, (3) Allocate extra storage headroom (30-50% more than estimate), (4) For very large migrations, consider DMS Serverless which automatically handles capacity scaling."
        },
        {
          "id": "D2-T2.2-Q10",
          "question": "A media company stores video files in S3 (100TB) in us-east-1 and needs them replicated to eu-west-1 within 15 minutes for compliance. Existing videos (uploaded before replication was enabled) must also be replicated. What configuration is required? (Select TWO)",
          "options": [
            "Enable S3 Cross-Region Replication (CRR) with S3 Replication Time Control (RTC)",
            "Enable S3 Versioning on both source and destination buckets",
            "Use S3 Batch Replication to replicate existing objects",
            "Enable S3 Transfer Acceleration for faster replication",
            "Configure S3 Lifecycle policy to copy objects to the destination bucket",
            "Use AWS DataSync to initially sync existing files, then enable CRR"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1,
            2
          ],
          "explanation": "The complete solution requires: (1) S3 CRR with RTC for 15-minute SLA (RTC provides 99.99% of objects replicated within 15 minutes), (2) S3 Versioning on both buckets (prerequisite for CRR), (3) S3 Batch Replication to replicate existing objects since CRR only replicates objects uploaded after enabling replication. Option D (Transfer Acceleration) is for faster uploads to S3, not for replication between buckets. Option E (Lifecycle policy) can transition storage classes but doesn't replicate/copy objects across regions. Option F (DataSync) could work for initial sync but is unnecessary complexity - S3 Batch Replication is the AWS-native solution for replicating existing objects. Important: RTC adds cost but provides SLA guarantees and replication metrics. S3 Batch Replication creates a one-time job to replicate existing objects; after completion, ongoing CRR handles new objects."
        },
        {
          "id": "D2-T2.2-Q11",
          "question": "A company has an Aurora MySQL cluster in us-east-1 with 1 writer and 3 readers. They need to implement DR in us-west-2 with RTO of 2 minutes and RPO of 10 seconds. Which Aurora configuration provides the BEST balance of cost and requirements?",
          "options": [
            "Aurora Global Database with managed planned failover for zero RPO during maintenance",
            "Aurora cross-region read replica with manual promotion during failures",
            "Aurora Multi-AZ with automated failover (only protects against AZ failures, not regional)",
            "Aurora backtrack feature for point-in-time recovery"
          ],
          "correctAnswer": 0,
          "explanation": "Aurora Global Database is the correct choice for cross-region DR with stringent RTO/RPO requirements: (1) RPO of ~1 second (typical replication lag) meets the 10-second requirement, (2) RTO of approximately 1-5 minutes for cross-region failover meets the 2-minute requirement, (3) Managed planned failover provides RPO of 0 for maintenance windows. Option B (cross-region read replica) provides similar RPO but longer RTO as manual promotion takes more time than Global Database's coordinated failover. Option C (Multi-AZ) only protects against AZ failures within a region, not regional disasters. Option D (backtrack) is for rewinding the database to a prior state within the same cluster, not cross-region DR. Aurora Global Database supports up to 5 secondary regions with up to 16 read replicas per region. Cost consideration: Global Database costs more than single-region cross-region replicas but provides better RTO and managed failover capabilities."
        },
        {
          "id": "D2-T2.2-Q12",
          "question": "A SaaS platform uses DynamoDB Global Tables with Multi-Region Eventual Consistency (MREC) across us-east-1, eu-west-1, and ap-southeast-1. A customer reports that they updated a record in the EU but still see old data when querying from the AP region. What is the MOST likely cause?",
          "options": [
            "DynamoDB Global Tables are broken and need AWS Support intervention",
            "The application is using eventually consistent reads, and replication lag hasn't completed yet (typically sub-second but can be higher under load)",
            "Multi-Region Eventual Consistency is misconfigured; should use Multi-Region Strong Consistency (MRSC)",
            "DynamoDB Global Tables only replicate on a scheduled batch basis, not in real-time"
          ],
          "correctAnswer": 1,
          "explanation": "With DynamoDB Global Tables MREC (Multi-Region Eventual Consistency), writes are asynchronously replicated across regions, typically within one second or less. However, under high load or network conditions, replication can take longer. Additionally, if the application uses eventually consistent reads (default for GetItem/Query), it might read from a replica that hasn't received the latest update yet. To see the latest data, use strongly consistent reads locally (reads within the same region where the write occurred). Option A is overly dramatic - this is expected behavior with eventual consistency. Option C (MRSC) is available as of June 2025 but has constraints (exactly 3 regions, no transactions, higher latency) and isn't necessary for most use cases. Option D is incorrect - Global Tables replicate continuously, not in batches. Best practice: Understand consistency model implications. If your use case requires reading latest writes immediately, either: (1) Use strongly consistent reads in the same region, (2) Design application to handle eventual consistency, or (3) Evaluate MRSC if zero RPO is required."
        },
        {
          "id": "D2-T2.2-Q13",
          "question": "A company performs quarterly DR testing by promoting RDS read replicas in their DR region to standalone instances. After testing, they want to revert to the original configuration. What is the MOST operationally efficient approach?",
          "options": [
            "Promote read replica for testing, then delete it and create a new read replica from the primary",
            "Use AWS Backup to snapshot the read replica before promotion, promote for testing, then restore from snapshot",
            "Never promote read replicas during testing; only promote during actual disasters",
            "Use Route 53 Application Recovery Controller to simulate failover without actually promoting the replica"
          ],
          "correctAnswer": 0,
          "explanation": "RDS read replica promotion is a one-way operation - once promoted, the replica becomes a standalone instance and cannot be converted back to a replica. The standard approach for DR testing: (1) Promote read replica to test failover, (2) Conduct DR test, (3) Delete the promoted instance, (4) Create a new read replica from the primary for future DR. This validates the complete DR process including replica promotion. Option B adds complexity with snapshots and doesn't test the actual promotion process. Option C (never promote during testing) leaves you uncertain whether DR will work during a real disaster - the purpose of testing is to validate the complete procedure. Option D (Route 53 ARC) can orchestrate failover but doesn't validate the actual database promotion mechanism. Best practice: Automate the entire process - promote, test, delete, recreate - using AWS Systems Manager Automation Documents or Step Functions. This ensures DR procedures are validated and repeatable. Cost optimization: Schedule DR testing during low-traffic periods and use smaller instance classes for DR replicas that are scaled up during actual failover."
        },
        {
          "id": "D2-T2.2-Q14",
          "question": "A company uses AWS Backup to protect EC2 instances, EBS volumes, and RDS databases across 50 accounts. They want centralized visibility of backup compliance and automated notifications when backups fail. Which AWS Backup feature provides this?",
          "options": [
            "AWS Backup Audit Manager with compliance framework and SNS notifications",
            "CloudWatch Events triggered by AWS Backup job completions",
            "AWS Config rules for backup validation",
            "CloudTrail logs analysis with Athena queries"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Backup Audit Manager provides centralized backup compliance monitoring: (1) Built-in compliance frameworks (e.g., requiring daily backups, cross-region copies, retention policies), (2) Automated evaluation of backup activity against frameworks, (3) Compliance reports showing which resources meet/violate policies, (4) Integration with SNS for notifications on compliance violations, (5) Cross-account and cross-region visibility when using Organizations integration. Option B (CloudWatch Events) can trigger on backup events but requires custom logic to evaluate compliance. Option C (Config rules) can validate backups but isn't purpose-built for backup compliance. Option D (CloudTrail + Athena) is overly complex for what Audit Manager provides natively. AWS Backup Audit Manager frameworks can enforce requirements like: 'All EC2 instances must have daily backups with 7-day retention and cross-region copy to at least one other region.' This is critical for demonstrating compliance to auditors with automated evidence."
        }
      ]
    },
    {
      "filename": "domain-2-task-2.1-deployment-strategy.json",
      "domain": "Domain 2: Design for New Solutions",
      "task": "Task 2.1: Deployment Strategy",
      "question_count": 12,
      "questions": [
        {
          "question": "In July 2025, AWS introduced built-in blue/green deployment capability for ECS, eliminating the need for CodeDeploy. A company wants to implement this new feature for their ECS Fargate service. During deployment, they need to run integration tests against the green environment before routing production traffic. Which capability should they leverage?",
          "options": [
            "Configure CodeDeploy lifecycle hooks even though using built-in ECS blue/green",
            "Use ECS's automatic Lambda function invocation at specified lifecycle stages to run tests against the green revision",
            "Implement manual testing by keeping both blue and green running simultaneously",
            "Configure Application Load Balancer health checks to validate the green environment"
          ],
          "correctAnswer": 1,
          "explanation": "The new built-in ECS blue/green deployment feature (July 2025) automatically invokes Lambda functions at specified lifecycle stages, allowing comprehensive testing against the green revision before traffic cutover. This is included with Amazon ECS at no additional charge. Teams can configure Lambda functions to run integration tests, smoke tests, or any validation logic. Option A is incorrect - the whole point of the new feature is eliminating the need for CodeDeploy. Option C (manual testing) defeats the automation purpose. Option D (ALB health checks) validates basic health but doesn't run comprehensive integration tests. Key benefit: This new capability makes complex CodeDeploy workarounds unnecessary while providing near-instantaneous rollback capability if issues arise during validation."
        },
        {
          "question": "A team is implementing canary deployments for their Lambda function processing critical financial transactions. They want to route 10% of traffic to the new version for 10 minutes, then automatically shift the remaining 90% if no errors occur. Which deployment configuration achieves this?",
          "options": [
            "Use Lambda versions with weighted aliases: assign 90% weight to $LATEST and 10% to the new version",
            "Configure CodeDeploy with Lambda deployment using Canary10Percent10Minutes configuration",
            "Implement API Gateway canary deployment with 10% traffic to the new stage",
            "Use EventBridge rules to route 10% of events to the new Lambda version"
          ],
          "correctAnswer": 1,
          "explanation": "AWS CodeDeploy for Lambda supports predefined canary configurations like 'Canary10Percent10Minutes' which shifts 10% of traffic to the new version, waits 10 minutes, then automatically shifts the remaining 90% if CloudWatch alarms don't trigger. CodeDeploy can automatically rollback if failures are detected. Option A (weighted aliases) allows percentage-based routing but doesn't provide the automatic time-based progression or automated rollback that CodeDeploy offers. Option C (API Gateway canary) works for API-triggered Lambdas but doesn't help with event-driven sources like SQS, Kinesis, etc. Option D doesn't exist as a native capability. CodeDeploy also supports Linear (e.g., Linear10PercentEvery10Minutes) and All-at-once deployment patterns. Best practice: Use CloudWatch Alarms with CodeDeploy to automatically trigger rollback on error rate increases."
        },
        {
          "question": "A company needs to choose an Infrastructure as Code tool for their new AWS-only project. The development team is proficient in Python and wants to use familiar programming constructs (loops, conditionals, functions). They need to deploy across 10 AWS accounts with slight variations per account. Which tool is MOST appropriate?",
          "options": [
            "AWS CloudFormation with YAML templates and nested stacks for reusability",
            "AWS CDK with Python, leveraging programming language features and CDK constructs",
            "Terraform with HCL, using modules for reusability across accounts",
            "AWS CloudFormation with JSON templates and template parameters"
          ],
          "correctAnswer": 1,
          "explanation": "AWS CDK with Python is the optimal choice given the requirements: (1) Team is proficient in Python - no new language to learn, (2) Can use Python's loops, conditionals, functions, classes for complex logic and variations across accounts, (3) AWS-only project - CDK's tight AWS integration is beneficial, (4) CDK constructs provide higher-level abstractions reducing boilerplate. CDK synthesizes to CloudFormation, so you get CloudFormation's state management benefits. Option A (CloudFormation YAML) requires learning YAML/CloudFormation syntax and is more verbose for variations. Option C (Terraform) requires learning HCL and is better suited for multi-cloud; for AWS-only, CDK's ergonomics are superior. Option D (JSON) is even more verbose than YAML. As of 2025, CDK has growing momentum and AWS investment, making it increasingly the default choice for AWS-only infrastructure. CDK supports L1 (CloudFormation), L2 (curated), and L3 (patterns) constructs for different abstraction levels."
        },
        {
          "question": "A development team uses AWS CloudFormation StackSets to deploy a VPC architecture across 50 accounts in AWS Organizations. They update the template to add new subnets. They want to ensure that if the update fails in more than 3 accounts, the entire deployment stops. Which StackSets configuration achieves this?",
          "options": [
            "Set Maximum Concurrent Accounts to 3 and Continue Deploying to Remaining Accounts on Failure",
            "Set Failure Tolerance Count to 3 and Stop Operation on Subsequent Failures",
            "Configure CloudFormation rollback triggers with CloudWatch alarms",
            "Use StackSets drift detection to prevent deployments with more than 3 drifted accounts"
          ],
          "correctAnswer": 1,
          "explanation": "StackSets provides deployment control options including Failure Tolerance. Setting Failure Tolerance Count to 3 means: if updates fail in 3 or fewer accounts, the operation continues; if failures exceed 3, the operation stops and doesn't deploy to remaining accounts. This prevents cascading failures across the organization. You also configure Maximum Concurrent Accounts (parallelism) separately. For example: Max Concurrent = 10, Failure Tolerance = 3 means StackSets deploys to 10 accounts at a time but stops the entire operation if total failures exceed 3. Option A controls parallelism but doesn't stop on failures. Option C (rollback triggers) works for individual stacks but not for controlling StackSets operations across multiple accounts. Option D (drift detection) is for identifying configuration drift, not for controlling deployment failures. Best practice: Set conservative failure tolerance for production changes to prevent wide-scale issues."
        },
        {
          "question": "A SaaS company deploys customer-specific resources (databases, compute, storage) using Infrastructure as Code. They need feature flags to enable/disable features per customer without redeploying infrastructure. Which approach provides the MOST operationally efficient solution?",
          "options": [
            "Use CloudFormation parameters and update stacks with different parameter values per customer",
            "Implement AWS AppConfig for feature flag management, decoupling feature enablement from infrastructure deployment",
            "Store feature flags in DynamoDB and query on each request",
            "Use separate CloudFormation templates for each feature combination"
          ],
          "correctAnswer": 1,
          "explanation": "AWS AppConfig is purpose-built for feature flag and configuration management. It provides: (1) Dynamic configuration changes without redeployment, (2) Safe deployment strategies for configuration changes (similar to code deployments), (3) Validation of configuration data before deployment, (4) Rollback capability if issues occur, (5) Integration with Lambda, ECS, EC2, and other compute services. Feature flags can be enabled/disabled per customer instantly without infrastructure changes. Option A (CloudFormation parameters) requires stack updates which are slow and risky for simple feature toggles. Option C (DynamoDB) can work but requires custom implementation of safe rollout, validation, and rollback - reinventing what AppConfig provides. Option D (separate templates) creates maintenance nightmare. AppConfig deployment strategies include all-at-once, linear, and exponential rollout patterns, similar to CodeDeploy but for configuration."
        },
        {
          "question": "A financial services company must deploy applications with zero downtime and the ability to instantly rollback. They use Application Load Balancer with two target groups. During deployment, they want to validate the new version with synthetic transactions before routing real user traffic. Which deployment strategy and validation approach should they implement?",
          "options": [
            "Blue/green deployment with Route 53 weighted routing for gradual traffic shift",
            "Blue/green deployment with ALB listener rules and weighted target groups, using a pre-traffic Lambda hook for validation",
            "Canary deployment with CloudWatch Synthetics running tests against the canary version",
            "Rolling deployment with Connection Draining enabled"
          ],
          "correctAnswer": 1,
          "explanation": "Blue/green with ALB weighted target groups provides instant rollback capability and zero downtime. The architecture: (1) Blue target group handles production traffic (100% weight), (2) Deploy new version to green target group (0% weight), (3) Use Lambda hook to run synthetic tests against green, (4) If tests pass, shift traffic by adjusting weights (can be gradual: 10%, 50%, 100%), (5) If issues occur, instantly revert weights to 100% blue. ALB allows weights from 0-100 on target groups. Option A (Route 53) has slower rollback due to DNS propagation/caching. Option C (canary) works but doesn't provide the instant rollback that ALB weighted target groups offer. Option D (rolling) has downtime during rollback (must redeploy previous version). With ALB weighted target groups, rollback is near-instantaneous (just adjust weights), meeting the 'instantly rollback' requirement."
        },
        {
          "question": "A company uses CloudFormation to deploy a complex application with dependencies between resources (VPC → Subnets → EC2 → Load Balancer → DNS). Template updates sometimes fail midway, leaving the stack in UPDATE_ROLLBACK_FAILED state. Which CloudFormation features help prevent and recover from this scenario? (Select TWO)",
          "options": [
            "Use Stack Policy to prevent updates to critical resources",
            "Enable Termination Protection on the stack",
            "Implement CloudFormation DeletionPolicy: Retain on critical resources",
            "Use Change Sets to preview changes before execution",
            "Configure CloudFormation to Continue Update Rollback to skip problematic resources",
            "Enable Automatic Rollback on CloudWatch Alarm triggers"
          ],
          "type": "multiple",
          "correctAnswer": [
            3,
            4
          ],
          "explanation": "The best combination is: (1) Change Sets allow previewing exactly what CloudFormation will change before executing, reducing surprises that cause failures, and (2) Continue Update Rollback allows recovering from UPDATE_ROLLBACK_FAILED state by skipping resources that can't be rolled back. Option A (Stack Policy) prevents accidental updates but doesn't help with failed rollbacks. Option B (Termination Protection) prevents stack deletion, not relevant here. Option C (DeletionPolicy Retain) prevents resource deletion but doesn't address rollback failures. Option F (Alarm triggers) can automatically rollback but doesn't prevent or recover from UPDATE_ROLLBACK_FAILED state. When UPDATE_ROLLBACK_FAILED occurs, you use Continue Update Rollback in the console or AWS CLI, optionally specifying resources to skip. This is critical for recovering from complex failure scenarios without losing the entire stack."
        },
        {
          "question": "An enterprise manages infrastructure for both AWS and on-premises VMware environments. They need a single Infrastructure as Code tool that can provision resources in both environments, with existing team expertise in declarative configuration. Which tool should they standardize on?",
          "options": [
            "AWS CDK, using AWS CDK for CloudFormation (AWS resources) and CDK8s for Kubernetes-based VMware",
            "Terraform, leveraging AWS provider for cloud resources and VMware provider for on-premises",
            "AWS CloudFormation with custom resources backed by Lambda to provision VMware resources",
            "Ansible for both environments as it supports both cloud and on-premises provisioning"
          ],
          "correctAnswer": 1,
          "explanation": "Terraform is the correct choice for hybrid cloud/on-premises infrastructure. Key advantages: (1) Official providers for both AWS and VMware vSphere, (2) Declarative HCL syntax consistent across providers, (3) Single workflow and state management across environments, (4) Mature ecosystem and community support for hybrid scenarios. The team can use Terraform modules to abstract differences between AWS and VMware. Option A (CDK) is primarily AWS-focused; while CDK8s exists for Kubernetes, it doesn't directly support VMware vSphere. Option C (CloudFormation with custom resources) is overly complex and defeats the purpose of IaC - custom Lambda code to manage VMware is maintenance-heavy. Option D (Ansible) is a configuration management tool, not primarily an IaC provisioning tool, though it can provision resources. Terraform's strength in multi-cloud and hybrid scenarios makes it the industry standard for this use case, as confirmed by 2025 trends showing Terraform as the default choice for multi-provider scenarios."
        },
        {
          "question": "A company deploys microservices using AWS CodePipeline with stages: Source (GitHub) → Build (CodeBuild) → Deploy to Dev (ECS) → Manual Approval → Deploy to Prod (ECS). They want to add security scanning after Build and automatically fail the pipeline if critical vulnerabilities are found. Where should security scanning be added?",
          "options": [
            "Add a Test stage after Build with CodeBuild project running security scanners (Snyk, Trivy), configured to fail the stage on critical findings",
            "Implement security scanning in the Build stage CodeBuild project as a post-build phase",
            "Use Lambda function triggered by CodePipeline between Build and Deploy stages",
            "Enable Amazon Inspector scanning in ECR which will automatically block vulnerable images from deployment"
          ],
          "correctAnswer": 0,
          "explanation": "Adding a dedicated Test stage with security scanning provides: (1) Clear separation of concerns (build vs test), (2) Explicit visibility in pipeline - stakeholders see that security scanning occurred, (3) Ability to run multiple test types in parallel, (4) Clear failure indication if vulnerabilities found. The CodeBuild project in the Test stage runs security scanners and uses exit codes to signal pass/fail, stopping the pipeline before Dev deployment if critical vulnerabilities exist. Option B (post-build phase) works but lacks visibility - failures appear as 'Build failed' rather than 'Security scan failed'. Option C (Lambda) adds unnecessary complexity - CodeBuild can run any security tool. Option D (Inspector in ECR) provides scanning but doesn't automatically block deployments - it reports findings. Best practice: Use dedicated Test stage with parallel actions for different scan types (SAST with CodeGuru, container scanning with Trivy/Snyk, dependency checking with OWASP Dependency-Check)."
        },
        {
          "question": "A development team uses Terraform to manage AWS infrastructure across 20 environments (4 regions × 5 stages). They experience frequent state locking conflicts when multiple team members deploy simultaneously. Which configuration provides the MOST robust state management?",
          "options": [
            "Use local state files with Git for version control",
            "Configure S3 backend with DynamoDB for state locking, with separate state files per environment",
            "Use Terraform Cloud for state management and collaboration",
            "Store state in S3 with versioning enabled, without DynamoDB locking"
          ],
          "correctAnswer": 1,
          "explanation": "S3 backend with DynamoDB state locking is the AWS-native, robust solution for team collaboration. Configuration: (1) S3 bucket with versioning for state files (disaster recovery), (2) DynamoDB table for state locking (prevents concurrent modifications), (3) Separate state files per environment using workspace or different S3 keys. This prevents conflicts while maintaining separation. S3 provides durability, versioning for rollback, and encryption. DynamoDB locking ensures only one person/process can modify state at a time. Option A (local + Git) is extremely problematic - state contains sensitive data and Git isn't designed for state management; merge conflicts are disastrous. Option C (Terraform Cloud) is excellent but adds external dependency and cost. Option D (S3 without DynamoDB) risks state corruption from concurrent updates. Best practice: Enable S3 versioning, bucket encryption, and restricted IAM access. Use separate state files per environment (either via workspaces or different S3 keys) to prevent cross-environment impact."
        },
        {
          "question": "A company uses AWS CDK to deploy infrastructure. They want to ensure that developers can see what CloudFormation resources will be created before deploying. Additionally, they need to validate that CDK applications comply with organizational policies (e.g., all S3 buckets encrypted, no public access). Which CDK features address these requirements? (Select TWO)",
          "options": [
            "Use 'cdk diff' command to preview changes before deployment",
            "Implement CDK Aspects to validate and enforce policies across constructs",
            "Enable CloudFormation Change Sets in CDK configuration",
            "Use 'cdk synth' to generate CloudFormation templates for review",
            "Configure AWS Config rules to validate deployed resources",
            "Implement custom Lambda-backed CloudFormation resources for validation"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            3
          ],
          "explanation": "The correct combination is: (1) CDK Aspects allow implementing cross-cutting concerns and policy validation. Aspects visit all constructs in the CDK app and can validate, modify, or enforce rules. For example, an aspect can verify all S3 buckets have encryption enabled and fail the synth process if not. (2) 'cdk synth' generates the CloudFormation template that will be deployed, allowing review of exact resources before deployment. While 'cdk diff' (Option A) shows changes, it doesn't help with initial deployments or policy validation. Option C is incorrect - Change Sets are CloudFormation feature automatically used by CDK, not separately configured. Option E (Config rules) validates after deployment, not before. Option F is overengineered. CDK Aspects example: class BucketEncryptionAspect implements IAspect { visit(node: IConstruct) { if (node instanceof s3.Bucket && !node.encryptionKey) { Annotations.of(node).addError('Bucket must be encrypted'); } }}. This fails synthesis if policies aren't met, preventing deployment."
        },
        {
          "question": "A platform team manages a base networking infrastructure (VPC, subnets, security groups) deployed via CloudFormation. Application teams need to deploy resources into this VPC without having permissions to modify the networking stack. Which CloudFormation feature enables this safe resource sharing?",
          "options": [
            "Use CloudFormation Cross-Stack References with Outputs and ImportValue",
            "Grant application teams read-only access to the networking stack",
            "Use AWS Resource Access Manager (RAM) to share VPC resources",
            "Store VPC IDs in Systems Manager Parameter Store for application stacks to reference"
          ],
          "correctAnswer": 0,
          "explanation": "CloudFormation Cross-Stack References using Outputs and ImportValue is the native solution. The networking stack exports values (VPC ID, subnet IDs, security group IDs) using Outputs with Export names. Application stacks import these values using Fn::ImportValue. Benefits: (1) Type-safe references (CloudFormation validates that exported values exist), (2) Dependency tracking (CloudFormation prevents deleting exported values while they're in use), (3) No additional permissions needed on networking stack. Example: Networking stack: Outputs: VPCId: Value: !Ref VPC Export: Name: Platform-VPC-ID. Application stack: Resources: EC2Instance: Properties: SubnetId: !ImportValue Platform-Subnet-ID. Option B (read access) doesn't solve the deployment integration problem. Option C (RAM) is for sharing actual resources, not for CloudFormation integration. Option D (Parameter Store) works but lacks CloudFormation's native dependency tracking and validation. Cross-stack references provide clean separation: platform team owns infrastructure, app teams deploy into it without modification permissions."
        }
      ]
    },
    {
      "filename": "domain-2-task-2.3-security-controls.json",
      "domain": "Domain 2: Design for New Solutions",
      "task": "Task 2.3: Security Controls",
      "question_count": 16,
      "questions": [
        {
          "id": "D2-T2.3-Q1",
          "question": "A web application behind an ALB experiences bot attacks that bypass traditional rate limiting. The security team needs protection against sophisticated bots using machine learning detection while allowing legitimate search engine crawlers. Which AWS WAF configuration provides the BEST protection?",
          "options": [
            "AWS WAF Bot Control Common level (detects self-identifying bots only)",
            "AWS WAF Bot Control Targeted Protection level with ML-based detection and search engine allow rules",
            "AWS WAF rate-based rule blocking requests exceeding 2000 per 5 minutes",
            "AWS Shield Advanced with DDoS protection"
          ],
          "correctAnswer": 1,
          "explanation": "AWS WAF Bot Control Targeted Protection level provides comprehensive bot protection using: (1) Machine learning analysis (rules starting with TGT_ML_) that detect anomalous behavior indicative of distributed bot activity, (2) Browser interrogation and fingerprinting for sophisticated bots that don't self-identify, (3) Built-in rules to allow legitimate bots like search engines (GoogleBot, BingBot). The ML model analyzes traffic statistics including timestamps, browser characteristics, and behavioral patterns. Option A (Common level) only detects self-identifying bots using static analysis, missing sophisticated attacks. Option C (rate-based rules) is easily bypassed by distributed bots. Option D (Shield Advanced) protects against DDoS but doesn't provide granular bot detection. Bot Control also includes Token Reuse Detection (2025 enhancement) identifying token reuse across different ASNs and geographic locations with adjustable sensitivity."
        },
        {
          "id": "D2-T2.3-Q2",
          "question": "A financial application requires encryption of data at rest and in transit. Database credentials must be rotated every 30 days automatically. The application runs on ECS Fargate and connects to RDS PostgreSQL. Which combination provides the MOST secure and automated solution? (Select TWO)",
          "options": [
            "Store credentials in AWS Secrets Manager with automatic rotation enabled using Lambda rotation function",
            "Use IAM database authentication for RDS eliminating the need for passwords",
            "Store credentials in Systems Manager Parameter Store with manual rotation",
            "Enable RDS encryption at rest with AWS-managed KMS keys",
            "Use application-managed credential rotation with credentials in environment variables",
            "Enable SSL/TLS for RDS connections with certificate verification"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            1
          ],
          "explanation": "The optimal combination is: (1) Secrets Manager with automatic rotation - provides automated credential rotation every 30 days using AWS-provided or custom Lambda functions. ECS tasks retrieve credentials at runtime, getting the latest rotated values. (2) IAM database authentication eliminates passwords entirely - ECS task role generates authentication tokens valid for 15 minutes, providing better security than password-based auth. While both can be used, IAM auth is more secure (no secrets to rotate). Options D and F are important but address encryption, not the credential rotation requirement. Option C (Parameter Store) doesn't provide automatic rotation like Secrets Manager. Option E (environment variables) is insecure - credentials are visible in task definitions. Best practice: Use IAM database authentication where possible; for applications requiring traditional passwords, use Secrets Manager with automatic rotation."
        },
        {
          "id": "D2-T2.3-Q3",
          "question": "A company uses AWS KMS customer-managed keys (CMKs) to encrypt S3 buckets, EBS volumes, and RDS databases across 50 AWS accounts. They need centralized key management and the ability to immediately disable access to all encrypted data in case of a security incident. What is the MOST operationally efficient approach?",
          "options": [
            "Create separate CMKs in each account and manually disable them during incidents",
            "Create a CMK in a central security account, share it across accounts using key policies, and disable the CMK to revoke all access",
            "Use AWS-managed keys which can be centrally controlled through Organizations",
            "Create CMKs in each account but use AWS Config to automate disabling via Lambda"
          ],
          "correctAnswer": 1,
          "explanation": "A centralized CMK in a security account with cross-account sharing provides: (1) Single point of management - one key policy controls access from all accounts, (2) Immediate revocation - disabling the CMK instantly revokes decrypt access across all accounts and resources, (3) Centralized audit trail - all key usage logged to one CloudTrail. The key policy grants usage permissions to IAM roles in other accounts. During a security incident, disabling the CMK immediately prevents decryption of any data encrypted with it. Option A lacks centralization and requires 50 manual operations. Option C is incorrect - AWS-managed keys cannot be disabled or centrally controlled. Option D adds unnecessary complexity. Important: Key policies can limit which services and principals can use the key. For multi-account architectures, a centralized KMS key in a security account following least privilege is a best practice. Note: Disabled keys prevent decryption but don't delete data; re-enabling restores access."
        },
        {
          "id": "D2-T2.3-Q4",
          "question": "An API Gateway REST API exposes sensitive financial data. The security team requires: (1) Authentication via corporate Active Directory, (2) Authorization based on user groups, (3) Request throttling per user. Which API Gateway configuration meets all requirements?",
          "options": [
            "Use API Gateway Lambda authorizer validating AD credentials and returning user context with throttling limits",
            "Integrate with Amazon Cognito User Pools federated with AD via SAML, use Cognito groups for authorization, implement usage plans with API keys",
            "Use IAM authorization with IAM roles mapped to AD groups via federation",
            "Implement AWS WAF with rate-based rules for throttling and custom Lambda for AD authentication"
          ],
          "correctAnswer": 1,
          "explanation": "Cognito User Pools with AD federation provides the complete solution: (1) Federation with AD via SAML 2.0 - users authenticate against corporate AD, (2) Cognito groups mapped to AD groups - API Gateway can authorize based on groups in the JWT token, (3) Usage plans with API keys - API Gateway natively supports per-user throttling using usage plans. The flow: User authenticates via AD → Cognito issues JWT with groups → API Gateway validates JWT and checks groups → Usage plan enforces throttling. Option A (Lambda authorizer) can work but requires custom implementation of all logic. Option C (IAM) doesn't integrate well with per-user throttling and requires AWS credentials. Option D (WAF) doesn't provide authentication or per-user throttling granularity. API Gateway usage plans can set throttle and quota limits per API key. Best practice: Use Cognito User Pools for user management and API Gateway authorizers for validation."
        },
        {
          "id": "D2-T2.3-Q5",
          "question": "A container application uses AWS Secrets Manager to retrieve database passwords. Security audit reveals that containers running for days still have the initial password even after Secrets Manager rotation. How should the application be updated to use rotated credentials?",
          "options": [
            "Restart containers every 30 days to force credential refresh",
            "Implement application code to periodically call Secrets Manager GetSecretValue API to retrieve current credentials",
            "Use Secrets Manager rotation Lambda function to update environment variables in running containers",
            "Enable Secrets Manager automatic credential injection into containers"
          ],
          "correctAnswer": 1,
          "explanation": "Applications must actively retrieve secrets from Secrets Manager to get rotated values. Best practices: (1) Retrieve secrets at runtime on each database connection (or cache for short duration like 5 minutes), (2) Implement retry logic with exponential backoff if connection fails due to rotation in progress, (3) Use Secrets Manager caching libraries (AWS provides caching clients for multiple languages) to reduce API calls while ensuring freshness. Option A (restart containers) causes downtime and doesn't scale. Option C doesn't exist - rotation Lambda rotates secrets in Secrets Manager and the database, not container environment variables. Option D doesn't exist as an automatic feature. Common mistake: Retrieving secrets once at startup and caching indefinitely. Correct approach: Periodic retrieval or event-driven (using CloudWatch Events when rotation completes). For containers, sidecar pattern can handle secret retrieval and provide to application via localhost."
        },
        {
          "id": "D2-T2.3-Q6",
          "question": "A company runs a public web application that must pass PCI DSS compliance. They use Application Load Balancer with EC2 instances. Which security controls are REQUIRED for PCI DSS? (Select THREE)",
          "options": [
            "Use AWS WAF to protect against OWASP Top 10 vulnerabilities",
            "Implement encryption in transit using TLS 1.2 or higher on the ALB",
            "Enable AWS Shield Standard (automatically included) for DDoS protection",
            "Enable VPC Flow Logs to capture network traffic for audit",
            "Use Security Groups to restrict inbound traffic to only necessary ports (443 for HTTPS)",
            "Enable AWS Config to monitor security group configuration compliance"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            3,
            4
          ],
          "explanation": "PCI DSS requirements for AWS applications include: (1) Encryption in transit - TLS 1.2+ is required for transmitting cardholder data (PCI DSS requirement 4.1), (2) Network traffic logging - VPC Flow Logs provide audit trails of network access (PCI DSS requirement 10), (3) Network segmentation and access control - Security Groups implementing least privilege access (PCI DSS requirement 1). Option A (WAF) is highly recommended but not strictly required by PCI DSS, though it helps with several requirements. Option C (Shield Standard) is included automatically but isn't a PCI DSS requirement. Option F (Config) is recommended for compliance monitoring but not a core requirement. Other PCI DSS requirements include: encryption at rest, access controls, regular security testing, intrusion detection (GuardDuty), and centralized logging (CloudTrail). Use AWS PCI DSS compliance documentation and AWS Config conformance packs for PCI DSS to ensure all controls are implemented."
        },
        {
          "id": "D2-T2.3-Q7",
          "question": "A healthcare application on ECS Fargate must comply with HIPAA. Container images are stored in ECR. Which security measures ensure HIPAA compliance for container images? (Select TWO)",
          "options": [
            "Enable ECR image scanning to detect vulnerabilities in container images",
            "Use ECR lifecycle policies to retain images for 6 years for compliance",
            "Enable encryption at rest for ECR repositories using AWS KMS customer-managed keys",
            "Implement ECR cross-region replication for disaster recovery",
            "Use ECR pull-through cache for frequently accessed images",
            "Enable ECR tag immutability to prevent image tag overwrites"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2
          ],
          "explanation": "HIPAA compliance for container images requires: (1) Image scanning - ECR image scanning (basic or enhanced with Inspector) detects vulnerabilities in images. HIPAA requires systems to be free from known vulnerabilities. Scanning on push and continuous scanning help maintain compliance. (2) Encryption at rest - HIPAA requires encryption of ePHI (electronic Protected Health Information). ECR supports encryption with KMS CMKs, providing audit trails of key usage. Option B (6-year retention) is excessive for images; HIPAA requires audit logs and data retention but not necessarily container images for 6 years. Option D (replication) supports business continuity but isn't a HIPAA requirement. Option E (pull-through cache) is for performance. Option F (tag immutability) is good practice but not a HIPAA requirement. Additional HIPAA requirements: access controls (IAM policies), audit logging (CloudTrail), network isolation (VPC), encryption in transit. AWS provides HIPAA-eligible services including ECR, ECS, and Fargate."
        },
        {
          "id": "D2-T2.3-Q8",
          "question": "A serverless application uses API Gateway with Lambda backend processing sensitive customer data. The security team requires request/response logging for audit while ensuring sensitive data in logs is not exposed. What is the MOST secure logging configuration?",
          "options": [
            "Enable API Gateway CloudWatch Logs with full request/response body logging",
            "Enable API Gateway CloudWatch Logs with INFO level logging (metadata only, no request/response bodies)",
            "Disable API Gateway logging and implement custom logging in Lambda functions only",
            "Enable API Gateway access logs to S3 with server-side encryption"
          ],
          "correctAnswer": 1,
          "explanation": "API Gateway CloudWatch Logs with INFO level provides: (1) Request metadata (timestamp, source IP, method, path, status codes) for audit, (2) No request/response bodies preventing sensitive data exposure in logs, (3) Integration with CloudWatch Insights for analysis. This balances audit requirements with data protection. Option A (full logging) risks exposing sensitive data (PII, passwords, tokens) in CloudWatch Logs. Even with encryption, principle of least privilege suggests not logging sensitive data. Option C (no API Gateway logs) loses valuable audit information about API access patterns, error rates, and request metadata. Option D (access logs to S3) provides similar information to INFO level but CloudWatch Logs offers better querying and alerting. Best practice: INFO level logging + custom application logging for business logic (without sensitive data) + AWS WAF logging for security events. Use CloudWatch Logs data protection to redact sensitive patterns if full logging is required."
        },
        {
          "id": "D2-T2.3-Q9",
          "question": "A company must implement defense in depth for their three-tier web application (ALB → EC2 → RDS). Which security architecture provides multiple layers of protection? (Select THREE)",
          "options": [
            "AWS WAF on ALB with managed rules for SQL injection and XSS protection",
            "Network ACLs allowing only return traffic and explicit allow rules",
            "Security Groups: ALB allows 443 from internet, EC2 allows traffic only from ALB security group, RDS allows traffic only from EC2 security group",
            "GuardDuty for threat detection analyzing VPC Flow Logs and CloudTrail",
            "AWS Firewall Manager to centrally manage security groups",
            "VPC endpoint for S3 to prevent internet access"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2,
            3
          ],
          "explanation": "Defense in depth requires multiple security layers: (1) WAF at application layer - protects against OWASP Top 10 (SQL injection, XSS, etc.) before requests reach the application, (2) Security Groups as micro-segmentation - each tier only accepts traffic from the tier above (ALB ← Internet, EC2 ← ALB only, RDS ← EC2 only), preventing lateral movement, (3) GuardDuty for threat detection - analyzes logs to detect compromises, unusual API calls, and malicious activity. Option B (NACLs) can add value but is less critical than the selected options; Security Groups are stateful and more manageable. Option E (Firewall Manager) is for centralized management, not an additional security layer. Option F (VPC endpoint) is good practice but doesn't directly protect the three-tier app. Additional layers: CloudTrail for API audit, AWS Config for configuration compliance, Systems Manager for patch management, Inspector for vulnerability scanning."
        },
        {
          "id": "D2-T2.3-Q10",
          "question": "An application uses client-side encryption before uploading objects to S3. The security team wants to ensure that any object uploaded to the bucket without client-side encryption is automatically rejected. How can this be enforced?",
          "options": [
            "Enable S3 default encryption with SSE-S3",
            "Create S3 bucket policy denying PutObject unless x-amz-server-side-encryption header is present",
            "Create S3 bucket policy denying PutObject unless x-amz-meta-client-encrypted metadata is present",
            "Use S3 Object Lock to prevent unencrypted uploads"
          ],
          "correctAnswer": 2,
          "explanation": "Client-side encryption means data is encrypted before reaching AWS. To enforce this, the application must indicate encryption using custom metadata. S3 bucket policy denying uploads without the custom metadata (e.g., x-amz-meta-client-encrypted=true) enforces the requirement: Policy condition: 'StringNotEquals': {'s3:x-amz-meta-client-encrypted': 'true'}. Option A (default encryption) is server-side encryption, doesn't validate client-side encryption. Option B checks for server-side encryption headers, not client-side. Option D (Object Lock) prevents deletion/modification, not related to encryption enforcement. Important: Client-side encryption provides strongest security (AWS never sees unencrypted data) but requires proper key management. Options: AWS Encryption SDK, S3 encryption client libraries. The application encrypts with a key (stored in KMS, locally, etc.) before upload. S3 bucket policy enforces the workflow but doesn't perform encryption."
        },
        {
          "id": "D2-T2.3-Q11",
          "question": "A company runs microservices on EKS and needs to implement mutual TLS (mTLS) authentication between services for zero-trust security. Which AWS service provides the MOST automated solution for certificate management and mTLS?",
          "options": [
            "Use AWS Certificate Manager (ACM) to issue certificates and manually distribute to pods",
            "Implement AWS App Mesh with TLS encryption and AWS Certificate Manager Private CA for automatic certificate rotation",
            "Use cert-manager on Kubernetes with Let's Encrypt for certificate issuance",
            "Manually generate certificates with OpenSSL and mount as Kubernetes secrets"
          ],
          "correctAnswer": 1,
          "explanation": "AWS App Mesh with ACM Private CA provides automated mTLS for microservices: (1) App Mesh Envoy proxies handle TLS termination/origination transparently, (2) ACM Private CA issues certificates for each service, (3) Automatic certificate rotation before expiry (no application downtime), (4) Centralized policy management for which services can communicate. App Mesh implements service mesh pattern with automatic mTLS enforcement. Option A (ACM) doesn't support automatic distribution to EKS pods; ACM is for load balancers. Option C (cert-manager + Let's Encrypt) works but requires more operational overhead and Let's Encrypt is for public certificates, not ideal for internal mTLS. Option D (manual OpenSSL) is operationally intensive with manual rotation. App Mesh also provides: observability (metrics, traces), traffic management (canary deployments), and circuit breaking. Alternative: Istio service mesh also supports mTLS but requires self-management vs App Mesh's AWS-managed control plane."
        },
        {
          "id": "D2-T2.3-Q12",
          "question": "A financial application requires that all S3 buckets have versioning enabled, access logging enabled, and default encryption. They want to prevent creation of non-compliant buckets across 100 AWS accounts. Which preventive control is MOST effective?",
          "options": [
            "AWS Config rules that detect non-compliant buckets and trigger automatic remediation",
            "Service Control Policy (SCP) denying s3:CreateBucket unless versioning, logging, and encryption are enabled",
            "CloudFormation StackSets deploying compliant bucket templates to all accounts",
            "AWS Security Hub with CIS AWS Foundations Benchmark checks"
          ],
          "correctAnswer": 1,
          "explanation": "SCP provides true preventive control stopping non-compliant bucket creation at the organization level. The SCP denies s3:CreateBucket API calls unless the request includes versioning, logging, and encryption configurations. This prevents human error and ensures compliance from creation. With September 2025 SCP enhancements supporting full IAM policy language, you can write: Deny s3:CreateBucket unless conditions check for s3:x-amz-server-side-encryption, versioning, and logging configurations. Option A (Config rules) is detective, not preventive - buckets are created first, then detected as non-compliant. Option C (StackSets) ensures compliant buckets but doesn't prevent manual creation of non-compliant ones. Option D (Security Hub) aggregates findings but doesn't prevent actions. Important: Combine preventive (SCPs) with detective (Config) controls. SCPs prevent violations; Config detects configuration drift if SCPs are bypassed (e.g., changes after creation)."
        },
        {
          "id": "D2-T2.3-Q13",
          "question": "A company uses Amazon Cognito User Pools for their mobile app authentication. They need to implement step-up authentication requiring MFA for sensitive operations (money transfer) but not for viewing account balance. How should this be implemented?",
          "options": [
            "Enable MFA required for all users in Cognito User Pool settings",
            "Use Cognito User Pool Lambda triggers to challenge users for MFA based on the operation",
            "Implement custom application logic checking for MFA in ID tokens, requesting MFA challenge when needed",
            "Create separate Cognito User Pools for high-security and low-security operations"
          ],
          "correctAnswer": 2,
          "explanation": "Step-up authentication requires application-level logic: (1) Cognito issues ID tokens containing authentication_time and amr (authentication methods reference) claims, (2) For sensitive operations, application checks if MFA was used recently (amr contains 'mfa'), (3) If not, application calls Cognito's GetSession or InitiateAuth with required MFA, challenging the user, (4) After successful MFA, new tokens include MFA claim. This allows operation-specific security. Option A (always require MFA) forces MFA for all operations, poor UX. Option B (Lambda triggers) can customize auth flows but doesn't specifically support operation-based MFA challenges; triggers are for auth flow customization, not post-auth operation validation. Option D (separate pools) is overly complex. Implementation: Check ID token amr and auth_time claims. If MFA wasn't used or auth_time is too old, call InitiateAuth with AUTH_FLOW: 'CUSTOM_AUTH' or use Cognito API to request MFA. This pattern is common in financial apps: basic operations with password only, sensitive operations require recent MFA."
        },
        {
          "id": "D2-T2.3-Q14",
          "question": "A company migrates to AWS and must implement data sovereignty requirements ensuring EU customer data never leaves EU regions. They use S3 for storage and Lambda for processing. What controls ensure compliance? (Select THREE)",
          "options": [
            "Use S3 Block Public Access to prevent data exfiltration",
            "Implement S3 bucket policies restricting replication and actions to EU regions only",
            "Use SCP denying operations in non-EU regions for accounts handling EU data",
            "Enable S3 Object Lock for data protection",
            "Configure Lambda functions with VPC endpoints in EU regions",
            "Use AWS Organizations to create an OU for EU accounts with geographical restrictions"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            2,
            5
          ],
          "explanation": "Data sovereignty requires multi-layer geographical restrictions: (1) S3 bucket policies restricting cross-region replication and denying PutObject/GetObject from non-EU regions using aws:RequestedRegion condition, (2) SCPs at organization level denying API calls to non-EU regions for accounts handling EU data - prevents accidental or intentional data movement, (3) Organizational structure with dedicated OU for EU accounts enabling policy-based enforcement and clear data boundaries. Option A (Block Public Access) prevents public internet access but doesn't enforce regional restrictions. Option D (Object Lock) prevents deletion/modification, not regional restrictions. Option E (VPC endpoints) are for private connectivity, not data sovereignty. Additional controls: IAM policies restricting S3 GetObject to EU IPs, CloudTrail monitoring for non-EU API calls, Config rules validating all resources in EU regions. Example SCP condition: 'StringNotEquals': {'aws:RequestedRegion': ['eu-west-1', 'eu-central-1']}."
        },
        {
          "id": "D2-T2.3-Q15",
          "question": "An application uses AWS Secrets Manager to store API keys for third-party services. The security team discovers that IAM users are retrieving secrets using GetSecretValue and exfiltrating them. Which additional security control prevents unauthorized secret retrieval?",
          "options": [
            "Enable CloudTrail logging for Secrets Manager API calls",
            "Implement resource-based policy on secrets restricting access to specific IAM roles used by applications, not users",
            "Enable Secrets Manager automatic rotation to invalidate exfiltrated secrets",
            "Use AWS CloudWatch Alarms to detect unusual GetSecretValue API calls"
          ],
          "correctAnswer": 1,
          "explanation": "Resource-based policies on secrets provide least privilege access control: Only allow GetSecretValue from specific IAM roles (e.g., ECS task roles, Lambda execution roles), explicitly deny IAM users. Policy example: {'Effect': 'Deny', 'Principal': {'AWS': '*'}, 'Action': 'secretsmanager:GetSecretValue', 'Condition': {'StringNotLike': {'aws:PrincipalArn': 'arn:aws:iam::*:role/AllowedAppRoles*'}}}. This prevents direct user access while allowing application roles. Option A (CloudTrail) is detective, not preventive - logs the access but doesn't stop it. Option C (rotation) helps limit damage but doesn't prevent retrieval. Option D (CloudWatch Alarms) is also detective. Best practice: Applications should use IAM roles, not users. Secrets Manager permissions should be granted only to application roles. Use session tags and ABAC for fine-grained control. Monitor CloudTrail for GetSecretValue calls from unexpected principals. Combine preventive (resource policies) with detective (CloudTrail, alarms) controls."
        },
        {
          "id": "D2-T2.3-Q16",
          "question": "A company runs workloads requiring FIPS 140-2 validated cryptographic modules. Which AWS services and configurations provide FIPS 140-2 compliance? (Select TWO)",
          "options": [
            "Use AWS KMS in FIPS endpoints (kms-fips.region.amazonaws.com) for encryption operations",
            "Configure S3 to use FIPS 140-2 validated encryption modules",
            "Use CloudHSM which provides FIPS 140-2 Level 3 validated hardware security modules",
            "Enable FIPS mode in EC2 instances using AWS-provided AMIs",
            "Use ACM certificates which are automatically FIPS compliant",
            "Configure RDS encryption which uses FIPS modules automatically"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2
          ],
          "explanation": "FIPS 140-2 compliance in AWS requires: (1) AWS KMS FIPS endpoints - KMS uses FIPS 140-2 validated cryptographic modules, but applications must connect to FIPS endpoints (kms-fips.region.amazonaws.com) to ensure FIPS mode, (2) CloudHSM - provides FIPS 140-2 Level 3 validated HSMs for customer-exclusive cryptographic operations, suitable for workloads requiring dedicated HSMs. Option B is incorrect - S3 encryption uses KMS or S3-managed keys; you ensure FIPS by using KMS FIPS endpoints. Option D is partially true - you can configure FIPS mode on Linux instances, but this is OS-level, not AWS-provided. Option E is incorrect - ACM uses cryptographic modules but you don't configure FIPS mode for ACM. Option F is incorrect - RDS encryption uses KMS; for FIPS compliance, the application connecting to RDS should use FIPS endpoints and encrypted connections. Many AWS services support FIPS endpoints including S3, DynamoDB, and others. List available at: https://aws.amazon.com/compliance/fips/."
        }
      ]
    },
    {
      "filename": "domain-2-task-2.4-reliability.json",
      "domain": "Domain 2: Design for New Solutions",
      "task": "Task 2.4: Reliability Requirements",
      "question_count": 16,
      "questions": [
        {
          "id": "D2-T2.4-Q1",
          "question": "A web application experiences variable traffic patterns with daily spikes from 100 to 5000 requests per minute. Historical data shows traffic spikes occur predictably at 9 AM and 6 PM daily. Which Auto Scaling configuration minimizes costs while maintaining performance?",
          "options": [
            "Target tracking scaling policy maintaining 50% CPU utilization",
            "Predictive scaling policy analyzing 14 days of historical metrics to forecast and scale ahead of predicted load",
            "Scheduled scaling actions at 8:50 AM and 5:50 PM to pre-scale capacity",
            "Step scaling policy with multiple thresholds for different load levels"
          ],
          "correctAnswer": 1,
          "explanation": "Predictive scaling (available as of 2025 in most regions) uses machine learning to analyze up to 14 days of CloudWatch metrics and forecast capacity needs for the next 48 hours. For workloads with cyclical patterns (daily spikes at 9 AM/6 PM), predictive scaling: (1) Scales ahead of forecasted load (proactive vs reactive), (2) Provides smoother scaling than reactive policies, (3) Reduces the lag between demand increase and capacity availability. Predictive scaling can operate in 'Forecast Only' mode (test forecasts) or 'Forecast and Scale' mode (actually scale). Option C (scheduled scaling) works but requires manual maintenance and doesn't adapt to changing patterns. Option A (target tracking) is reactive - waits for CPU to reach 50% before scaling, causing performance degradation during rapid spikes. Option D (step scaling) is also reactive. Best practice: Combine predictive scaling for cyclical patterns with target tracking or step scaling for unexpected spikes beyond forecasted levels."
        },
        {
          "id": "D2-T2.4-Q2",
          "question": "An e-commerce application uses Application Load Balancer with Auto Scaling. During deployments, new instances pass ALB health checks before completing application initialization, causing errors for requests routed to them. What configuration prevents traffic to incompletely initialized instances?",
          "options": [
            "Increase ALB health check interval and unhealthy threshold",
            "Enable connection draining with 300-second timeout",
            "Configure Auto Scaling lifecycle hooks to delay instance in-service state until application initialization completes",
            "Use ALB health check path pointing to a lightweight endpoint"
          ],
          "correctAnswer": 2,
          "explanation": "Auto Scaling lifecycle hooks pause instance launch at a defined point (Pending:Wait state), allowing custom actions before the instance enters service. Implementation: (1) Create lifecycle hook for instance launch, (2) Application signals completion using complete-lifecycle-action API or CloudWatch Event after initialization, (3) Only then does instance enter InService state and receive ALB traffic. This ensures full application readiness before traffic. Option A (longer health checks) delays detection of unhealthy instances but doesn't prevent initial traffic to unready instances. Option B (connection draining) handles in-flight requests during instance termination, not launch. Option D (lightweight health check) makes the problem worse - instance passes health check faster while still initializing. Alternative: Use ALB health check path requiring complete initialization (e.g., /health that verifies all dependencies), but lifecycle hooks provide better control. Lifecycle hooks support up to 2-hour wait time. Use SNS/SQS notifications to trigger initialization workflows."
        },
        {
          "id": "D2-T2.4-Q3",
          "question": "A video processing application uses SQS queue feeding Lambda functions. Processing a video takes 3 minutes on average, but the Lambda timeout is 15 minutes. Occasionally, messages are processed multiple times causing duplicate video outputs. What is the ROOT cause and solution?",
          "options": [
            "SQS visibility timeout (30 seconds default) is too short; increase to 15 minutes (6x max Lambda timeout)",
            "Lambda is not deleting messages after processing; add explicit DeleteMessage call",
            "SQS message retention is too long; reduce retention period",
            "Use SQS FIFO queue instead of standard queue to prevent duplicates"
          ],
          "correctAnswer": 0,
          "explanation": "SQS visibility timeout controls how long a message is invisible after a consumer receives it. If processing isn't complete before visibility timeout expires, the message becomes visible again and another consumer receives it, causing duplicate processing. For Lambda: (1) Lambda automatically manages message deletion on successful completion, (2) Visibility timeout must be >= 6x Lambda timeout to account for retries (Lambda retries twice on failure), (3) For 15-minute Lambda timeout, visibility timeout should be 15 × 6 = 90 minutes (maximum allowed is 12 hours). Option B is incorrect - Lambda event source mapping automatically deletes messages on successful processing. Option C (retention) controls how long messages stay in queue if unprocessed, not related to duplicates. Option D (FIFO) provides exactly-once processing within a 5-minute deduplication window but adds complexity and has lower throughput (3000 msg/sec vs standard's unlimited). Solution: Set visibility timeout = Lambda timeout × 6 in SQS queue configuration or event source mapping."
        },
        {
          "id": "D2-T2.4-Q4",
          "question": "A microservices application uses Network Load Balancer distributing traffic to services running on EC2 instances across three AZs. They want to ensure that if an entire AZ fails, traffic is only routed to healthy AZs. Which NLB configuration provides this?",
          "options": [
            "Enable cross-zone load balancing on the NLB",
            "Disable cross-zone load balancing and configure health checks with fast failover",
            "Use Route 53 health checks monitoring each AZ's NLB node",
            "Configure NLB with target group health checks and deregistration delay of 0 seconds"
          ],
          "correctAnswer": 1,
          "explanation": "With NLB cross-zone load balancing DISABLED: Each NLB node (one per AZ) routes traffic only to targets in its own AZ. If an AZ fails: (1) The NLB node in that AZ becomes unavailable, (2) DNS/routing directs traffic to NLB nodes in healthy AZs, (3) Those nodes route to targets in their respective (healthy) AZs only. This prevents failed AZ impact. With cross-zone enabled (Option A), NLB nodes route to targets in all AZs - if an AZ fails, healthy AZ nodes try to route to failed AZ targets (causing delays/failures until health checks mark them unhealthy). Option C (Route 53) adds complexity and slower failover than NLB's built-in AZ isolation. Option D (deregistration delay) controls connection draining duration, not AZ failure handling. Trade-off: Disabling cross-zone can cause uneven traffic distribution if AZs have unequal target counts. Best practice for AZ independence: Disable cross-zone for equal targets per AZ; enable for uneven distribution accepting slower AZ failure detection."
        },
        {
          "id": "D2-T2.4-Q5",
          "question": "A financial application requires that all requests are processed exactly once with strong ordering guarantees. Messages are published from multiple sources. Which combination of AWS services meets these requirements MOST cost-effectively?",
          "options": [
            "SQS FIFO queue with content-based deduplication and message group ID",
            "SQS standard queue with application-level deduplication logic",
            "Kinesis Data Streams with consumer tracking of sequence numbers",
            "EventBridge with DLQ for failed deliveries"
          ],
          "correctAnswer": 0,
          "explanation": "SQS FIFO queue provides: (1) Exactly-once processing - automatic deduplication within 5-minute window using message deduplication ID, (2) Strict ordering - messages in same message group ID are delivered in order, (3) Content-based deduplication - uses SHA-256 hash of message body as deduplication ID (no need to set manually), (4) Support for multiple message groups - different groups can be processed in parallel while maintaining order within each group. This is purpose-built for the requirement. Option B (standard queue) provides at-least-once delivery (duplicates possible) requiring complex application logic for deduplication. Option C (Kinesis) provides ordering within a shard and at-least-once delivery, but requires managing checkpoints and is more complex/expensive for simple queue use cases. Option D (EventBridge) provides at-least-once delivery. FIFO queue limitations: 3000 messages/second (with batching, 300 ops/second otherwise), higher cost than standard queue. Use message group ID strategically for parallel processing while maintaining order."
        },
        {
          "id": "D2-T2.4-Q6",
          "question": "A latency-sensitive application uses Application Load Balancer with connection draining. During deployments, users experience intermittent errors. Analysis shows the application gracefully handles in-flight requests but the default 300-second deregistration delay is too long. What configuration optimizes deployments?",
          "options": [
            "Reduce deregistration delay to match application's maximum request duration (e.g., 60 seconds)",
            "Increase deregistration delay to 900 seconds for safer draining",
            "Set deregistration delay to 0 seconds for fastest deployment",
            "Use connection draining with sticky sessions to maintain user connections"
          ],
          "correctAnswer": 0,
          "explanation": "Deregistration delay (connection draining) controls how long the ALB waits before fully deregistering a target. During this time: (1) No new connections are sent to the target, (2) Existing connections are allowed to complete, (3) After the delay expires, connections are forcibly closed. Optimal configuration: Set delay slightly longer than longest expected request duration. If application requests complete within 60 seconds, set delay to 60-90 seconds. This minimizes deployment time while preventing request interruption. Option B (900 seconds) unnecessarily prolongs deployments. Option C (0 seconds) immediately closes connections causing errors. Option D conflates two concepts - sticky sessions maintain affinity but don't affect draining duration. Best practice: Monitor CloudWatch metrics for request duration, set deregistration delay to 95th percentile request duration + buffer. For websocket applications, delay should account for longest session duration. Range: 0-3600 seconds."
        },
        {
          "id": "D2-T2.4-Q7",
          "question": "A data processing application uses Lambda functions triggered by Kinesis Data Streams. During high-volume periods, Lambda throttles occur causing processing delays. The application can tolerate 5-minute processing delays. Which configuration improves reliability? (Select TWO)",
          "options": [
            "Increase Lambda concurrent execution limit (reserved concurrency)",
            "Enable Kinesis Enhanced Fan-Out for dedicated throughput per Lambda consumer",
            "Configure Lambda event source mapping with batch size of 10,000",
            "Enable Lambda function parallelization factor on the event source mapping",
            "Increase Kinesis shard count to handle higher throughput",
            "Configure Lambda retry attempts to 0 to prevent duplicate processing"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            3
          ],
          "explanation": "For Lambda + Kinesis reliability: (1) Enhanced Fan-Out provides 2 MB/sec dedicated read throughput per consumer (vs shared 2 MB/sec per shard with standard iterators), preventing consumer competition and read throttling, (2) Parallelization factor (1-10) allows multiple Lambda invocations processing from the same shard simultaneously, increasing processing throughput. With factor=10, one shard can invoke up to 10 Lambdas concurrently. These address throughput limitations. Option A (reserved concurrency) helps if Lambda concurrency is the bottleneck but not if Kinesis read is the issue. Option C (large batch) increases efficiency but max batch size is 10,000; doesn't solve throttling. Option E (more shards) helps but is more expensive than Enhanced Fan-Out. Option F (0 retries) causes data loss on failures. Enhanced Fan-Out costs more but critical for multiple consumers. Parallelization factor requires Lambda functions to be idempotent (out-of-order processing possible within shard)."
        },
        {
          "id": "D2-T2.4-Q8",
          "question": "A global application uses CloudFront with multiple origin endpoints (US, EU, APAC) based on viewer geography. During regional failures, requests should failover to the nearest healthy origin. Which CloudFront configuration achieves this?",
          "options": [
            "Use CloudFront origin groups with primary and secondary origins, configuring failover status codes (5xx, 4xx)",
            "Use Route 53 latency-based routing behind CloudFront origins",
            "Configure CloudFront with Lambda@Edge selecting origin based on viewer location and health",
            "Use CloudFront origin access control with health check monitoring"
          ],
          "correctAnswer": 0,
          "explanation": "CloudFront origin groups provide native origin failover: (1) Create origin group with primary and secondary origins, (2) Configure failover criteria (HTTP status codes: 500, 502, 503, 504, 403, 404 - customizable), (3) If primary origin returns failover status code, CloudFront automatically tries secondary origin, (4) Can nest multiple origin groups for multi-level failover. For geographic distribution: Create behavior patterns routing based on headers/paths to different origin groups, each with primary/secondary. Option B (Route 53) behind origins works but adds DNS propagation delay; CloudFront origin groups provide faster failover at edge. Option C (Lambda@Edge) can implement custom logic but is more complex and costly than native origin groups. Option D misunderstands - origin access control (OAC) is for securing S3 origins, not failover. Origin groups check pattern: Primary fails (5xx) → Try secondary → If secondary fails → Return error to viewer. Use CloudWatch metrics to monitor origin health and failover events."
        },
        {
          "id": "D2-T2.4-Q9",
          "question": "A mobile application backend uses DynamoDB with provisioned capacity. Traffic is unpredictable with occasional spikes to 10x normal throughput lasting 5-10 minutes. They want to avoid throttling during spikes without over-provisioning. What is the MOST cost-effective solution?",
          "options": [
            "Switch to DynamoDB on-demand capacity mode",
            "Keep provisioned mode and enable DynamoDB auto scaling with target utilization of 70%",
            "Keep provisioned mode and enable DynamoDB burst capacity (automatic)",
            "Increase provisioned capacity to 10x normal throughput"
          ],
          "correctAnswer": 1,
          "explanation": "DynamoDB auto scaling with provisioned capacity provides: (1) Automatically adjusts provisioned capacity based on actual utilization, (2) Scales up when utilization exceeds target (70% default), (3) Scales down during low usage, saving costs vs fixed high capacity, (4) Can handle spikes up to 2x current capacity using burst capacity while auto scaling adjusts, (5) More cost-effective than on-demand for predictable baseline with occasional spikes. Option A (on-demand) works but is more expensive if you have a predictable baseline throughput; on-demand costs ~5x more per request. Use on-demand for truly sporadic, unpredictable traffic. Option C (burst capacity) is automatic but limited to 300 seconds of unused capacity; insufficient for sustained spikes. Option D (10x provisioning) wastes money during normal periods. Best practice: Provisioned + auto scaling for workloads with identifiable baseline; on-demand for highly variable/unpredictable workloads with no baseline. Auto scaling can take a few minutes to adjust, hence target utilization of 70% provides buffer."
        },
        {
          "id": "D2-T2.4-Q10",
          "question": "A serverless application uses API Gateway invoking Lambda functions. During sudden traffic spikes, Lambda concurrent execution limit is reached, causing 429 throttling errors. The application can handle 500 concurrent requests maximum. What configuration prevents service degradation?",
          "options": [
            "Enable API Gateway throttling at 500 requests per second",
            "Configure Lambda reserved concurrency of 500 for the function",
            "Enable API Gateway caching to reduce Lambda invocations",
            "Use Lambda provisioned concurrency of 500"
          ],
          "correctAnswer": 1,
          "explanation": "Lambda reserved concurrency guarantees that exactly that amount of concurrency is available for the function and prevents it from using more (protecting other functions/accounts from noisy neighbor). Setting reserved concurrency of 500: (1) Ensures the function can handle 500 concurrent requests, (2) Prevents exceeding capacity (which would cause failures), (3) Protects account-level concurrency for other functions. Important: Regional concurrent execution limit is 1000 by default (can be increased). Reserved concurrency allocates from this pool. Option A (API Gateway throttling) limits requests per second, not concurrency. RPS and concurrency are different: RPS × duration = concurrency. Option C (caching) reduces load but doesn't guarantee capacity. Option D (provisioned concurrency) pre-warms functions for low latency but doesn't limit concurrency - can still exceed capacity and throttle. Reserved concurrency = ceiling; provisioned concurrency = warm floor. Best practice: Set reserved concurrency to protect critical functions; use provisioned concurrency for latency-sensitive functions."
        },
        {
          "id": "D2-T2.4-Q11",
          "question": "A real-time analytics application processes streaming data from Kinesis Data Streams using Lambda. They observe that during processing failures, the same records are retried multiple times, then eventually moved to the Dead Letter Queue (DLQ). They want failed records to be retried with exponential backoff before moving to DLQ. How should this be configured?",
          "options": [
            "Configure Lambda event source mapping with maximum retry attempts and maximum record age",
            "Implement exponential backoff logic in the Lambda function code",
            "Configure Lambda destination for on-failure events pointing to SQS for retry logic",
            "Use Kinesis Data Streams retention period to allow re-processing"
          ],
          "correctAnswer": 0,
          "explanation": "Lambda event source mapping for streams (Kinesis, DynamoDB Streams) provides configurable retry behavior: (1) Maximum retry attempts - how many times to retry failed batches (-1 = retry until record expires or processed), (2) Maximum record age - discard records older than this (seconds), (3) On-failure destination - where to send records after retries exhausted, (4) Bisect on function error - split failed batches to isolate bad records. Lambda implements exponential backoff automatically between retries. Configuration ensures: Records are retried with backoff, old records don't retry forever (record age), failed records go to DLQ after max attempts. Option B (code-level backoff) doesn't apply - Lambda retries are automatic. Option C (destinations) can send failure info but doesn't configure retry logic. Option D (retention) keeps records in stream but doesn't control retry behavior. Best practice: Set max record age to prevent retrying very old data; set max retry attempts based on failure tolerance; use bisect on error to isolate poisonous messages."
        },
        {
          "id": "D2-T2.4-Q12",
          "question": "A multi-tier application uses Auto Scaling groups for web and application tiers. During scale-in events, instances are terminated immediately even though connections are still active. What configuration ensures graceful shutdown? (Select TWO)",
          "options": [
            "Configure Auto Scaling lifecycle hooks to delay termination, allowing application to finish processing",
            "Enable connection draining on the load balancer with appropriate timeout",
            "Set Auto Scaling termination policy to OldestInstance",
            "Implement application-level shutdown logic responding to SIGTERM signals",
            "Use Auto Scaling scheduled actions to prevent scale-in during business hours",
            "Configure health check grace period to delay termination"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            3
          ],
          "explanation": "Graceful shutdown requires: (1) Auto Scaling lifecycle hook (terminating:wait) - pauses termination, allowing custom logic. Application completes requests, saves state, then signals completion via complete-lifecycle-action API. Default timeout is 1 hour (max: 48 hours for scale-in). (2) Application handles SIGTERM - when EC2 receives shutdown, it sends SIGTERM to processes. Application should catch this signal, stop accepting new work, complete in-flight work, and exit gracefully. Combined approach: Lifecycle hook provides time, application handles signal properly. Option B (connection draining) is ALB feature for deregistration, applies when instance is removed from target group but doesn't delay Auto Scaling termination. Option C (termination policy) selects which instance to terminate, doesn't affect graceful shutdown. Option E (scheduled actions) is a workaround, not a solution. Option F (health check grace period) prevents premature health check failures during launch, not relevant to termination. Best practice: Lifecycle hook + SIGTERM handling + ELB connection draining for complete graceful shutdown."
        },
        {
          "id": "D2-T2.4-Q13",
          "question": "An application uses EventBridge to route events from multiple sources to various targets (Lambda, SQS, SNS). During outages, some events are lost. They need guaranteed event delivery with the ability to replay events for up to 30 days after failures are resolved. What should they implement?",
          "options": [
            "Enable EventBridge Archive for the event bus, configure retention of 30 days, and use Replay to reprocess events after outage resolution",
            "Configure EventBridge to use SQS as a target with 14-day message retention",
            "Enable CloudTrail to log all events for replay",
            "Use EventBridge global endpoints for automatic failover"
          ],
          "correctAnswer": 0,
          "explanation": "EventBridge Archive and Replay provides event sourcing capabilities: (1) Archive captures all events matching filter patterns (or all events), (2) Stores events for specified retention (up to indefinite), (3) Replay allows reprocessing archived events to configured targets, (4) Useful for disaster recovery, testing, and auditing. After resolving outages: Create a replay specifying time range, EventBridge reprocesses archived events to targets. Option B (SQS) only provides 14-day retention (extended queue) and doesn't help with events already delivered and failed. Option C (CloudTrail) logs API calls, not application events in EventBridge. Option D (global endpoints) provides regional failover but doesn't solve event replay after resolution. Archive configuration: Specify event pattern filter (archive specific events or all), retention period, and encryption. Replay: Select archive, time window, and destination event bus. Events are replayed in order with original timestamps preserved but delivery occurs at replay time. Use case: After fixing bug in Lambda consumer, replay last 24 hours of events."
        },
        {
          "id": "D2-T2.4-Q14",
          "question": "A latency-sensitive application requires database query latency under 10ms with high throughput. The application reads heavily (90% reads, 10% writes) with strong consistency requirements. Which database solution meets these requirements?",
          "options": [
            "DynamoDB with DynamoDB Accelerator (DAX) using strongly consistent reads",
            "ElastiCache for Redis with cluster mode enabled and read replicas",
            "Aurora MySQL with read replicas using read endpoints",
            "RDS PostgreSQL with Multi-AZ and read replicas"
          ],
          "correctAnswer": 0,
          "explanation": "DynamoDB + DAX provides: (1) DAX caches DynamoDB reads with microsecond latency (well under 10ms), (2) Supports both eventually consistent and strongly consistent reads from DAX cache, (3) Write-through cache automatically updated on writes, (4) Scales to millions of requests per second. For strongly consistent reads, DAX uses consistent read against DynamoDB, caching the result. Option B (Redis) achieves low latency but doesn't natively provide strong consistency with cross-region scenarios (though single-region reads from primary are consistent). Option C (Aurora read replicas) provides read scaling but replica lag means replicas have eventual consistency; only primary provides strong consistency. Option D (RDS PostgreSQL) similar issue plus higher latency than DAX. Trade-off: DAX strongly consistent reads have slightly higher latency than eventually consistent reads (still sub-10ms) because they bypass certain cache layers. DAX cluster: Primary node handles writes, multiple read replicas for read scaling. Use TTL settings to control cache freshness. For pure cache use case without DynamoDB table, use ElastiCache; DAX is optimized for DynamoDB acceleration."
        },
        {
          "id": "D2-T2.4-Q15",
          "question": "A video streaming application uses CloudFront with S3 origin. During popular live events, the S3 origin returns 503 errors due to request rate exceeding S3 limits. What architecture change prevents origin overload?",
          "options": [
            "Enable S3 Transfer Acceleration to handle higher request rates",
            "Configure CloudFront with origin shield to reduce requests to S3 origin",
            "Use multiple S3 buckets with CloudFront origin groups for load distribution",
            "Enable S3 request rate performance optimization with randomized key prefixes"
          ],
          "correctAnswer": 1,
          "explanation": "CloudFront Origin Shield acts as an additional caching layer between edge locations and origin: (1) All requests from all edge locations in a region go through Origin Shield, (2) Origin Shield consolidates requests, significantly reducing load on origin, (3) Improves cache hit ratio - if one edge requests content, all edges benefit from Shield's cache, (4) Reduces origin's request rate by 40-80% typically. Perfect for S3 origins with rate limit concerns. Option A (Transfer Acceleration) is for faster uploads to S3, not for request rate handling. Option C (multiple buckets) adds operational complexity; S3 auto-scales but Shield is simpler solution. Option D (randomized prefixes) helps distribute requests across S3 partitions but Origin Shield provides better protection. Origin Shield cost: Per 10,000 requests + per GB data transfer. Enable in CloudFront origin settings by selecting Origin Shield region (usually same as origin region). Best practice: Use Origin Shield for origins with limited request capacity or high cost per request (compute origins, third-party APIs)."
        },
        {
          "id": "D2-T2.4-Q16",
          "question": "A financial application must guarantee that SNS notifications are delivered to all subscribers even during service interruptions. Some subscribers are SQS queues, others are Lambda functions, and some are HTTPS endpoints. Which configuration ensures reliable delivery? (Select TWO)",
          "options": [
            "Configure SNS subscription filter policies to ensure relevant messages reach each subscriber",
            "Enable SNS DLQ for each subscription to capture failed deliveries for retry",
            "Use SNS message archiving to store all messages for 30 days",
            "Configure SNS delivery retry policies with exponential backoff for HTTPS endpoints",
            "Replace SNS with EventBridge for guaranteed delivery",
            "Enable SNS FIFO topics for ordered delivery"
          ],
          "type": "multiple",
          "correctAnswer": [
            1,
            3
          ],
          "explanation": "SNS reliable delivery requires: (1) Dead Letter Queue (DLQ) per subscription - when deliveries fail after retries, messages go to DLQ (SQS queue) where they can be processed after resolving issues. DLQ prevents message loss. (2) Delivery retry policies - SNS automatically retries failed deliveries with exponential backoff. For HTTPS endpoints, configure retry policy parameters (number of retries, min/max delay, backoff function). These ensure delivery attempts continue, with DLQ catching ultimate failures. Option A (filter policies) routes messages but doesn't improve reliability. Option C doesn't exist - SNS doesn't have message archiving (EventBridge has Archive). Option E (EventBridge) provides archival/replay but SNS is sufficient for this use case with proper DLQ config. Option F (FIFO topics) provides ordering but doesn't improve delivery reliability over standard topics. SNS delivery guarantees by endpoint type: SQS/Lambda (high durability, automatic retries), HTTPS (best-effort, configure retries), SMS/Email (best-effort). Always configure DLQ for critical subscriptions. Monitor DLQ depth in CloudWatch."
        }
      ]
    },
    {
      "filename": "domain-3-task-3.1-operational-excellence.json",
      "domain": "Domain 3: Continuous Improvement for Existing Solutions",
      "task": "Task 3.1: Operational Excellence",
      "question_count": 12,
      "questions": [
        {
          "id": "D3-T3.1-Q1",
          "question": "A company needs to query application logs across 100 AWS accounts to troubleshoot a distributed transaction failure. Logs are stored in CloudWatch Logs in each account. Which approach provides the FASTEST query capability across all accounts?",
          "options": [
            "Use CloudWatch Logs Insights with cross-account cross-region functionality",
            "Export all logs to S3 and query with Athena",
            "Use CloudWatch Logs subscription filters sending to centralized Kinesis Data Streams",
            "Manually query each account's CloudWatch Logs individually"
          ],
          "correctAnswer": 0,
          "explanation": "CloudWatch Logs Insights supports cross-account, cross-region queries directly. You can select multiple log groups across accounts and regions in a single query, making it the fastest approach for ad-hoc troubleshooting. Setup requires: (1) Create a monitoring account, (2) Set up resource links in each source account, (3) Query from the monitoring account selecting all relevant log groups. Logs Insights uses a SQL-like query language with automatic field discovery. Option B (S3 + Athena) has export delay and requires data to be in S3 first - slower for real-time troubleshooting. Option C (Kinesis) is for streaming processing, not interactive queries. Option D is impractical for 100 accounts. CloudWatch Logs Insights pricing is per GB scanned, making it cost-effective for targeted queries. Use saved queries and dashboards for recurring analysis. The cross-account feature simplifies centralized monitoring without complex ETL pipelines."
        },
        {
          "id": "D3-T3.1-Q2",
          "question": "An application uses X-Ray for distributed tracing. The development team reports that trace data for failed requests is incomplete, missing segments from downstream Lambda functions. What is the MOST likely cause and solution?",
          "options": [
            "X-Ray sampling rate is too low; increase to 100% for all requests",
            "Lambda functions don't have X-Ray tracing enabled; enable active tracing on Lambda functions",
            "X-Ray SDK is not initialized in Lambda code; add X-Ray SDK initialization",
            "IAM role for Lambda lacks xray:PutTraceSegments permission"
          ],
          "correctAnswer": 1,
          "explanation": "Lambda requires explicit enablement of X-Ray active tracing either: (1) In Lambda console/CLI with TracingConfig mode: Active, or (2) Via infrastructure as code (CloudFormation, SAM, CDK). Without active tracing enabled, Lambda doesn't send trace segments to X-Ray even if the X-Ray SDK is in the code. When active tracing is enabled, Lambda automatically: patches HTTP requests, sends trace data, provides environment variables (AWS_XRAY_DAEMON_ADDRESS). Option A (sampling) wouldn't cause missing segments; sampling decisions are made at request entry - if a request is traced, all segments should appear. Option C is incorrect because Lambda's active tracing mode automatically instruments common libraries without SDK initialization (though SDK provides more features). Option D would cause permission errors logged in CloudWatch, not silently missing segments. Best practice: Enable active tracing on all Lambda functions in distributed traces, use X-Ray SDK for custom subsegments and annotations. Check X-Ray service map to visualize request flow and identify missing components."
        },
        {
          "id": "D3-T3.1-Q3",
          "question": "A company wants to automate patching of 500 EC2 instances across multiple accounts, with different maintenance windows for production (Sundays 2AM) and development (daily 2AM). Failed patches should trigger alerts. Which solution provides the MOST operationally efficient approach?",
          "options": [
            "Use Systems Manager Patch Manager with patch baselines, maintenance windows, and SNS notifications for compliance",
            "Create Lambda functions with CloudWatch Events (EventBridge) to trigger yum/apt update commands",
            "Manually apply patches during maintenance windows using SSH",
            "Use third-party patch management tools integrated with AWS"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Systems Manager Patch Manager provides comprehensive, native patch management: (1) Patch baselines define which patches to install (security, critical, all), (2) Maintenance windows specify when patching occurs with different schedules per environment, (3) Run commands execute patching across instance groups (tags), (4) Patch compliance reporting shows which instances are compliant, (5) SNS integration for alerts on patch failures, (6) AWS-managed patch baselines updated by AWS as new patches release, (7) Support for cross-account patching with Organizations integration. For this scenario: Create maintenance window for production (Sunday 2AM, tagged Env=prod) and development (daily 2AM, tagged Env=dev). Associate patch baseline (e.g., AWS-DefaultPatchBaseline). Patch Manager handles orchestration, reboot, and compliance reporting. Option B (Lambda + EventBridge) requires custom code for patching logic, error handling, and reporting. Option C is not scalable or automatable. Option D adds cost and complexity. Patch Manager also supports custom patch baselines, testing patches before production (install-override list), and integration with Change Manager for change approval workflows."
        },
        {
          "id": "D3-T3.1-Q4",
          "question": "An operations team receives hundreds of CloudWatch Alarms daily, many from transient issues that self-resolve. They want alarms only when multiple related metrics indicate a real problem (e.g., high CPU AND high error rate AND high latency). Which CloudWatch feature addresses this?",
          "options": [
            "Create composite alarms combining multiple alarms with AND/OR logic",
            "Increase alarm evaluation periods to reduce false positives",
            "Use CloudWatch anomaly detection on each metric",
            "Configure SNS filter policies to suppress duplicate notifications"
          ],
          "correctAnswer": 0,
          "explanation": "CloudWatch composite alarms allow combining multiple alarms using boolean logic (AND, OR, NOT). For this scenario: Create individual alarms for CPU (>80%), error rate (>5%), and latency (>2s). Then create a composite alarm: ALARM when (CPUAlarm AND ErrorRateAlarm AND LatencyAlarm). The composite alarm triggers only when all three conditions are true simultaneously, reducing false positives from isolated metric spikes. Composite alarms support: nested composition (composite alarms referencing other composite alarms), up to 100 alarm rules, suppression of underlying alarm notifications (preventing alert fatigue). Option B (longer evaluation periods) may miss short-duration but severe issues. Option C (anomaly detection) helps identify unusual patterns but doesn't correlate multiple metrics. Option D (SNS filtering) suppresses notifications but doesn't change alarm logic. Use composite alarms for: complex failure scenarios requiring multi-metric correlation, reducing alert fatigue, implementing service-level indicators (SLIs) requiring multiple metrics. Configure different thresholds for warning (2 of 3) vs critical (all 3) composite alarms."
        },
        {
          "id": "D3-T3.1-Q5",
          "question": "A DevOps team manages infrastructure changes via CloudFormation but notices stacks showing DRIFT even though no manual changes were made. Investigation shows that some resources (security groups, IAM roles) were modified outside CloudFormation by automation scripts. How should they prevent and detect this?",
          "options": [
            "Run CloudFormation drift detection daily and automatically update stacks to fix drift",
            "Implement AWS Config rules to prevent changes to CloudFormation-managed resources and alert on violations",
            "Use CloudFormation Stack Policy to prevent updates to critical resources",
            "Delete and recreate stacks monthly to eliminate drift"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Config rules provide preventive and detective controls for drift: (1) Create custom Config rules checking if resources are managed by CloudFormation (using cloudformation:stack-id tag or GetStackResources API), (2) Config rule evaluates on configuration changes, (3) Non-compliant resources (modified outside CloudFormation) trigger alerts via SNS, (4) Optional: Use Config remediation actions with Systems Manager Automation to revert unauthorized changes. This prevents drift by alerting immediately when out-of-band changes occur, allowing quick correction. Option A (auto-update stacks) is risky - drift might be intentional for valid reasons; automatic updates could revert legitimate emergency changes. Option C (Stack Policy) prevents CloudFormation updates but doesn't prevent external changes. Option D (recreation) causes unnecessary downtime. Best practice: (1) Tag CloudFormation-managed resources consistently, (2) Use Config to monitor for external changes, (3) Educate teams to make changes through CloudFormation only, (4) Run drift detection before stack updates to avoid conflicts. For preventing changes entirely: use SCPs denying API calls without CloudFormation role, or IAM policies restricting manual changes."
        },
        {
          "id": "D3-T3.1-Q6",
          "question": "A company uses AWS Service Catalog to provision pre-approved infrastructure for development teams. They want to ensure launched products (VPCs, databases) remain compliant with organizational standards over their lifecycle, detecting drift from the original portfolio configuration. What should they implement?",
          "options": [
            "Use AWS Config rules to monitor Service Catalog launched resources for compliance",
            "Enable Service Catalog TagOptions to track provisioned products",
            "Use CloudFormation drift detection on underlying stacks",
            "Implement AWS CloudTrail logging for Service Catalog actions"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Config provides ongoing compliance monitoring for Service Catalog-launched resources: (1) Service Catalog products are deployed via CloudFormation stacks, (2) Config rules evaluate these stacks' resources against compliance requirements (encryption, tagging, network configs), (3) Config detects configuration changes over time, reporting non-compliance, (4) Service Catalog integrates with Config for governance at scale. Example rules: ensuring S3 buckets have encryption, RDS has backups enabled, EC2 in approved VPCs. Option B (TagOptions) helps with organization and cost allocation but doesn't monitor compliance. Option C (drift detection) shows changes from original template but requires manual triggering and doesn't evaluate against compliance policies. Option D (CloudTrail) logs actions but doesn't evaluate compliance. Service Catalog best practices: (1) Define constraints in portfolios (launch constraints, tag update constraints), (2) Use Config for continuous monitoring, (3) Integrate with AWS Budgets for cost control, (4) Use CloudFormation StackSets to update products across accounts. Service Catalog constraints can enforce things like specific IAM roles, required tags, and resource limits at launch time."
        },
        {
          "id": "D3-T3.1-Q7",
          "question": "An application generates high-cardinality custom metrics (unique customer IDs as dimensions) in CloudWatch, resulting in thousands of metric streams and high costs. Which approach optimizes cost while maintaining observability?",
          "options": [
            "Use CloudWatch embedded metric format (EMF) in application logs, extracting metrics only when needed for queries",
            "Continue publishing all metrics but increase aggregation period from 1 minute to 5 minutes",
            "Store custom metrics in DynamoDB instead of CloudWatch",
            "Publish metrics to S3 and use Athena for analysis"
          ],
          "correctAnswer": 0,
          "explanation": "CloudWatch Embedded Metric Format (EMF) provides cost-effective high-cardinality metrics: (1) Application logs structured JSON to CloudWatch Logs with metric metadata, (2) Metrics are extracted automatically from logs, appearing in CloudWatch Metrics, (3) You only pay for log storage ($0.50/GB ingested) instead of custom metrics ($0.30 per metric), (4) High-cardinality dimensions (customer IDs) can be included in logs without creating thousands of metric streams, (5) CloudWatch Logs Insights can query logs with full dimensionality. EMF is ideal for: high-cardinality metrics, metrics from serverless functions (Lambda automatically uses EMF), scenarios where not all dimensions are queried regularly. Option B (longer aggregation) saves some storage but loses granularity and doesn't address cardinality. Option C (DynamoDB) requires custom code for metric collection, querying, and visualization - reinventing CloudWatch. Option D (S3/Athena) has query latency unsuitable for real-time dashboards. EMF format example: {\"_aws\": {\"CloudWatchMetrics\": [{\"Namespace\": \"App\", \"Metrics\": [{\"Name\": \"Latency\"}], \"Dimensions\": [[\"CustomerId\"]]}]}, \"CustomerId\": \"12345\", \"Latency\": 145}. This appears as both a log entry and a CloudWatch metric."
        },
        {
          "id": "D3-T3.1-Q8",
          "question": "A company runs a multi-tier application with ALB, ECS, and RDS. They want automated remediation when: ALB returns 5XX errors, ECS tasks restart frequently, or RDS CPU exceeds 90%. Actions should include: restart tasks, scale out, or page on-call engineer. Which architecture provides this automation?",
          "options": [
            "CloudWatch Alarms triggering Lambda functions with remediation logic, using SNS for paging",
            "EventBridge rules detecting CloudWatch alarm state changes, triggering Systems Manager Automation documents for remediation and SNS for paging",
            "CloudWatch Alarms directly triggering Auto Scaling policies and SNS topics",
            "AWS Config remediation actions for non-compliant resources"
          ],
          "correctAnswer": 1,
          "explanation": "EventBridge + Systems Manager Automation provides comprehensive remediation automation: (1) CloudWatch Alarms detect issues (5XX, task restarts, high CPU), (2) Alarms change state (OK → ALARM), (3) EventBridge rule matches alarm state change events, (4) EventBridge triggers Systems Manager Automation documents with remediation logic, (5) Automation documents can: restart ECS tasks (ECS:UpdateService), modify RDS (RDS:ModifyDBInstance), invoke Lambda, execute AWS APIs, (6) SNS notifies on-call for severe issues. This architecture separates concerns: CloudWatch for detection, EventBridge for routing, Automation for remediation, SNS for human notification. Option A works but Lambda requires custom code for each remediation; Automation documents are reusable and AWS-managed. Option C (direct alarm actions) limited to Auto Scaling and SNS - can't restart tasks or modify RDS. Option D (Config remediation) for configuration compliance, not performance issues. Systems Manager Automation benefits: visual workflow editor, AWS-managed documents for common tasks (e.g., AWS-StopEC2Instance), approval steps for human validation, runbooks as code (version control). Use Automation for: self-healing (restart failed components), auto-remediation (security group fixes), operational runbooks (deployment procedures)."
        },
        {
          "id": "D3-T3.1-Q9",
          "question": "A global application uses CloudWatch dashboards for monitoring. Operations teams in different regions want customized views (US team sees US resources, EU team sees EU resources) without maintaining separate dashboards. How can this be achieved?",
          "options": [
            "Create dashboard variables allowing users to select region dynamically",
            "Duplicate dashboards per region with different resource filters",
            "Use CloudWatch cross-region functionality but manually switch regions",
            "Create a custom dashboard application querying CloudWatch APIs"
          ],
          "correctAnswer": 0,
          "explanation": "CloudWatch dashboard variables (also called dynamic dashboards) allow runtime customization: (1) Define variables for dimensions like Region, InstanceType, Environment, (2) Dashboard widgets reference variables: {region}, {instance}, (3) Users select variable values from dropdowns, (4) Dashboard updates to show selected resources. This enables a single dashboard serving multiple teams/regions. Variables support: property values (regions, AZs), dimension values from metrics, label values, custom values. For this scenario: Create variable 'region' with values [us-east-1, eu-west-1, ap-southeast-1], reference in widgets: \"AWS/EC2\" metrics for region=variable.region. Users switch regions via dropdown. Option B (duplicate dashboards) creates maintenance burden - changes must be applied to all copies. Option C still requires manual switching. Option D is unnecessary complexity. Dashboard variables are also useful for: environment selection (dev/staging/prod), application filtering (AppA/AppB), auto-scaling group selection. Combine with CloudWatch dashboard sharing and IAM permissions to provide role-based dashboard access. Variables can populate from CloudWatch Metric streams dynamically (e.g., all Auto Scaling groups in the account)."
        },
        {
          "id": "D3-T3.1-Q10",
          "question": "A company needs to inventory all EC2 instances, RDS databases, and S3 buckets across 50 AWS accounts, including configuration details (encryption, public access, tags). They need this data queryable for compliance reports. Which AWS service provides this with minimal operational overhead?",
          "options": [
            "AWS Config with aggregator for multi-account configuration tracking",
            "Custom Lambda functions querying AWS APIs and storing results in DynamoDB",
            "AWS Systems Manager Inventory for resource data collection",
            "CloudTrail logs analysis with Athena"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Config with multi-account multi-region aggregator provides comprehensive resource inventory: (1) Enable Config in all accounts to record resource configurations, (2) Create aggregator in central account collecting data from all source accounts, (3) Config tracks: resource type, creation time, relationships, configuration changes over time, (4) Config Advanced Queries use SQL to query across all accounts/regions, (5) Compliance dashboard shows aggregate compliance across organization. Example query: SELECT resourceId, resourceType, configuration.encrypted WHERE resourceType = 'AWS::RDS::DBInstance' AND configuration.encrypted = false. This identifies unencrypted RDS instances across all accounts. Option B (custom Lambda) requires significant development for API pagination, handling limits, incremental updates, and maintaining schema. Option C (Systems Manager Inventory) focuses on EC2 instance software inventory (applications, OS details), not broad AWS resource inventory. Option D (CloudTrail) logs API calls but doesn't maintain current state inventory. Config aggregator supports: up to 10,000 source accounts, retention of configuration history (up to 7 years), snapshot delivery to S3 for compliance archives. Use Config for: compliance reporting, resource tracking, change management, security audits, cross-account asset inventory."
        },
        {
          "id": "D3-T3.1-Q11",
          "question": "An application team wants to receive notifications when CloudFormation stack operations fail, succeed, or require manual intervention. They use stacks across multiple accounts and want centralized notification handling. Which solution provides this?",
          "options": [
            "Configure SNS topics per stack with subscriptions for operations team",
            "Use EventBridge rules matching CloudFormation events, routing to central SNS topic across accounts",
            "Enable CloudFormation stack notifications in each stack configuration",
            "Use CloudTrail to log CloudFormation API calls and trigger Lambda on failures"
          ],
          "correctAnswer": 1,
          "explanation": "EventBridge (CloudWatch Events) provides centralized, event-driven notifications for CloudFormation: (1) CloudFormation emits events for stack operations (create complete/failed, update complete/failed, drift detected), (2) EventBridge rules match these events using event patterns, (3) Rules can route to cross-account/cross-region targets including SNS, (4) Single SNS topic receives all CloudFormation notifications from all stacks/accounts, (5) SNS filters allow subscribers to filter by account, stack name, or operation type. Event pattern example: {\"source\": [\"aws.cloudformation\"], \"detail-type\": [\"CloudFormation Stack Status Change\"], \"detail\": {\"stack-status\": [\"CREATE_FAILED\", \"UPDATE_FAILED\"]}}. This matches only failure events. Option A (SNS per stack) requires configuring each stack individually - not scalable. Option C (stack notifications) requires manual config per stack and doesn't aggregate across accounts. Option D (CloudTrail + Lambda) adds unnecessary complexity when EventBridge provides native event matching. EventBridge benefits: event filtering (only failures, only specific stacks), transformation (customize notification format), multiple targets (SNS, Lambda, Step Functions simultaneously), cross-account event bus for central event collection. Use for: centralized operations monitoring, compliance tracking (drift detection events), integration with incident management systems."
        },
        {
          "id": "D3-T3.1-Q12",
          "question": "A company enforces tagging standards (Project, Environment, Owner) on all resources. They want automated detection and remediation: new untagged resources should be tagged automatically if possible, or notifications sent to resource owners for manual tagging. Which combination achieves this? (Select TWO)",
          "options": [
            "AWS Config rule detecting untagged resources with automatic remediation via Systems Manager Automation",
            "Service Control Policy (SCP) denying resource creation without required tags",
            "EventBridge rule detecting resource creation events, triggering Lambda to tag resources",
            "CloudFormation drift detection to identify tagging drift",
            "AWS Organizations tag policies enforcing required tags",
            "CloudWatch alarm on untagged resource count"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2
          ],
          "explanation": "Comprehensive tagging automation requires detection and remediation: (1) AWS Config rule for tag compliance - evaluates resources against tagging requirements, marks non-compliant resources. Config remediation actions trigger Systems Manager Automation to apply tags automatically (if permissions allow). (2) EventBridge rule on resource creation - detects AWS API calls creating resources (via CloudTrail), triggers Lambda to immediately tag new resources before they violate compliance. This provides real-time tagging vs Config's periodic evaluation. Option B (SCP) is preventive but blocks resource creation entirely if tags missing - too strict for scenarios where tags should be applied post-creation. Option D (drift detection) is for CloudFormation managed resources only. Option E (tag policies) validates tag keys/values but doesn't automatically remediate. Option F (CloudWatch alarm) doesn't provide remediation. Best practice: Layered approach: (1) Tag policies enforce valid values, (2) EventBridge + Lambda for immediate tagging, (3) Config for compliance detection, (4) Systems Manager Automation for remediation, (5) SCPs as last resort to prevent untagged resources in critical environments. Tag automation Lambda should: attempt to infer tags from creator identity (Owner), environment from VPC (Environment), query CMDB for Project tag, notify if tags can't be determined."
        }
      ]
    },
    {
      "filename": "domain-3-task-3.2-security-improvements.json",
      "domain": "Domain 3: Continuous Improvement for Existing Solutions",
      "task": "Task 3.2: Security Improvements",
      "question_count": 10,
      "questions": [
        {
          "id": "D3-T3.2-Q1",
          "question": "GuardDuty detects an EC2 instance communicating with a known command-and-control server. The security team wants automated response: isolate the instance, capture forensic data, and notify the security team. Which architecture provides automated incident response?",
          "options": [
            "GuardDuty finding triggers EventBridge rule → Lambda function: modifies security group to block all traffic, creates EBS snapshots, sends SNS notification",
            "Configure GuardDuty to automatically quarantine compromised instances",
            "Use Security Hub to aggregate GuardDuty findings and manually respond",
            "Create CloudWatch alarm on GuardDuty finding count and page security team"
          ],
          "correctAnswer": 0,
          "explanation": "Automated incident response requires EventBridge + Lambda orchestration: (1) GuardDuty publishes findings to EventBridge as events, (2) EventBridge rule matches specific finding types (e.g., Trojan:EC2/DNSDataExfiltration), (3) Lambda function executes response: modify instance security group to deny all ingress/egress (isolate), create EBS volume snapshots (preserve evidence), tag instance as 'quarantined', invoke Systems Manager to capture memory dump if SSM agent running, send SNS notification to security team with finding details. Option B is incorrect - GuardDuty doesn't have automatic response capabilities; it only detects and reports. Option C (Security Hub aggregation) provides centralized view but doesn't automate response. Option D (CloudWatch alarm) only notifies, doesn't remediate. Lambda function should: use least privilege IAM role, log all actions to CloudTrail for audit, create forensic S3 bucket for evidence storage (snapshots, logs), optionally invoke Step Functions for complex multi-step response workflows. Consider using AWS Security Hub's built-in automated response and remediation actions (ASFF) as an alternative to custom Lambda. For regulated environments: ensure forensic data collection complies with chain of custody requirements, use CloudFormation to deploy response automation consistently across accounts."
        },
        {
          "id": "D3-T3.2-Q2",
          "question": "A company uses AWS Macie to discover sensitive data in S3. Macie found PII in 15 out of 10,000 buckets. The security team wants automated remediation: move sensitive objects to encrypted, restricted-access buckets, and alert data owners. What should they implement?",
          "options": [
            "Macie sensitive data discovery job → EventBridge rule on findings → Lambda: copy objects to secure bucket, delete from source, notify via SNS",
            "Enable Macie auto-remediation feature to move sensitive data automatically",
            "Use S3 Batch Operations to copy objects based on Macie finding reports",
            "Create AWS Config rule to detect sensitive data and remediate via Systems Manager"
          ],
          "correctAnswer": 0,
          "explanation": "Macie automated remediation workflow: (1) Macie sensitive data discovery job analyzes S3 objects, (2) Macie publishes findings to EventBridge when PII/sensitive data detected, (3) EventBridge rule matches Macie finding events (SensitiveData:S3Object/Personal or Custom), (4) Lambda function triggered with finding metadata (bucket, object key, PII types), (5) Lambda: verifies finding severity, copies object to restricted S3 bucket (versioning enabled, MFA delete, bucket key encryption), updates object ACL to private, optionally deletes from source or tags for review, queries identity/access management to determine data owner, sends SNS notification to owner. Option B doesn't exist - Macie detects but doesn't remediate automatically. Option C (S3 Batch Operations) requires manual job creation from Macie reports - not automated. Option D (Config) is for configuration compliance, not data content analysis. Implementation considerations: Lambda function should handle large objects (use multipart copy), implement exponential backoff for S3 API limits, maintain audit log in DynamoDB (what moved, when, by whom), use S3 inventory to track object locations. For compliance: Macie classification results should drive DLP policies, integrate with data governance tools, consider AWS Clean Rooms for data sharing without exposure. Macie finding types: Financial (credit card), Personal (SSN, passport), Credentials (AWS secrets), Custom (regex patterns). Configure suppression rules to ignore false positives (test data, encrypted data)."
        },
        {
          "id": "D3-T3.2-Q3",
          "question": "Security audit reveals that ACM certificates are expiring without renewal, causing service outages. Certificates are used with ALB, CloudFront, and API Gateway. How can certificate lifecycle management be improved to prevent expirations?",
          "options": [
            "Implement EventBridge rule detecting ACM DaysToExpiry metric, triggering Lambda to renew certificates 30 days before expiration",
            "Use ACM automatic certificate renewal for publicly trusted certificates and set up CloudWatch alarms on DaysToExpiry for private certificates",
            "Migrate to AWS Certificate Manager Private CA for automated renewal",
            "Create calendar reminders for manual certificate renewal"
          ],
          "correctAnswer": 1,
          "explanation": "ACM certificate lifecycle management requires understanding automatic renewal: (1) Publicly trusted ACM certificates (domain-validated via DNS or email) renew AUTOMATICALLY if validation records remain in place. ACM attempts renewal 60 days before expiration. (2) Private certificates (issued by ACM Private CA) require manual renewal or automation. (3) Imported certificates (from external CAs) do NOT auto-renew - must be manually reimported before expiration. The solution: Ensure DNS validation records persist (CNAME for ACM validation in Route 53), monitor CloudWatch metric AWS/CertificateManager DaysToExpiry for all certificates, create CloudWatch alarm triggering SNS when DaysToExpiry < 30 for private/imported certificates, automate private certificate renewal using Lambda + ACM API RequestCertificate. Option A is incorrect - you cannot manually renew ACM-issued public certificates; ACM handles this automatically. Attempting to request new certificate for same domain creates duplicate, doesn't renew existing. Option C (ACM Private CA) is for different use case (internal certificates), not solution for publicly trusted certificates. Option D (manual reminders) is error-prone. Best practices: Use DNS validation (not email) for automatic renewal, monitor all ACM certificates in centralized account, use AWS Config rule (acm-certificate-expiration-check) to detect approaching expiration, document certificate owners and rotation procedures, for imported certificates: automate renewal with source CA and reimport via Lambda. Certificate transparency logs: ACM certificates appear in public CT logs for audit. ACM supports up to 10 SANs per certificate for efficiency."
        },
        {
          "id": "D3-T3.2-Q4",
          "question": "A company wants to continuously verify that no IAM policies grant broad permissions (Principal: *, Action: *, Resource: *) and automatically flag them for review. Which service provides this capability with minimal operational overhead?",
          "options": [
            "IAM Access Analyzer with policy validation scans",
            "AWS Config with managed rule iam-policy-no-statements-with-admin-access",
            "Custom Lambda function analyzing IAM policies daily",
            "Security Hub compliance standard checks"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Config rule 'iam-policy-no-statements-with-admin-access' continuously monitors IAM policies: (1) Evaluates IAM policies attached to users, groups, and roles, (2) Flags non-compliant policies granting admin access (Action: *, Resource: *), (3) Triggers on configuration changes (new policy, policy update), (4) Integrates with Config remediation for automated response, (5) Compliance timeline shows when violations occurred. For this use case: Enable Config in all accounts, activate managed rule, set up SNS notification on non-compliance, optionally configure remediation to detach overly permissive policies (with approval step). Option A (Access Analyzer) focuses on external resource sharing and policy validation during development, not continuous monitoring of existing policies. Option C (Lambda) requires custom code for policy parsing, IAM API pagination, and handling policy variations - reinventing Config. Option D (Security Hub) aggregates findings from Config and other services but doesn't directly evaluate policies. Config rules for IAM best practices: iam-password-policy (password requirements), iam-user-unused-credentials-check (inactive users), iam-root-access-key-check (root keys exist), access-keys-rotated (key age), mfa-enabled-for-iam-console-access (MFA on users). Use Config conformance packs to deploy multiple related rules together (e.g., 'Operational Best Practices for IAM'). Config remediation via Systems Manager Automation: AWS-DisableS3BucketPublicReadWrite, AWS-DeleteUnusedIAMRole. For preventive control: use SCPs to deny creation of policies with Action: * and Resource: *, blocking overly permissive policies at creation time (defense in depth: SCP prevents, Config detects)."
        },
        {
          "id": "D3-T3.2-Q5",
          "question": "Security team uses AWS Detective to investigate a GuardDuty finding about unusual API calls from an IAM user. They want to understand: which resources the user accessed, source IPs over time, and whether this represents privilege escalation. Which Detective capability provides this analysis?",
          "options": [
            "Detective finding groups automatically correlating related security events",
            "Detective visualizations showing IAM user activity timeline, resource access patterns, and IP address history with machine learning anomaly detection",
            "CloudTrail Insights analysis integrated into Detective",
            "VPC Flow Logs correlation in Detective"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Detective provides ML-powered security investigation with visualization: (1) Ingests CloudTrail, VPC Flow Logs, GuardDuty findings automatically, (2) Creates behavior graph showing relationships between users, roles, IP addresses, AWS resources, (3) Time-based visualizations: 'Scope time' window to view activity during investigation period, Baselines showing typical vs anomalous behavior, IP address geo-location and first-seen dates, Resource access patterns (which S3 buckets, EC2 instances, databases user accessed), API call volumes and types over time. (4) Detective uses ML to highlight unusual activities: new IP addresses, new geolocations, spike in API calls, new services accessed. For this scenario: Select IAM user in Detective console, view Activity timeline showing all API calls, examine ResourceAccessed panel for accessed resources, check IPAddress panel for source IPs with geo-location, look for PrivilegeEscalation panel highlighting suspicious permission changes. Option A (finding groups) exists but is for aggregating related findings, not detailed investigation. Option C (CloudTrail Insights) detects unusual API activity but Detective provides deeper investigation with graph visualization. Option D (Flow Logs) show network traffic, not IAM API activity. Detective investigation workflow: Start with GuardDuty finding in Detective (integrated), pivot to involved entities (user, role, resource), examine behavior during suspected time + baseline comparison, expand to related entities (which other users from same IP, what else did the user access), export findings to case management system. Detective supports up to 1 year of aggregated data for investigations. Pricing: per GB of ingested data (CloudTrail events, VPC Flow Logs, GuardDuty findings)."
        },
        {
          "id": "D3-T3.2-Q6",
          "question": "A company needs to enforce network segmentation: production workloads (subnet-prod) cannot communicate with development workloads (subnet-dev) even though both are in the same VPC. Security groups and NACLs are already configured, but audit shows some cross-environment traffic. What additional security control should be implemented?",
          "options": [
            "AWS Network Firewall with stateful rule groups blocking traffic between production and development CIDR ranges",
            "VPC Security Groups with explicit deny rules (Security Groups only support allow rules, so this won't work)",
            "AWS WAF protecting application endpoints from cross-environment access",
            "VPC Flow Logs to monitor traffic and manually block violating instances"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Network Firewall provides stateful, inline traffic inspection at VPC level: (1) Deploy Network Firewall endpoints in dedicated subnet per AZ, (2) Update route tables to route traffic through firewall endpoints, (3) Create stateful rule group with Suricata-compatible rules: 'drop ip $PROD_CIDR any -> $DEV_CIDR any' (block prod to dev), 'drop ip $DEV_CIDR any -> $PROD_CIDR any' (block dev to prod), (4) Firewall inspects packets, enforces rules, logs violations to S3/CloudWatch. Network Firewall provides defense-in-depth beyond Security Groups/NACLs: IDS/IPS capabilities (detect exploits, malware), domain filtering (block DNS queries to malicious domains), centralized rule management for complex policies, protocol enforcement (block non-standard traffic). Option B is incorrect - Security Groups are stateful whitelist only (implicit deny); you cannot create explicit deny rules (though NACLs support explicit deny, they might be insufficient if misconfured). Option C (WAF) operates at application layer (HTTP/HTTPS), not network layer - won't block TCP/UDP between subnets. Option D (Flow Logs) is detective, not preventive. Implement Network Firewall: (1) Create firewall policy with rule groups, (2) Deploy firewall in VPC, (3) Update route tables: 0.0.0.0/0 → firewall endpoint for inter-subnet routing, (4) Monitor firewall logs for denied connections, (5) Use AWS Firewall Manager to deploy Network Firewall across VPCs centrally. Use cases: segment workloads (prod/dev), comply with regulations requiring stateful inspection, block outbound traffic to unapproved destinations, inspect encrypted traffic with TLS inspection (requires certificate). Rule group types: Stateful (track connection state, bi-directional), Stateless (simple allow/deny, processed before stateful), Domain list (block/allow based on domain names)."
        },
        {
          "id": "D3-T3.2-Q7",
          "question": "CloudTrail logs show an IAM user making API calls that should not be possible given their attached policies (e.g., launching EC2 instances when user has no EC2 permissions). Investigation is needed to identify the permission source. Which IAM feature helps identify HOW the user gained these permissions?",
          "options": [
            "IAM Access Analyzer policy validation",
            "IAM policy simulator with CloudTrail event details",
            "CloudTrail Insights to detect unusual IAM activity",
            "IAM credential report showing user permissions"
          ],
          "correctAnswer": 1,
          "explanation": "IAM Policy Simulator helps debug permission issues: (1) Select IAM user/role, (2) Input specific API action (ec2:RunInstances), (3) Optionally input CloudTrail event request parameters (specific AMI, VPC), (4) Simulator evaluates: identity-based policies (attached to user), resource-based policies (e.g., AMI launch permissions), permission boundaries, SCPs, session policies (if assumed role), (5) Results show: whether action is allowed/denied, which policy statements contributed to decision, evaluation logic explaining why. For this scenario: Enter user and ec2:RunInstances action, Simulator may reveal: user assumed a role with EC2 permissions (check CloudTrail for AssumeRole), user is member of group with broad permissions, resource-based policy on AMI grants access, temporary credentials from federation had broader permissions. Policy Simulator shows complete evaluation logic following AWS's policy evaluation flowchart. Option A (Access Analyzer) validates policies for external access and policy correctness, not runtime permission evaluation. Option C (Insights) detects unusual activity but doesn't explain permission source. Option D (credential report) shows users and credential status, not permission evaluation. Debugging IAM permissions: (1) Use Policy Simulator to test access, (2) Check CloudTrail for AssumeRole calls (user may have assumed role), (3) Review all group memberships (users inherit group policies), (4) Examine resource policies (S3 bucket policies, KMS key policies may grant cross-account access), (5) Verify SCPs not restricting (though SCPs deny, not grant), (6) Check session policies if using STS assume-role with session tags. Policy evaluation order: Explicit Deny in any policy → SCP allow check → Resource-based policy allow → Identity-based policy allow → Session policy allow (if applicable) → Permission boundary allow. If action allowed anywhere and not explicitly denied, access grants."
        },
        {
          "id": "D3-T3.2-Q8",
          "question": "A company wants to implement just-in-time privileged access: developers can request temporary admin access to production accounts for incident response, access expires after 4 hours, and all actions during elevated access are logged. Which solution provides this capability?",
          "options": [
            "AWS SSO with permission sets that automatically expire after 4 hours",
            "Systems Manager Session Manager with time-limited assume-role policies and CloudTrail logging",
            "Custom workflow: developer requests via ServiceNow → Lambda creates temporary IAM user with 4-hour STS session → CloudTrail logs → Lambda deletes user",
            "IAM roles with maximum session duration of 4 hours, requested via self-service portal, activities logged to CloudTrail"
          ],
          "correctAnswer": 3,
          "explanation": "IAM roles with session duration limits provide just-in-time access: (1) Create 'BreakGlassAdmin' role with maximum session duration = 4 hours (default 1 hour, max 12 hours), (2) Trust policy allows developers to assume role (or federated users), (3) Self-service portal (API Gateway + Lambda): developer authenticates, requests access with justification, Lambda assumes role via STS, returns temporary credentials valid 4 hours, logs request to audit table, (4) CloudTrail automatically logs all API actions made with temporary credentials including role session name identifying requester, (5) Credentials expire after 4 hours, revoking access automatically. Option A (AWS SSO permission sets) have session duration but SSO doesn't support 'request access' workflow natively - permission sets are pre-assigned. Option B (Session Manager) is for interactive shell access to EC2, not for AWS API access. Option C (temporary IAM user) is overly complex - IAM users are permanent until deleted (not truly temporary), uses STS for session but still creates IAM user unnecessarily. Enhancements: Use AWS CloudFormation or CDK to deploy break-glass infrastructure, Integrate approval workflow (Step Functions): developer requests → manager approves via SNS → Lambda grants access, Use CloudWatch Events to alert security team when break-glass role assumed, Store justifications in DynamoDB for compliance audit, Implement MFA requirement for assume-role (aws:MultiFactorAuthPresent condition in role trust policy), Monitor with GuardDuty for unusual break-glass usage patterns. Session duration in STS AssumeRole API: DurationSeconds parameter (900 to 43200 seconds / 15 min to 12 hours). Role's maximum session duration setting overrides API request if API requests longer session. Audit trail: CloudTrail logs show roleSessionName identifying who assumed role, all subsequent API calls include role ARN and session name."
        },
        {
          "id": "D3-T3.2-Q9",
          "question": "Security audit reveals that CloudTrail logs are being deleted from S3 buckets in some accounts, potentially hiding malicious activity. What controls should be implemented to prevent CloudTrail log tampering? (Select TWO)",
          "options": [
            "Enable S3 Object Lock in compliance mode on CloudTrail S3 bucket with retention period",
            "Use S3 bucket policies denying all delete operations even from account root",
            "Enable MFA Delete on the CloudTrail S3 bucket",
            "Configure CloudTrail log file validation to detect modifications",
            "Use AWS Organizations to enforce CloudTrail in all accounts",
            "Store CloudTrail logs in S3 Glacier Deep Archive immediately"
          ],
          "type": "multiple",
          "correctAnswer": [
            0,
            2
          ],
          "explanation": "Preventing CloudTrail log deletion requires WORM protection: (1) S3 Object Lock in compliance mode with retention period (e.g., 7 years for SOX, 90 days minimum recommended) ensures objects cannot be deleted or modified until retention expires, even by root account. Compliance mode lock cannot be removed. (2) MFA Delete requires MFA token for object deletion or versioning changes, adding human verification step preventing automated or accidental deletion. Combined: Object Lock prevents deletion during retention, MFA Delete adds authentication layer for operations after retention. Option B (bucket policy deny delete) can be overridden by root or by changing bucket policy itself - not as secure as Object Lock. Option D (log file validation) detects tampering but doesn't prevent it (detective vs preventive control). Option E (Organizations enforcing CloudTrail) ensures trails exist but doesn't protect logs from deletion. Option F (Glacier) delays access but doesn't prevent deletion. Implementation: Create S3 bucket with versioning enabled (prerequisite for Object Lock), Enable Object Lock, Set default retention (compliance mode, 90 days), Enable MFA Delete, Bucket policy denying unencrypted uploads and non-SSL access, CloudTrail configured to use this bucket. Additional controls: Cross-account CloudTrail logging (logs from member accounts to security account bucket), CloudWatch Logs for real-time monitoring despite S3 log delays, SNS notifications on S3 bucket policy changes or Object Lock configuration changes, Regular access review for CloudTrail S3 bucket (minimize permissions). CloudTrail best practices: Organization trail (one trail for all accounts), Log file validation enabled, Encrypted with KMS CMK (audit key usage), Multi-region trail (logs from all regions to one bucket), Integrated with CloudWatch Logs for alerting. S3 Object Lock modes: Compliance (cannot be deleted even by root, for regulatory compliance), Governance (can be deleted with special permissions, for operational flexibility). Use Compliance mode for compliance requirements, Governance mode for flexible retention policies."
        },
        {
          "id": "D3-T3.2-Q10",
          "question": "A company implements infrastructure as code using CloudFormation. They want to enforce that all stacks use encrypted storage (encrypted EBS, S3 buckets with encryption, encrypted RDS) BEFORE deployment. Which approach provides pre-deployment validation?",
          "options": [
            "Use CloudFormation Hooks to validate stack templates before CREATE/UPDATE operations",
            "Enable AWS Config rules to detect non-encrypted resources after deployment",
            "Implement CI/CD pipeline step running cfn-lint to check templates",
            "Use SCPs to deny creation of unencrypted resources"
          ],
          "correctAnswer": 0,
          "explanation": "CloudFormation Hooks provide pre-deployment validation: (1) Hooks are registered with CloudFormation, (2) Hooks execute before CREATE, UPDATE, or DELETE operations on stacks, (3) Hook evaluates stack template and resources, (4) If hook returns FAILED, CloudFormation operation aborts (stack not created/updated), (5) If hook returns SUCCESS, operation proceeds. For this scenario: Create Hook checking CloudFormation template for: EBS volumes with Encrypted=true, S3 buckets with BucketEncryption configuration, RDS instances with StorageEncrypted=true. Hook Lambda function parses template, validates encryption properties, returns pass/fail. This prevents deployment of non-compliant stacks. Option B (Config rules) is detective (after deployment), not preventive. Option C (cfn-lint) is static analysis tool useful for syntax and basic validation but doesn't have context of organizational policies - would need custom rules. Option D (SCPs) prevents API calls but is organization-wide, not template-specific, and difficult to manage for complex policies. CloudFormation Hooks use cases: Policy enforcement (tagging, encryption, approved resource types), Cost control (deny expensive instance types), Security validation (no public S3 buckets, required security groups), Compliance (HIPAA, PCI-DSS resource requirements). Hooks can: Scan entire template, Evaluate specific resource types, Make API calls for external validation, Timeout after 30 seconds (plan hook execution accordingly). Deploy hooks using: CloudFormation Registry, Hooks CLI plugin, Share hooks across organization using AWS Organizations. Alternative: Use CloudFormation Guard rules (policy-as-code) to validate templates, integrated into CI/CD pipeline. Guard uses declarative rules: 'AWS::S3::Bucket { Properties.BucketEncryption exists }'. Hook vs Guard: Hooks run in CloudFormation service (required for deployment), Guard runs in CI/CD (shift-left validation). Use both for defense-in-depth: Guard in CI/CD for fast feedback, Hooks as final enforcement gate."
        }
      ]
    },
    {
      "filename": "domain-4-migration-modernization-all.json",
      "domain": "Domain 4: Accelerate Workload Migration and Modernization",
      "task": "task_4.1_migration_selection",
      "taskKey": "task_4.1_migration_selection",
      "question_count": 10,
      "questions": [
        {
          "id": "D4-T4.1-Q1",
          "question": "A company has 200 on-premises servers running mixed workloads. They need to determine migration strategy (rehost, replatform, refactor) for each workload. Which AWS service provides automated assessment with TCO calculations and migration strategy recommendations?",
          "options": [
            "AWS Application Discovery Service for inventory collection",
            "AWS Migration Evaluator (formerly TSO Logic) for right-sizing and TCO analysis with strategy recommendations",
            "AWS Migration Hub for migration tracking",
            "AWS Database Migration Service for database assessment"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Migration Evaluator provides comprehensive migration planning: (1) Agentless data collection from on-premises environment (CPU, memory, storage, network utilization), (2) Pattern analysis over 30+ days, (3) Right-sizing recommendations for AWS (EC2 instance types, storage options), (4) TCO comparison (on-premises vs AWS with 3-year projection), (5) Migration strategy recommendations based on: complexity, dependencies, quick wins vs long-term optimization. Evaluator considers: current utilization patterns, AWS pricing (On-Demand, Reserved, Savings Plans), cost of migration tools, operational efficiency gains. Option A (Application Discovery Service) collects data but doesn't provide TCO analysis or strategy recommendations. Option C (Migration Hub) tracks migrations but doesn't assess/recommend. Option D (DMS) is specific to database migration."
        },
        {
          "id": "D4-T4.1-Q2",
          "question": "Database migration assessment shows Oracle database with custom stored procedures, PL/SQL packages, and Oracle-specific features. Target is PostgreSQL on Aurora. What's the FIRST step in migration planning?",
          "options": [
            "Use AWS Database Migration Service to start replicating data immediately",
            "Run AWS Schema Conversion Tool (SCT) to analyze schema compatibility and generate conversion assessment report",
            "Manually rewrite all stored procedures in PostgreSQL",
            "Migrate to RDS Oracle first, then to Aurora PostgreSQL"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Schema Conversion Tool (SCT) is essential for heterogeneous database migration: (1) Connects to source Oracle database, (2) Analyzes schema, stored procedures, functions, triggers, (3) Generates assessment report showing: automatic conversion percentage (e.g., 85% auto-convertible), manual effort required, incompatible features, complexity score, estimated effort (person-days). (4) Converts schema to PostgreSQL equivalent, (5) Highlights items requiring manual intervention. Assessment report guides: Go/no-go decision, effort estimation, resource planning. For this scenario: SCT identifies which PL/SQL can convert automatically vs manual rewrite needed. Option A (immediate DMS) fails without schema conversion - target schema must exist before data migration. Option C (manual rewrite) without assessment is inefficient. Option D (staged migration) adds unnecessary step. Migration phases: Assess (SCT report), Convert (SCT conversion + manual fixes), Migrate data (DMS), Test, Cutover."
        },
        {
          "id": "D4-T4.1-Q3",
          "question": "A retail company must decide migration strategy for mainframe application processing transactions. Application is business-critical, poorly documented, and contains COBOL code. Which 7 R's strategy is MOST appropriate initially?",
          "options": [
            "Rehost (lift-and-shift) to EC2",
            "Refactor to microservices architecture",
            "Replatform using AWS Mainframe Modernization",
            "Retire the application and build new in cloud"
          ],
          "correctAnswer": 2,
          "explanation": "AWS Mainframe Modernization (Replatform) is appropriate for mainframe migrations: Service provides: (1) Automated refactoring (converts COBOL to Java) or Replatform (runtime environment for COBOL on AWS), (2) Managed runtime environment, (3) Migration tools, (4) Reduced risk vs full refactor. For business-critical, poorly documented system: Replatform minimizes risk - application logic stays in COBOL, runs on AWS infrastructure. Option A (Rehost) doesn't apply to mainframes - can't lift-and-shift mainframe to EC2. Option B (Refactor) is high-risk for undocumented critical system - requires understanding entire codebase. Option D (Retire/rebuild) is risky without knowing all business logic. 7 R's: Rehost (lift-and-shift), Replatform (lift-tinker-shift), Refactor (re-architect), Repurchase (move to SaaS), Retire (decommission), Retain (keep on-premises), Relocate (VMware Cloud on AWS). Mainframe modernization phases: Assess (analyze code dependencies), Refactor or Replatform (choose approach), Test (functional, performance), Train (operations team), Cutover."
        },
        {
          "id": "D4-T4.1-Q4",
          "question": "Company has 50 applications running on-premises. They want to map application dependencies to understand which applications can be migrated together in waves. Which AWS service provides this capability?",
          "options": [
            "AWS Application Discovery Service with agent-based discovery to collect server performance, network connections, and process data",
            "AWS Migration Hub for tracking only",
            "AWS Config for resource inventory",
            "Manual documentation by IT team"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Application Discovery Service maps application dependencies: Agent-based discovery: Installs agent on servers, collects system configuration, performance, network connections (which server talks to which), running processes. Agentless discovery (VMware only): Collects VM config, performance, doesn't capture network dependencies. Dependency mapping: Visualize server dependencies, identify application groups (servers that communicate together), plan migration waves (migrate dependent applications together). Integration with Migration Hub: Discovered data flows to Migration Hub, track migration status per application group. For this scenario: Agent-based discovery captures network connections, identifies 50 applications' interdependencies, groups servers by communication patterns, enables wave planning (migrate tightly coupled apps in same wave). Option B (Migration Hub) tracks migrations but doesn't discover dependencies. Option C (Config) tracks AWS resources only (not on-premises). Option D manual approach error-prone and time-consuming. Discovery data includes: server specs (CPU, RAM, disk), utilization metrics, network flows (source/destination IP, ports), running processes and applications. Use case: dependency mapping prevents breaking applications by migrating dependent components separately."
        },
        {
          "id": "D4-T4.1-Q5",
          "question": "E-commerce application uses proprietary CMS (Content Management System) hosted on-premises. AWS migration assessment suggests moving to SaaS CMS like WordPress on AWS Lightsail or managed WordPress. Which 7 R strategy is this?",
          "options": [
            "Rehost - lift and shift the proprietary CMS",
            "Repurchase - replace with SaaS or different product",
            "Refactor - rebuild the CMS on AWS",
            "Retain - keep on-premises"
          ],
          "correctAnswer": 1,
          "explanation": "Repurchase strategy replaces existing software with SaaS or commercial product: Examples: proprietary CMS → WordPress SaaS, custom CRM → Salesforce, self-managed email → Microsoft 365, on-premises HR system → Workday. Benefits: eliminate maintenance of legacy software, leverage vendor innovation, faster time-to-value, predictable subscription pricing, reduced operational burden. Trade-offs: data migration complexity, training users on new system, potential feature gaps, vendor lock-in. For this scenario: Proprietary CMS requires maintenance (security patches, feature development), WordPress SaaS eliminates operational overhead, managed WordPress on AWS (Lightsail, or third-party managed) provides WordPress benefits with AWS hosting. Repurchase migration process: (1) Evaluate SaaS alternatives (feature comparison, cost analysis), (2) Plan data migration (export from proprietary system, import to SaaS), (3) Test (functionality, integrations), (4) Train users, (5) Cutover. When to repurchase: maintaining legacy software costs high, SaaS alternative meets requirements, total cost of ownership lower, want to focus on business vs infrastructure. When NOT to repurchase: unique business requirements SaaS doesn't meet, regulatory data residency restrictions, tight legacy integration requirements."
        },
        {
          "id": "D4-T4.1-Q6",
          "question": "VMware workloads (200 VMs) need to migrate to AWS. Company wants to maintain VMware operational model and tools. Which 7 R strategy and AWS service?",
          "options": [
            "Rehost to EC2 using AWS Application Migration Service",
            "Relocate to VMware Cloud on AWS maintaining VMware environment",
            "Refactor to containers on EKS",
            "Repurchase SaaS alternatives"
          ],
          "correctAnswer": 1,
          "explanation": "Relocate to VMware Cloud on AWS for VMware workloads: VMware Cloud on AWS: VMware-managed SDDC (Software-Defined Data Center) on dedicated AWS infrastructure, same VMware tools (vCenter, vSphere, NSX, vSAN), hybrid cloud between on-premises VMware and AWS, enables vMotion to AWS (live migration without downtime). 7 R's - Relocate strategy: specifically for VMware workloads moving to VMware Cloud on AWS, retains exact VMware environment, operational continuity (same processes, tools, skills). For this scenario (200 VMware VMs, want VMware tools): Relocate preserves VMware operational model, teams use existing VMware skills, vMotion enables gradual migration, hybrid connectivity (AWS Direct Connect, VPN). Alternative (Option A - Rehost to EC2): converts VMs to EC2 instances, loses VMware management layer, operational model changes. Migration approaches comparison: Relocate (VMware Cloud on AWS): fastest for VMware, no refactoring, Option A (Rehost): convert to native EC2, new operational model. Refactor (Option C): significant development effort. Use VMware Cloud on AWS when: large VMware footprint, want operational continuity, hybrid cloud strategy, time-sensitive migration (<6 months). After stabilizing on VMware Cloud, optionally refactor to native AWS services over time."
        },
        {
          "id": "D4-T4.1-Q7",
          "question": "Legacy application has licensing tied to specific physical servers. Application cannot be easily refactored. Runs on physical server with dedicated resources. What's appropriate migration strategy?",
          "options": [
            "Rehost to EC2 dedicated host for bring-your-own-license compliance",
            "Refactor to remove licensing dependency",
            "Repurchase new licensing model",
            "Retain on-premises permanently"
          ],
          "correctAnswer": 0,
          "explanation": "Rehost to EC2 Dedicated Host for BYOL (Bring Your Own License): EC2 Dedicated Host: Physical server dedicated to your use, visibility into sockets, cores, host ID for license tracking, supports BYOL for server-bound licenses (Windows Server, SQL Server, Oracle, SAP). For this scenario (license tied to physical server): Dedicated Host provides server-level isolation needed for licensing, enables BYOL to AWS, reduces licensing costs vs acquiring new cloud licenses. Dedicated Host vs Dedicated Instance: Dedicated Host: physical server dedicated to you, socket/core visibility for licensing, host affinity (instance stays on same host), higher cost but BYOL support. Dedicated Instance: isolated instances on dedicated hardware, no visibility into physical infrastructure, cannot use with server-bound licenses. Licensing scenarios: per-socket licensing (Oracle Database): use Dedicated Host with known socket count, per-core licensing (SQL Server): Dedicated Host shows core count, per-VM licensing: regular EC2 instances sufficient. Migration process: Provision Dedicated Hosts (specify instance family, cores needed), migrate workload using MGN to Dedicated Host, maintain license compliance reporting. Alternative (Option C - repurchase): buy cloud-native licenses (expensive for legacy apps), or Option D (retain on-premises): if migration too costly."
        },
        {
          "id": "D4-T4.1-Q8",
          "question": "Application dependency mapping shows application with database tier used by multiple applications. Should database be migrated with first application or wait until all dependent applications migrate?",
          "options": [
            "Migrate database with first application, leaving it accessible to remaining on-premises applications via hybrid connectivity",
            "Wait until all applications migrate to move database",
            "Create database replica in AWS for migrated application, keep original for on-premises",
            "Retire the database entirely"
          ],
          "correctAnswer": 0,
          "explanation": "Migrate shared database early with hybrid connectivity: Shared database migration strategy: (1) Migrate database to AWS (RDS or EC2), (2) Maintain hybrid connectivity (Direct Connect or VPN), (3) On-premises applications access AWS database over hybrid connection, (4) Migrate applications incrementally, (5) Eventually all applications in AWS, decompose database later if needed. For this scenario: Database on AWS provides cloud benefits (automated backups, HA), on-premises applications continue functioning via hybrid network, enables incremental application migration. Hybrid network requirements: Low latency (<10ms for interactive apps, <50ms for batch), adequate bandwidth (based on database traffic), redundant connections (Direct Connect with VPN backup). Option B (wait for all apps) delays migration start, misses cloud benefits. Option C (replica approach) creates data synchronization complexity (writes to both? conflict resolution?), DMS bidirectional replication possible but complex. Database migration sequencing: Migrate databases early (persistent state component), applications follow incrementally, enables lift-and-shift first, optimize later pattern. Network architecture: AWS Private Link or Transit Gateway for centralized hybrid connectivity, VPC peering between AWS VPCs, Route 53 private hosted zones for DNS."
        },
        {
          "id": "D4-T4.1-Q9",
          "question": "200 applications assessed for migration. 50 can be retired (no longer used), 30 can move to SaaS, 70 can rehost, 50 need refactoring. How should migration waves be prioritized?",
          "options": [
            "Wave 1: Retire and Repurchase (quick wins, 80 apps), Wave 2: Rehost (70 apps), Wave 3: Refactor (50 apps - most complex)",
            "All applications simultaneously for fastest migration",
            "Largest applications first",
            "Most complex applications first to learn lessons"
          ],
          "correctAnswer": 0,
          "explanation": "Prioritize quick wins then increasing complexity: Wave-based migration strategy: Wave 1 (quick wins): Retire unused applications (decommission, cost savings immediate), Repurchase with SaaS (subscription setup, data migration, limited refactoring), demonstrates early value, builds organizational confidence. Wave 2 (moderate complexity): Rehost compatible applications (lift-and-shift using MGN), predictable process, accelerates migration pace, learns operational patterns in AWS. Wave 3 (highest complexity): Refactor applications requiring re-architecture, time-intensive, benefits from learnings of previous waves, team experienced with AWS by this point. For this scenario (80 quick wins available): Immediate value (retire 50 = cost savings, repurchase 30 = reduced maintenance), builds momentum and stakeholder confidence, funds subsequent waves with cost savings. Wave prioritization factors: Business value (revenue-generating apps higher priority), dependencies (migrate grouped apps together), risk (start with low-risk), technical complexity (simple to complex). Migration portfolio approach: Portfolio assessment identifies all 200 apps, categorize by 7 R's, create migration factory (repeatable process for rehost wave), allocate team resources (SaaS team, refactoring team, infrastructure team). Option B (simultaneous) overwhelming, high risk. Option C/D don't optimize for quick wins."
        },
        {
          "id": "D4-T4.1-Q10",
          "question": "Windows Server 2008 R2 applications (end of support) running on-premises. Microsoft requires Software Assurance for extended security updates on-premises. What migration strategy addresses security and licensing?",
          "options": [
            "Rehost to AWS EC2 - receive free extended security updates for legacy Windows on EC2",
            "Keep on-premises and purchase extended support from Microsoft",
            "Refactor to Linux",
            "Containerize on ECS"
          ],
          "correctAnswer": 0,
          "explanation": "AWS provides extended security updates for legacy Windows on EC2: Legacy Windows migration benefit: Windows Server 2008/2008 R2 on EC2 receives extended security updates at no additional charge (through Systems Manager), no Software Assurance required on AWS (vs on-premises requires paid extended support), simplified patching via Systems Manager Patch Manager. For this scenario (Windows 2008 R2 end-of-support): Rehost to EC2 maintains application compatibility, receives security updates in AWS without extra licensing costs, reduces security risk of unsupported OS. Migration approach: assess applications on Windows 2008 R2, migrate to EC2 using MGN (preserves Windows installation), enable Systems Manager for patch management, plan eventual OS upgrade to Windows Server 2019/2022 in AWS. AWS licensing benefits for Windows: License Mobility (reuse Windows Server licenses with Software Assurance on EC2 Dedicated Hosts), License included EC2 instances (pay per hour, includes Windows license), Extended security updates for legacy versions. Alternative modernization path: after migrating to EC2, containerize application (if suitable) to Windows containers on ECS, or refactor to Linux if application allows (Option C - but high effort). Option B keeps on-premises with paid extended support (misses cloud benefits). Extended updates via Systems Manager: automatic deployment, integrated with AWS patch baseline, CloudWatch monitoring."
        }
      ]
    },
    {
      "filename": "domain-4-migration-modernization-all.json",
      "domain": "Domain 4: Accelerate Workload Migration and Modernization",
      "task": "task_4.2_migration_approach",
      "taskKey": "task_4.2_migration_approach",
      "question_count": 12,
      "questions": [
        {
          "id": "D4-T4.2-Q1",
          "question": "Large-scale server migration (500 physical servers) requires replication-based migration with minimal downtime. Applications are heterogeneous (Windows, Linux, various databases). Which AWS service is MOST appropriate?",
          "options": [
            "AWS Application Migration Service (MGN) with continuous replication and cutover orchestration",
            "AWS Server Migration Service (SMS) - deprecated, not recommended",
            "CloudEndure Migration (now part of MGN)",
            "Manual VM export/import to EC2"
          ],
          "correctAnswer": 0,
          "explanation": "AWS Application Migration Service (MGN) is the current recommended solution for replication-based migration: (1) Agent installed on source servers, (2) Continuous block-level replication to AWS (staging area in AWS), (3) Minimal performance impact on source systems, (4) Non-disruptive testing (launch test instances without affecting replication), (5) Cutover automation (switch from source to migrated), (6) Automated conversion (source volumes to EBS, network config). MGN supports: Windows, Linux, Physical servers, VMware, Hyper-V, Azure VMs. Replication RTO: minutes (failover to already-replicated instances), RPO: seconds (near real-time replication). Option B (SMS) deprecated December 2022 - replaced by MGN. Option C (CloudEndure) was acquired by AWS, became MGN. Option D (manual) doesn't scale. MGN migration phases: Install agent, Initial sync (full replication), Continuous data replication, Test (launch test instance), Cutover (redirect traffic), Finalize (terminate replication)."
        },
        {
          "id": "D4-T4.2-Q2",
          "question": "MySQL database (5TB) must migrate from on-premises to RDS with minimal downtime (<30 minutes). Database receives constant updates. Which DMS configuration achieves this?",
          "options": [
            "DMS full load only (long downtime for 5TB)",
            "DMS full load + CDC (ongoing replication) with cutover during low-traffic window",
            "Export to S3, then import to RDS",
            "Use AWS Snowball for data transfer, then DMS for incremental sync"
          ],
          "correctAnswer": 1,
          "explanation": "DMS full load + CDC (Change Data Capture) minimizes downtime: (1) DMS replication instance created in AWS, (2) Full load begins (copy all existing data while source remains online), (3) CDC captures changes during full load (binary logs for MySQL), (4) After full load complete, CDC applies captured changes (replication lag decreases), (5) When lag is near zero (seconds), cutover: stop application, apply final changes, redirect application to RDS. Downtime = time to apply final changes + DNS/connection string update (< 30 minutes achievable). Option A (full load only) requires stopping source during entire migration (hours for 5TB). Option C (S3 export/import) similar downtime issue. Option D (Snowball) for large initial sync works but unnecessary complexity for 5TB over network. DMS CDC uses database transaction logs: MySQL binary logs, Oracle archive logs, PostgreSQL WAL. Prerequisites: binary logging enabled, appropriate permissions (replication slave for MySQL). DMS homogeneous vs heterogeneous: homogeneous (MySQL → RDS MySQL) uses native tools, heterogeneous (Oracle → PostgreSQL) requires schema conversion. DMS performance: Multi-AZ for HA, choose appropriate instance size (r5 for memory-intensive, c5 for CPU), monitor CloudWatch metrics (CDCLatencySource, CDCLatencyTarget)."
        },
        {
          "id": "D4-T4.2-Q3",
          "question": "500TB file server data must migrate to AWS. Network bandwidth: 100 Mbps (takes 5+ months). Data must be available in AWS within 2 weeks. What's the MOST efficient approach?",
          "options": [
            "Use AWS Snowball Edge devices (80TB each, 7 devices) for initial bulk transfer, then AWS DataSync for incremental sync",
            "Use AWS DataSync over VPN for entire transfer",
            "Use AWS Storage Gateway with cached volumes",
            "Use third-party tools like Aspera for faster transfer"
          ],
          "correctAnswer": 0,
          "explanation": "Snowball Edge + DataSync hybrid approach: (1) Order multiple Snowball Edge devices (80TB usable per device, 100TB raw), (2) Copy data to Snowball devices on-premises (local network speed), (3) Ship devices to AWS (AWS uploads to S3), (4) After bulk transfer complete, use DataSync to sync incremental changes and new files created during shipping, (5) Cutover when sync complete. Timeline: Snowball data copy (days), Shipping (1 week), AWS upload (days), DataSync incremental (hours/days). Total: ~2 weeks. Option B (DataSync over 100 Mbps) calculation: 500TB × 8 bits / 100 Mbps / 86400 sec/day ≈ 463 days (impossible in 2 weeks). Option C (Storage Gateway cached) doesn't solve initial transfer problem. Option D (Aspera) accelerates network transfer but still limited by 100 Mbps bandwidth. Snowball family: Snowball Edge Storage Optimized (80TB, 40 vCPUs), Snowball Edge Compute Optimized (39.5TB, 52 vCPUs, GPU), Snowmobile (up to 100PB, for exabyte-scale). When to use Snowball: >10TB data, limited bandwidth, cost (cheaper than months of high-bandwidth transfer), time-sensitive migration."
        },
        {
          "id": "D4-T4.2-Q4",
          "question": "AWS MGN (Application Migration Service) agent installation blocked by strict firewall rules. What's 2025 solution for VMware environments?",
          "options": [
            "Open all outbound ports temporarily",
            "Use MGN agentless replication for VMware (2025 feature supporting VMware vCenter 8)",
            "Manually export/import VMs",
            "Use AWS Server Migration Service"
          ],
          "correctAnswer": 1,
          "explanation": "MGN agentless replication for VMware (2025 enhancement): Agentless replication: No agent installation on source VMs, VMware vCenter integration reads VM data directly, Supports VMware vCenter 6.7, 7.0, and 8.0 (added 2025), can use proxy server for connectivity (2025 feature), supports AWS credentials update for agentless replication. Benefits: No firewall changes on source VMs, no performance impact from agent, centralized management through vCenter, suitable for security-restricted environments. Requirements: VMware vCenter access, network connectivity from MGN Connector to vCenter, VMware vSphere permissions (read VM configuration, snapshots). For this scenario (strict firewall): Agentless bypass VM-level firewall restrictions, MGN Connector communicates with vCenter (not individual VMs), maintains security posture while enabling migration. MGN Connector features (2025): Automates agent installation where allowed, supports agentless for VMware, communicates over HTTP with Windows servers, password authentication with Linux servers, deployed in on-premises or AWS environment. Option A dangerous security practice. Option C manual process doesn't scale. Option D (SMS) deprecated 2022. Agent vs Agentless comparison: Agent-based: All platforms (physical, VMware, Hyper-V, Azure), block-level replication, broader compatibility. Agentless: VMware only, VMware snapshot-based replication, no agent overhead. 2025 MGN enhancements: Amazon Linux 2023 support, Rocky Linux 9.0 support, UEFI boot mode retention, kernel up to 6.5."
        },
        {
          "id": "D4-T4.2-Q5",
          "question": "DMS Serverless vs instance-based DMS for migrating 10TB SQL Server database. DMS Serverless announced 2025 enhancements. When to use each?",
          "options": [
            "Always use DMS instance-based for control",
            "DMS Serverless for simplified management with automatic capacity scaling and April 2025 unlimited storage scaling",
            "DMS Serverless only for small databases",
            "Instance-based for all production migrations"
          ],
          "correctAnswer": 1,
          "explanation": "DMS Serverless advantages with 2025 enhancements: DMS Serverless (released 2023, with 2025 enhancements): Automatic capacity provisioning and scaling (no instance sizing needed), February 2025: Premigration assessments (evaluate migration compatibility before starting), April 2025: Automatic storage scaling (no more 100GB default limit - unlimited storage), pay-per-use billing (DMS Capacity Units - DCUs), 1 DCU = 2GB RAM. For this scenario (10TB SQL Server): Serverless automatically scales capacity based on transaction volume, April 2025 storage scaling handles 10TB without manual intervention, simplified operations (no capacity planning), cost-effective (pay only for actual usage). DMS Serverless vs Instance-based: Serverless: automatic scaling, simplified management, pay-per-use, unlimited storage (2025 enhancement), ideal for: variable workloads, unpredictable transaction volumes, simplified operations. Instance-based: fixed capacity, manual scaling, hourly pricing regardless of usage, more control over resources, ideal for: predictable workloads, specific instance requirements, consistent high throughput. Migration types supported (both): Homogeneous (SQL Server → RDS SQL Server), heterogeneous (SQL Server → Aurora PostgreSQL with SCT), full load + CDC for minimal downtime. DMS Serverless limitations: Some features still instance-only (check latest docs), generally most migrations now supported on Serverless. 2025 recommendation: Start with DMS Serverless for operational simplicity, use instance-based only if specific requirements demand it."
        },
        {
          "id": "D4-T4.2-Q6",
          "question": "Migrating NFS file server (100TB, millions of small files) to AWS. Need POSIX permissions, metadata preserved. Which service?",
          "options": [
            "AWS DataSync to Amazon EFS with metadata preservation",
            "Snowball to S3",
            "rsync to EC2",
            "AWS Storage Gateway File Gateway"
          ],
          "correctAnswer": 0,
          "explanation": "AWS DataSync to EFS for POSIX file migration: DataSync capabilities: Automated file transfer service, preserves metadata (permissions, timestamps, ownership), verifies data integrity, bandwidth throttling, scheduling (hourly, daily, weekly), encryption in transit. DataSync to EFS: Maintains POSIX permissions, preserves file metadata, directly mounts source NFS share, transfers to EFS (managed NFS service in AWS), handles millions of files efficiently, incremental transfers (only changed files). For this scenario (NFS → AWS with metadata): DataSync agent deployed on-premises, agent connects to source NFS and target EFS, transfer preserves all POSIX attributes, EFS provides managed NFS in AWS (no server management). Migration process: (1) Create EFS file system in AWS, (2) Deploy DataSync agent on-premises (VM or physical), (3) Configure DataSync task (source NFS, destination EFS, schedule), (4) Run initial full sync, (5) Incremental syncs until cutover, (6) Applications point to EFS. Option B (Snowball to S3) doesn't preserve POSIX metadata natively, S3 is object storage (not file system). Option C (rsync) works but manual, no verification, no scheduling, DataSync purpose-built. Option D (Storage Gateway File) provides hybrid access but not migration tool. DataSync vs alternatives: DataSync: Purpose-built for migration, metadata preservation, verification. Snowball: >10TB with limited bandwidth (but loses metadata). rsync: Manual, no verification. Transfer Family: For ongoing SFTP access (not bulk migration). DataSync performance: Parallelized transfer (multi-threaded), saturates available bandwidth, CloudWatch monitoring."
        },
        {
          "id": "D4-T4.2-Q7",
          "question": "Oracle database migration to Aurora PostgreSQL. SCT assessment shows 92% automatic conversion, 8% manual effort (custom PL/SQL functions). What's migration sequence?",
          "options": [
            "Use DMS directly without schema conversion",
            "SCT for schema conversion (automatic + manual fixes), then DMS for data migration with CDC",
            "Manual rewrite of entire database",
            "Keep Oracle, use RDS Oracle"
          ],
          "correctAnswer": 1,
          "explanation": "Heterogeneous migration requires SCT then DMS: Migration sequence: (1) SCT assessment report (already completed - 92% auto-convertible), (2) SCT automatic schema conversion (creates PostgreSQL schema from Oracle), (3) Manual fixes for 8% non-convertible code (rewrite custom PL/SQL functions in PL/pgSQL), (4) Test converted schema (functional testing), (5) DMS replication instance setup, (6) DMS full load + CDC (migrate data while source active), (7) Cutover when replication lag near zero. For this scenario (Oracle → PostgreSQL, 92% convertible): SCT handles bulk of conversion work automatically, 8% manual effort manageable (custom functions require developer expertise), DMS handles data migration separately from schema. SCT conversion: Converts tables, indexes, constraints, stored procedures, functions, triggers, generates PostgreSQL-compatible SQL, highlights items needing manual intervention (e.g., Oracle-specific features like hierarchical queries). Manual conversion (8%): Review SCT action items, rewrite Oracle-specific PL/SQL in PostgreSQL PL/pgSQL, leverage PostgreSQL features (e.g., CTEs for hierarchical queries), test thoroughly. DMS CDC for minimal downtime: Full load copies existing data, CDC captures ongoing changes (archive logs), apply CDC to keep synchronized, cutover when lag <seconds. Option A fails - heterogeneous requires schema conversion. Option C unnecessary - 92% auto-converts. Option D misses modernization opportunity (Aurora benefits over Oracle)."
        },
        {
          "id": "D4-T4.2-Q8",
          "question": "Windows file server with SMB shares (50TB, Active Directory integrated permissions) migrating to AWS. Need SMB protocol, AD integration. Which service?",
          "options": [
            "Amazon EFS (NFS only, no SMB)",
            "Amazon FSx for Windows File Server with AD integration",
            "S3 with SMB gateway",
            "EC2 with Windows Server file shares"
          ],
          "correctAnswer": 1,
          "explanation": "Amazon FSx for Windows File Server for SMB workloads: FSx for Windows features: Fully managed Windows file server, native SMB protocol (SMB 2.0, 3.0, 3.1.1), Active Directory integration (AWS Managed AD or self-managed AD), Windows ACLs, NTFS file system, DFS namespaces, deduplication, shadow copies. For this scenario (Windows SMB + AD permissions): FSx provides Windows-native file shares, integrates with existing AD (maintains permissions), supports all Windows features applications expect, managed service (automatic patching, backups). Migration approach: (1) Create FSx file system, (2) Join FSx to Active Directory domain, (3) Use AWS DataSync or Robocopy to migrate data, (4) Preserve ACLs and metadata, (5) Update client mount points to FSx, (6) Cutover. FSx deployment types: Single-AZ (cost-optimized, single availability zone), Multi-AZ (HA with automatic failover to standby), storage types (SSD for latency-sensitive, HDD for throughput). Option A (EFS) Linux NFS protocol, no SMB. Option C (S3) object storage, requires SMB gateway (adds complexity vs native FSx). Option D (EC2 Windows) self-managed (defeats purpose of cloud migration). FSx vs alternatives: FSx: Native Windows, fully managed, AD integrated. EC2 Windows: Self-managed, operational overhead. Storage Gateway File: Hybrid, local cache + S3, not for full cloud migration. Data migration to FSx: DataSync (automated, scheduled, verified), Robocopy (Windows native, supports ACLs), AWS Transfer Family SFTP (if coming from SFTP source)."
        },
        {
          "id": "D4-T4.2-Q9",
          "question": "Mainframe application with VSAM datasets needs migration to AWS. Data access patterns: sequential reads for batch, indexed access for online transactions. Which AWS service for data migration?",
          "options": [
            "Migrate VSAM to S3 using custom scripts",
            "AWS Mainframe Modernization with automated data migration utilities",
            "AWS DMS (doesn't support VSAM)",
            "Manual export to CSV, import to RDS"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Mainframe Modernization handles VSAM migration: Mainframe Modernization capabilities: Two patterns: Automated refactoring (COBOL → Java), Replatform (runtime for COBOL on AWS). Data migration: Converts VSAM datasets to AWS-compatible storage, supports VSAM KSDS (key-sequenced), ESDS (entry-sequenced), RRDS (relative-record), maps to relational databases or file storage based on access patterns. For this scenario (VSAM with sequential + indexed access): Automated tools analyze VSAM dataset characteristics, sequential datasets may map to S3, indexed datasets (KSDS) map to relational database with indexes, batch processes adapted to read from AWS storage. Migration process: (1) Assess mainframe applications and data dependencies, (2) Choose refactor or replatform approach, (3) Migrate code (automated conversion or runtime), (4) Migrate data (VSAM → AWS storage), (5) Test (batch + online transactions), (6) Cutover. VSAM to AWS storage mapping: KSDS (indexed) → RDS/Aurora with indexes or DynamoDB, ESDS (sequential) → S3 with file organization, RRDS (relative record) → database with sequential IDs. Option A custom scripts complex and error-prone. Option C DMS designed for database replication, not mainframe data. Option D manual CSV loses data structure and metadata. Mainframe modernization benefits: eliminate mainframe costs, cloud scalability, integrate with AWS services (Lambda, Step Functions), modern developer experience. Alternative: Partner solutions (Micro Focus, BluAge) if AWS Mainframe Modernization doesn't fit specific requirements."
        },
        {
          "id": "D4-T4.2-Q10",
          "question": "SAP system migration to AWS. Requires precise timing between application and database migration to minimize downtime. Which approach?",
          "options": [
            "Migrate database first, then application",
            "Use SAP-specific migration tools: AWS Launch Wizard for SAP or MGN for infrastructure + DMS for database with coordinated cutover",
            "Manual migration during maintenance window",
            "Migrate application first, then database"
          ],
          "correctAnswer": 1,
          "explanation": "SAP migration requires coordinated approach with SAP-specific tools: SAP migration strategies: AWS Launch Wizard for SAP: Automated SAP deployment on AWS (HANA, NetWeaver), infrastructure provisioning, HA configuration, best practices built-in. MGN + DMS approach: MGN replicates SAP application servers (continuous replication), DMS replicates SAP database (HANA, Oracle, SQL Server), coordinated cutover minimizes downtime. For this scenario (precise timing required): Parallel replication (application via MGN, database via DMS), Both remain in sync with production, Coordinated cutover: (1) Stop SAP application, (2) Final MGN sync of app servers, (3) Final DMS CDC sync of database, (4) Start SAP on AWS, (5) Validate. Downtime window: minutes (time for final sync + SAP startup). SAP on AWS considerations: Instance types (x1e for SAP HANA large memory), EBS volumes (io2 for database performance), Networking (placement groups for low latency), HA setup (Multi-AZ, HANA System Replication). Option A/D (sequential) extends downtime - database and app must migrate together (interdependent). Option C (manual) risky for complex SAP landscape. SAP migration tools: AWS Launch Wizard: Greenfield SAP deployments, automated configuration. MGN: Lift-and-shift existing SAP infrastructure. AWS Backint Agent: SAP HANA backups to S3. CloudEndure Disaster Recovery (now MGN DR): SAP HA/DR. Post-migration: SAP on AWS optimizations (autoscaling non-production, Spot for test systems, S3 for HANA backups, Reserved Instances for production)."
        },
        {
          "id": "D4-T4.2-Q11",
          "question": "Active-active database replication across on-premises and AWS during migration for zero-downtime testing. Source: MySQL, Target: Aurora MySQL. What's the architecture?",
          "options": [
            "DMS bidirectional replication between on-premises MySQL and Aurora MySQL",
            "Read-only Aurora replica, promote at cutover",
            "Periodic snapshots and restore",
            "Application writes to both databases"
          ],
          "correctAnswer": 0,
          "explanation": "DMS bidirectional replication enables active-active testing: DMS bidirectional setup: Two DMS tasks: Task 1: on-premises MySQL → Aurora (full load + CDC), Task 2: Aurora → on-premises MySQL (CDC only - full load already done). Ongoing replication keeps both databases synchronized. Use case: Gradual migration (some traffic to on-premises, some to AWS), zero-downtime testing (test AWS environment with production data), confidence building (validate performance before full cutover). For this scenario: Start with Task 1 (on-prem → Aurora) until Aurora synchronized, Enable Task 2 (Aurora → on-prem) for bidirectional, Route subset of traffic to Aurora-backed application, Monitor for conflicts (rare with DMS conflict resolution), Gradually increase traffic to AWS, Final cutover: stop on-premises writes, disable Task 2. DMS conflict detection and resolution: Detects conflicting writes (same record modified in both), resolution strategies (use latest timestamp, configurable), monitoring via CloudWatch. Trade-offs: Complexity vs unidirectional, small replication lag (async replication), potential conflicts need monitoring, operational overhead. Option B (read replica) doesn't allow writes to Aurora during testing. Option C (snapshots) not continuous, stale data. Option D (dual writes) application complexity, no conflict resolution. When to use bidirectional: gradual migration with testing, zero-downtime requirement, need to rollback easily. When NOT: application can't tolerate replication lag, write conflicts likely (highly concurrent writes to same records)."
        },
        {
          "id": "D4-T4.2-Q12",
          "question": "Tape backup library (500TB historical data) needs migration to AWS for long-term archival (10-year retention). Data rarely accessed. What's most cost-effective approach?",
          "options": [
            "Ship tapes to AWS, manually restore and upload",
            "AWS Snowball Edge to S3, then lifecycle to S3 Glacier Deep Archive",
            "AWS Storage Gateway Tape Gateway (VTL) with Glacier integration, then Snowball import of historical tapes to S3 Glacier Deep Archive",
            "DataSync to S3 Standard"
          ],
          "correctAnswer": 2,
          "explanation": "Tape Gateway + Snowball for historical tape migration: Architecture: AWS Storage Gateway Tape Gateway (VTL - Virtual Tape Library): Presents iSCSI-based VTL to backup applications, virtual tapes stored in S3 (cached tapes) or Glacier/Glacier Deep Archive (archived tapes), maintains tape catalog for restore. Historical tape migration: Ship physical tapes to AWS via Snowball, AWS imports tape data to S3 Glacier Deep Archive directly, preserves tape archive catalog, maintains retrievability for 10+ years. For this scenario (500TB, rare access, 10-year retention): Tape Gateway for ongoing backups (replaces physical tape library), historical tapes imported via Snowball (faster than network for 500TB), S3 Glacier Deep Archive cheapest storage ($0.00099/GB/month), maintains tape abstraction backup software expects. Cost comparison: Glacier Deep Archive $0.00099/GB vs Glacier Flexible Retrieval $0.004/GB vs Standard $0.023/GB, for 500TB: Deep Archive ~$500/month vs Standard ~$11,500/month. Migration process: (1) Deploy Tape Gateway in on-premises or AWS (EC2), (2) Configure backup software to use VTL, (3) Begin backing up to virtual tapes (new backups), (4) Ship historical tapes via Snowball to AWS, (5) AWS imports to Glacier Deep Archive, (6) Catalog merged in Tape Gateway. Option A manual process too complex. Option B Snowball good but doesn't maintain tape abstraction. Option D Standard storage too expensive. Tape Gateway retrieval: Standard retrieval (12-48 hours for Glacier Deep Archive), Expedited retrieval (3-5 hours for Glacier Flexible), maintains tape catalog for browse without retrieval."
        }
      ]
    },
    {
      "filename": "domain-4-migration-modernization-all.json",
      "domain": "Domain 4: Accelerate Workload Migration and Modernization",
      "task": "task_4.3_architecture_design",
      "taskKey": "task_4.3_architecture_design",
      "question_count": 10,
      "questions": [
        {
          "id": "D4-T4.3-Q1",
          "question": "Monolithic application (3-tier: presentation, business logic, data) migrated to AWS on EC2. Now refactoring to microservices. What's the recommended decomposition strategy to minimize risk?",
          "options": [
            "Strangler Fig pattern: incrementally extract services while monolith runs, routing traffic gradually to new services",
            "Big Bang rewrite: rebuild entire application as microservices simultaneously",
            "Database-first split: divide database first, then split application",
            "Keep monolith, just containerize it"
          ],
          "correctAnswer": 0,
          "explanation": "Strangler Fig pattern minimizes risk during refactoring: (1) Identify bounded contexts (business capabilities that can be independent services), (2) Extract service for one capability (e.g., payment processing), (3) Deploy new service alongside monolith, (4) Use API Gateway or ALB to route traffic: new feature → microservice, existing feature → monolith, (5) Gradually migrate features to microservices, (6) Eventually, monolith 'strangled' - all traffic to microservices. Benefits: Incremental (low risk), Testable (validate each extraction), Rollback capability. Option B (Big Bang) high-risk - if anything fails, everything fails. Option C (database-first) risky - application and database tightly coupled, splitting database first breaks application. Option D (containerize) improves deployment but doesn't achieve microservices benefits. Strangler Fig steps: Prioritize services (high value, low dependency), Define contracts (APIs between services), Implement new service, Route subset of traffic, Monitor, Expand. Tools: AWS App Mesh (service mesh), API Gateway (routing), ECS/EKS (container orchestration), DynamoDB (per-service databases)."
        },
        {
          "id": "D4-T4.3-Q2",
          "question": "Application uses batch processing jobs running nightly on EC2 (8 hours). Jobs are fault-tolerant. AWS migration should optimize cost. What's the BEST compute choice?",
          "options": [
            "On-Demand EC2 instances for predictable pricing",
            "EC2 Spot Instances with Spot Fleet for up to 90% cost savings",
            "Lambda functions for serverless processing",
            "ECS Fargate for managed containers"
          ],
          "correctAnswer": 1,
          "explanation": "EC2 Spot Instances optimal for fault-tolerant batch workloads: Spot pricing up to 90% discount vs On-Demand. Spot Fleet configuration: (1) Define instance types (multiple types for availability), (2) Target capacity (e.g., 20 instances), (3) Allocation strategy (lowest price, diversified), (4) Spot interruption handling (checkpointing). For batch processing: implement checkpointing (save progress periodically), Spot interruption handling (2-minute warning, save state), Job queue (SQS) for work distribution, Auto Scaling based on queue depth. Option A (On-Demand) most expensive for long-running jobs. Option C (Lambda) has 15-minute max execution time - unsuitable for 8-hour jobs. Option D (Fargate) more expensive than Spot EC2 for long-duration workloads. AWS Batch service simplifies: job queues, compute environments (Spot, On-Demand, Fargate), job dependencies, automatic retries. Batch job patterns: array jobs (parallel processing), multi-node jobs (MPI), GPU jobs (ML training). Spot best practices: multiple instance types (flexibility), checkpointing (fault tolerance), Spot Fleet (automatic replacement), monitoring (Spot interruption rate)."
        },
        {
          "id": "D4-T4.3-Q3",
          "question": "Real-time analytics application processes IoT sensor data (100,000 messages/second). Currently batch processes data hourly on-premises. AWS migration should provide real-time insights. Which architecture is MOST appropriate?",
          "options": [
            "IoT Core → Kinesis Data Streams → Lambda → DynamoDB → QuickSight",
            "IoT Core → SQS → EC2 batch processing → RDS",
            "IoT Core → S3 → EMR batch processing → Redshift",
            "IoT Core → Kinesis Data Firehose → S3 → Athena"
          ],
          "correctAnswer": 0,
          "explanation": "Real-time architecture with Kinesis: (1) AWS IoT Core ingests sensor data (MQTT, HTTPS), (2) IoT Rules route to Kinesis Data Streams (scales to millions msg/sec), (3) Lambda or Kinesis Data Analytics processes streams in real-time (aggregations, filtering, enrichment), (4) DynamoDB stores processed results for low-latency queries, (5) QuickSight dashboards visualize real-time metrics. This achieves second-level latency vs hourly batch. Option B (SQS + batch) still batch processing - not real-time. Option C (S3 + EMR) batch analytics. Option D (Firehose + Athena) near real-time but has minute-level delays (Firehose buffers), query latency (Athena) - not suitable for real-time dashboards. Kinesis Data Streams: shard-based scaling, sub-second latency, ordered records per partition key. Use cases: real-time dashboards, alerting, fraud detection, clickstream analytics. Alternative real-time stack: Kafka on MSK (Managed Streaming for Kafka) for Kafka ecosystem, Kinesis Data Analytics with SQL for stream processing, Amazon Timestream for time-series data, Lambda for event-driven processing. Performance: Kinesis shard = 1MB/s ingress or 1000 records/s, Lambda concurrency = shards × parallelization factor (up to 10)."
        },
        {
          "id": "D4-T4.3-Q4",
          "question": "Microservices architecture on ECS requires service-to-service communication with mutual TLS, traffic management, and observability. Which AWS service provides these capabilities?",
          "options": [
            "Application Load Balancer with HTTPS",
            "AWS App Mesh for service mesh capabilities with Envoy proxy sidecars",
            "API Gateway for service routing",
            "Direct service-to-service HTTP calls"
          ],
          "correctAnswer": 1,
          "explanation": "AWS App Mesh provides service mesh for microservices: App Mesh capabilities: Service discovery (integrates with Cloud Map, Kubernetes), traffic management (weighted routing, retries, timeouts), observability (metrics to CloudWatch, traces to X-Ray), mutual TLS (mTLS between services), health checks, circuit breakers. How it works: Envoy proxy sidecar deployed alongside each service task, proxies intercept all network traffic, enforce policies (mTLS, routing), emit metrics and traces. For this scenario (microservices needing mTLS + traffic management): App Mesh configures Envoy sidecars automatically, enables zero-trust networking (mTLS service-to-service), provides traffic shaping (canary deployments, retries), observability built-in (CloudWatch metrics, X-Ray traces). App Mesh resources: Virtual services (logical service names), virtual nodes (actual service deployments on ECS/EKS/EC2), virtual routers (route traffic based on rules), virtual gateways (ingress/egress). Deployment example: ECS task definition includes Envoy sidecar container, application container configured to route through Envoy (localhost proxy), App Mesh configures Envoy policies centrally. Option A (ALB) handles ingress (external to services) but not service-to-service mesh. Option C (API Gateway) for external APIs, not internal mesh. Option D (direct calls) no traffic management or mTLS enforcement. App Mesh vs alternatives: App Mesh: AWS-managed control plane, works across ECS/EKS/EC2, CloudWatch/X-Ray integration. Istio on EKS: Self-managed, Kubernetes-only, broader ecosystem. Consul: Service discovery + mesh, self-managed."
        },
        {
          "id": "D4-T4.3-Q5",
          "question": "Migrated monolithic database to AWS. Now splitting into microservice databases. Each service needs own database but some queries need data from multiple services. What pattern addresses cross-service queries?",
          "options": [
            "Keep single shared database for all services",
            "API composition pattern: services expose APIs, orchestrator queries multiple services and aggregates results",
            "Distributed transactions across service databases",
            "Database replication from all services to central query database"
          ],
          "correctAnswer": 1,
          "explanation": "API composition for cross-service queries in microservices: Microservices database patterns: Database per service: Each service owns its database schema, services expose APIs for data access, no direct database access between services. For cross-service queries: API composition: Orchestrator (API Gateway Lambda, GraphQL server, BFF pattern) queries multiple services via APIs, aggregates results in application layer, returns combined response. CQRS (Command Query Responsibility Segregation): Services publish events on data changes, read-optimized view database subscribes to events, aggregates data for queries, separates write model (individual services) from read model (aggregated). For this scenario (need cross-service queries after database split): API composition for simple queries (query 2-3 services, aggregate in code), CQRS + event sourcing for complex analytics (materialized views updated via events), supports microservice independence while enabling cross-service queries. Example: Order service has orders DB, Customer service has customers DB, Order details query: query both services APIs, join in application layer, return combined result. Trade-offs: API composition: simple, real-time data, can be slow if many services, network chattiness. CQRS: complex setup, eventual consistency, optimized for read-heavy. Option A (shared database) violates microservices principle (tight coupling). Option C (distributed transactions) complex, poor performance, avoided in microservices. Option D (replication) creates data copies but needs change propagation mechanism (better as CQRS event-driven)."
        },
        {
          "id": "D4-T4.3-Q6",
          "question": "E-commerce architecture processes orders via queue. Orders must be processed exactly once in correct sequence per customer. High throughput (5000 orders/sec) with thousands of customers. What architecture?",
          "options": [
            "SQS Standard queue (at-least-once delivery, best-effort ordering)",
            "SQS FIFO queue with message group ID = customer ID for partitioned ordering and deduplication",
            "Kinesis Data Streams with customer ID as partition key",
            "DynamoDB with conditional writes"
          ],
          "correctAnswer": 1,
          "explanation": "SQS FIFO with message grouping for partitioned exactly-once ordering: SQS FIFO capabilities: Exactly-once processing (deduplication based on MessageDeduplicationId), ordering guarantee within message group (MessageGroupId), high throughput mode (3000 msg/sec per action, 30K with batching). For this scenario (exactly-once, ordered per customer, 5000 msg/sec total): Use MessageGroupId = customer_id (ordering per customer, not global), enables parallel processing (different consumers handle different customers), 5000 msg/sec total across all groups (within FIFO high throughput limits), exactly-once via deduplication. Architecture: Producer sends to FIFO queue with MessageGroupId=customer123, MessageDeduplicationId=order456 (or content-based), Consumer Lambda processes orders, maintains ordering per customer group, different customers processed in parallel (different message groups). SQS FIFO ordering semantics: Within message group: strict ordering (customer123's orders processed in sequence), across message groups: no ordering guarantee (customer123 and customer456 orders process in parallel), this enables parallelism while maintaining per-customer ordering. Option A (Standard) at-least-once (duplicates possible), best-effort ordering (not guaranteed). Option C (Kinesis) works but more complex (Lambda needs to track sequence numbers), SQS FIFO simpler for this use case. Option D (DynamoDB) not a queue. When to use SQS FIFO: need exactly-once + ordering, partitioned workload (message groups), throughput <30K msg/sec. When to use Kinesis: need data replay, multiple consumers same stream, throughput >30K msg/sec."
        },
        {
          "id": "D4-T4.3-Q7",
          "question": "Data lake architecture on S3 with raw data, processed data, and curated data layers. Need to catalog data, manage access controls, and enable athena/redshift queries. Which AWS service provides centralized governance?",
          "options": [
            "S3 bucket policies only",
            "AWS Lake Formation for data lake governance, catalog, and fine-grained access control",
            "IAM policies only",
            "AWS Glue Data Catalog only"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Lake Formation for data lake governance: Lake Formation capabilities: Data catalog (built on Glue Data Catalog - tables, schemas, metadata), fine-grained access control (column-level, row-level security), data ingestion (blueprints for common sources), data transformation (ETL workflows), centralized permissions (across Athena, Redshift Spectrum, EMR). For this scenario (S3 data lake with governance needs): Lake Formation registers S3 locations as data lake, catalogs datasets (tables, partitions), defines permissions (database/table/column level), enforces access when queried via Athena/Redshift. Permission model: Grant permissions in Lake Formation (not IAM), supports: database-level, table-level, column-level, row-level filtering. Athena/Redshift query against Lake Formation catalog, Lake Formation enforces permissions, returns only authorized data. Data lake layers with Lake Formation: Raw layer (bronze): ingest from sources, register in Lake Formation, grant read to data engineers. Processed layer (silver): cleaned and transformed, grant read to analysts. Curated layer (gold): business-ready, grant read to business users, column-level security (hide PII from some users). Option A/C (S3/IAM policies) bucket-level only, no column/row filtering, no catalog. Option D (Glue Catalog) catalogs data but no fine-grained access control enforcement. Lake Formation vs alternatives: Lake Formation: Centralized governance, fine-grained access, AWS analytics integration. AWS Glue only: Catalog and ETL, no access control. Third-party (Collibra, Alation): Broader governance, multi-cloud, more complex. Use Lake Formation when: Building S3 data lake, need column/row level security, using Athena/Redshift/EMR."
        },
        {
          "id": "D4-T4.3-Q8",
          "question": "Containerized application on ECS Fargate scales based on CPU. During traffic spikes, tasks scale but new tasks take 2 minutes to start (container image pull + app initialization). How to improve responsiveness?",
          "options": [
            "Use ECS Service Auto Scaling with target tracking on custom application-ready metric instead of CPU",
            "Pre-scale before expected traffic using scheduled scaling + reduce container startup time with smaller images",
            "Increase CPU threshold for scaling",
            "Switch to EC2-based ECS for faster startup"
          ],
          "correctAnswer": 1,
          "explanation": "Pre-scaling and startup optimization for Fargate responsiveness: Scaling challenges with slow startup: Reactive scaling (CPU-based) starts scaling after load increases, 2-minute startup = capacity lags demand, users experience latency during ramp-up. Solutions: (1) Pre-scaling: Scheduled scaling before predictable traffic (daily patterns), Target tracking with predictive scaling (if available for ECS). Step scaling with CloudWatch alarm on queue depth (leading indicator). (2) Reduce startup time: Optimize container image (multi-stage builds, smaller base images), Pre-pull images (ECS caches on underlying infrastructure), Application warm-up optimization (lazy loading, faster initialization). For this scenario (2-minute startup, traffic spikes): If predictable: scheduled scaling 5 minutes before peak, if unpredictable: reduce startup time to <30 seconds (image optimization), consider CPU threshold tuning (scale earlier at 50% vs 70%). Container image optimization: Use slim base images (alpine, distroless), multi-stage builds (build dependencies not in final image), layer caching (frequently changing layers last), example: 500MB image → 50MB = faster pull. ECS/Fargate startup time components: Image pull (depends on image size), container initialization (app startup code), health check (until marked healthy). Option A (application-ready metric) improves accuracy but doesn't solve 2-minute lag. Option C (higher threshold) delays scaling further (worse). Option D (EC2 ECS) startup time similar (still pulls image). 2025 best practice: Predictive scaling (where available) + startup optimization."
        },
        {
          "id": "D4-T4.3-Q9",
          "question": "Event-driven architecture needs to process events from multiple sources (S3, DynamoDB Streams, custom applications). Need to route events to different Lambda functions based on event content. Which service?",
          "options": [
            "SNS with message filtering",
            "Amazon EventBridge with event patterns and multiple targets",
            "SQS with Lambda polling",
            "Direct Lambda invocation from each source"
          ],
          "correctAnswer": 1,
          "explanation": "Amazon EventBridge for centralized event routing: EventBridge capabilities: Event bus (central event router), event patterns (content-based filtering), multiple targets per rule (route to Lambda, SQS, Step Functions, etc.), schema registry (event structure documentation), archive and replay, cross-account event delivery. For this scenario (multiple sources, content-based routing): EventBridge centralized event bus receives from all sources (S3, DynamoDB Streams via Pipes, custom apps via PutEvents), rules with event patterns match content (e.g., {detail.type: ['order.created']}), routes to appropriate Lambda functions. Event routing examples: Rule 1: Pattern matches 'order.created' → routes to OrderProcessingLambda. Rule 2: Pattern matches 'inventory.low' → routes to InventoryAlertLambda. Rule 3: Pattern matches all events → routes to AuditLogLambda. Multiple targets: same event can match multiple rules, enables fan-out to multiple processors. EventBridge event sources: AWS services (100+ services emit events), custom applications (PutEvents API), SaaS integrations (Stripe, Shopify, etc.), EventBridge Pipes (DynamoDB Streams, Kinesis, SQS sources). Option A (SNS) message filtering works but less powerful than EventBridge patterns (SNS filters on attributes, EventBridge on full event content). Option C (SQS) requires polling, no content-based routing. Option D (direct invocation) tightly couples sources to functions. EventBridge vs SNS: EventBridge: Rich event patterns, schema registry, archive/replay, 100+ AWS integrations. SNS: Simpler pub/sub, message filtering, higher throughput (SNS FIFO 300 msg/sec, EventBridge 10K+ events/sec default). Use EventBridge for: complex event routing, AWS service integration, schema evolution. Use SNS for: simple fan-out, high-throughput pub/sub."
        },
        {
          "id": "D4-T4.3-Q10",
          "question": "Migrated web application to AWS Serverless (API Gateway + Lambda + DynamoDB). Load testing shows Lambda cold starts cause 2-3 second latency spikes. Application needs consistent <500ms response. What optimizations?",
          "options": [
            "Increase Lambda memory to reduce cold start time",
            "Use Lambda Provisioned Concurrency to keep functions warm + optimize function code for faster initialization",
            "Switch to ECS Fargate",
            "Add caching layer only"
          ],
          "correctAnswer": 1,
          "explanation": "Lambda Provisioned Concurrency eliminates cold starts: Cold start issue: Lambda creates new execution environment (container, runtime initialization), first invocation experiences latency (2-3 seconds for large packages/dependencies), subsequent invocations fast (<milliseconds on warm container). Solutions for consistent latency: (1) Provisioned Concurrency: keeps N functions initialized and warm, eliminates cold starts for provisioned instances, scales automatically when concurrency exceeds provisioned. (2) Function optimization: reduce deployment package size (remove unused dependencies), minimize initialization code (lazy load libraries), use runtime initialization outside handler (connection pools), use Lambda SnapStart (Java - instant cold starts). For this scenario (<500ms requirement, 2-3s cold start): provision 10-20 concurrent Lambdas (handles baseline traffic), Auto Scaling adds provisioned concurrency during peak, optimize code: lazy load, smaller packages, connection pool reuse. Provisioned Concurrency costs: charged for provisioned instances ($0.0000041667 per GB-second), plus invocation costs, trade-off: cost vs performance SLA. Code optimization techniques: minimize dependencies (tree-shaking, bundling), lazy loading (import libraries only when needed), global scope for reusable connections (database, HTTP clients), example: 200MB package → 20MB = faster cold start. Option A (memory increase) helps modestly but doesn't eliminate cold starts. Option C (Fargate) also has cold starts (task startup). Option D (caching) helps repeat requests but not cold start latency. Lambda cold start factors: Runtime (Python/Node fast, Java slow), package size (50MB vs 5MB), initialization code (database connections slow). 2025 optimization: Provisioned Concurrency + SnapStart (Java) + code optimization."
        }
      ]
    },
    {
      "filename": "domain-4-migration-modernization-all.json",
      "domain": "Domain 4: Accelerate Workload Migration and Modernization",
      "task": "task_4.4_modernization",
      "taskKey": "task_4.4_modernization",
      "question_count": 8,
      "questions": [
        {
          "id": "D4-T4.4-Q1",
          "question": "Application runs on EC2 with scheduled jobs (Lambda via CloudWatch Events can handle these better). Most functions are stateless, request-response pattern, <5 minute execution. What's the modernization opportunity?",
          "options": [
            "Migrate EC2 to Lambda functions for event-driven, serverless execution with automatic scaling and pay-per-use pricing",
            "Containerize the application using ECS",
            "Keep on EC2 but use Auto Scaling",
            "Migrate to Elastic Beanstalk"
          ],
          "correctAnswer": 0,
          "explanation": "Lambda modernization for suitable workloads: Current: EC2 running 24/7, pay for idle time, manual scaling. Lambda: event-driven execution (EventBridge schedules, API Gateway, S3 events), pay only for execution time (100ms granularity), automatic scaling (concurrent executions), no server management. For this scenario: scheduled jobs (EventBridge → Lambda), <5 min execution (within Lambda 15-min limit), stateless (Lambda paradigm). Benefits: cost savings (vs always-on EC2), simplified operations, high availability (Lambda managed by AWS). Consider Lambda when: stateless workloads, short duration (<15 min), event-driven triggers, variable load. Keep EC2 when: long-running (>15 min), stateful (persistent connections), specific OS requirements, GPU/high memory (>10GB). Option B (ECS) suitable for containerized apps but still requires cluster management. Option C (Auto Scaling) improves EC2 but still paying for servers. Option D (Elastic Beanstalk) PaaS simplification but still server-based. Lambda limitations: 15-minute max, 10GB memory max, /tmp storage (10GB), deployment package size (250MB unzipped). Modernization migration: identify stateless functions, containerize as Lambda deployment package, configure triggers (EventBridge, API Gateway), test concurrency limits, monitor CloudWatch metrics."
        },
        {
          "id": "D4-T4.4-Q2",
          "question": "Self-managed Kubernetes cluster on EC2 (10 worker nodes, multiple operators for logging, monitoring, service mesh). Operations team spends significant time on cluster upgrades, patching, and control plane HA. What's the modernization path?",
          "options": [
            "Migrate to Amazon EKS for managed Kubernetes control plane and integrated AWS services",
            "Migrate to ECS for AWS-native container orchestration",
            "Keep self-managed but automate with Infrastructure as Code",
            "Migrate to Lambda for serverless"
          ],
          "correctAnswer": 0,
          "explanation": "Amazon EKS modernization: EKS manages Kubernetes control plane (HA across 3 AZs, automatic upgrades, patching), integrates with AWS services (ALB/NLB ingress, EBS/EFS storage, IAM authentication, CloudWatch monitoring). Benefits vs self-managed: no control plane management, SLA-backed availability (99.95%), security (automatic security patches), AWS integrations (VPC networking, IAM). Operations team focuses on applications, not cluster infrastructure. For this scenario: 10 worker nodes become EKS-managed, service mesh (App Mesh or continue using existing), logging (CloudWatch Container Insights), monitoring (integrated with CloudWatch). Migration: create EKS cluster, migrate workloads (kubectl apply manifests), test, cutover. Option B (ECS) requires rewriting K8s manifests to ECS task definitions - significant effort if already Kubernetes. Option C (IaC) improves self-managed but doesn't eliminate operational burden. Option D (Lambda) for Kubernetes workloads is major refactoring. EKS features: Managed node groups (automatic patching, upgrades), Fargate for serverless pods, IRSA (IAM Roles for Service Accounts), EKS Add-ons (managed installation of VPC CNI, CoreDNS, kube-proxy). When to use EKS: existing Kubernetes workloads, multi-cloud (Kubernetes portable), need K8s API. When to use ECS: AWS-only, simpler container orchestration, tight AWS integration."
        },
        {
          "id": "D4-T4.4-Q3",
          "question": "Application uses Jenkins on EC2 for CI/CD. Jenkins server requires patching, plugin management, and often is underutilized. AWS-native modernization?",
          "options": [
            "Migrate to AWS CodePipeline, CodeBuild, and CodeDeploy for fully managed CI/CD without server management",
            "Run Jenkins on Elastic Beanstalk",
            "Containerize Jenkins on ECS",
            "Keep Jenkins but use Auto Scaling"
          ],
          "correctAnswer": 0,
          "explanation": "AWS CodePipeline + CodeBuild + CodeDeploy provides serverless CI/CD: CodePipeline (workflow orchestration), CodeBuild (build and test - runs in containers, scales automatically), CodeDeploy (deployment to EC2, ECS, Lambda with blue/green, canary). Benefits vs Jenkins: No server management (fully managed), pay per build minute (vs always-on Jenkins), integrated with AWS (IAM, CloudWatch, S3), automatic scaling. Migration: translate Jenkins pipeline to CodePipeline stages, Jenkinsfile to CodeBuild buildspec.yml, Jenkins deploy scripts to CodeDeploy appspec. Considerations: complex Jenkins pipelines may need phased migration, Jenkins plugins map to CodeBuild Docker images or Lambda functions, Jenkins artifacts migrate to S3. Option B/C (Beanstalk, ECS) still requires Jenkins management. Option D (Auto Scaling) doesn't solve operational burden. Alternative: GitHub Actions or GitLab CI/CD if using those platforms. AWS Developer Tools: CodeCommit (Git repository), CodeBuild (build service), CodeDeploy (deployment), CodePipeline (orchestration), CodeArtifact (artifact repository), CodeGuru (code review AI). When to modernize: reduce operational overhead, improve scalability, leverage AWS-native features. When to keep Jenkins: complex pipelines difficult to migrate, heavy Jenkins plugin dependence, multi-cloud (Jenkins portable)."
        },
        {
          "id": "D4-T4.4-Q4",
          "question": "Traditional RDS MySQL database currently handles 10,000 reads/sec with complex queries. Considering modernization to Aurora. What are the key Aurora advantages for this workload?",
          "options": [
            "Aurora MySQL provides up to 5x throughput vs RDS MySQL, storage auto-scales, 15 read replicas, faster failover",
            "Aurora is cheaper than RDS MySQL",
            "Aurora eliminates need for read replicas",
            "Aurora MySQL doesn't support InnoDB"
          ],
          "correctAnswer": 0,
          "explanation": "Aurora MySQL modernization benefits: Performance: Up to 5x throughput vs standard MySQL (SSD-backed virtualized storage layer), 15 low-latency read replicas (vs 5 for RDS MySQL), millisecond replica lag (vs seconds for RDS). Storage: Auto-scales from 10GB to 128TB automatically, 6-way storage replication across 3 AZs, self-healing storage (automatic block repair). Availability: <30 second failover to replica (vs 1-2 minutes RDS Multi-AZ), continues operating with loss of 2 copies (writes) or 3 copies (reads), backtrack (rewind to point in time without restore). For this scenario (10,000 reads/sec, complex queries): 15 read replicas distribute query load, faster storage layer improves query performance, auto-scaling storage eliminates capacity planning. Migration from RDS MySQL to Aurora: Create Aurora replica of RDS instance (replication lag until synchronized), promote Aurora replica to standalone cluster when ready, cutover application connections to Aurora, minimal downtime (<5 minutes). Aurora Global Database (additional benefit): cross-region replication (<1 second lag), disaster recovery with RPO <1 second, RTO <1 minute. Cost consideration: Aurora storage billed per GB used (vs RDS provisioned), Aurora I/O costs (can use Aurora I/O-Optimized for predictable pricing), often cost-neutral or lower TCO when considering performance and HA. Option B incorrect - Aurora not necessarily cheaper (depends on workload). Option C incorrect - read replicas still needed for scale. Option D incorrect - Aurora uses InnoDB. When to migrate to Aurora: need >5 read replicas, need fast failover (<30s), high read throughput, automatic storage scaling. When to keep RDS: cost-sensitive workload (low I/O), don't need additional replicas."
        },
        {
          "id": "D4-T4.4-Q5",
          "question": "Application uses self-managed Redis on EC2 for caching with manual configuration, patching, and scaling. Modernization to ElastiCache Redis provides what operational benefits?",
          "options": [
            "ElastiCache Redis provides automatic failover, automated patching, backup/restore, and Redis Cluster mode for horizontal scaling",
            "ElastiCache is incompatible with Redis protocol",
            "ElastiCache requires manual patching",
            "ElastiCache doesn't support Redis data structures"
          ],
          "correctAnswer": 0,
          "explanation": "ElastiCache Redis modernization benefits: Operational: Automated patching (engine version upgrades in maintenance window), automatic failover (primary to replica <60 seconds), automated backups and point-in-time restore, CloudWatch monitoring integration. Scalability: Cluster mode for horizontal scaling (up to 500 shards), up to 5 replicas per shard, online resharding (add/remove shards without downtime). Compatibility: 100% Redis compatible (all data structures, commands), supports Redis 6.x and 7.x features, drop-in replacement for self-managed Redis. For this scenario (self-managed Redis operational burden): ElastiCache eliminates: manual patching (AWS handles), failover scripting (automatic with Multi-AZ), monitoring setup (CloudWatch integration), backup automation (ElastiCache handles). Migration from EC2 Redis to ElastiCache: Create ElastiCache cluster (same Redis version), use Redis MIGRATE command or third-party tool (riot-redis), or online migration service, cutover application to ElastiCache endpoint. ElastiCache features: Redis AUTH for authentication, encryption at-rest (KMS), encryption in-transit (TLS), VPC isolation, IAM authentication (Redis 7.x). Cost comparison: ElastiCache vs self-managed: ElastiCache pay per node-hour, self-managed pay for EC2 + operational labor, generally ElastiCache lower TCO when factoring operations. Option B/D incorrect - fully Redis compatible. Option C incorrect - automated patching. When to use ElastiCache: reduce operational overhead, need automated failover, want managed backups. When self-manage: specific Redis config not supported, extreme cost sensitivity, need complete control. Alternative: Amazon MemoryDB for Redis for durable Redis with Multi-AZ strong consistency."
        },
        {
          "id": "D4-T4.4-Q6",
          "question": "Company runs Hadoop clusters on-premises for batch processing (10TB data processed nightly). Considering modernization. What's AWS alternative that reduces operational overhead?",
          "options": [
            "Self-managed Hadoop on EC2",
            "Amazon EMR with auto-scaling and Spot Instances, or AWS Glue for serverless ETL",
            "RDS for data processing",
            "Lambda for batch processing"
          ],
          "correctAnswer": 1,
          "explanation": "EMR and Glue as Hadoop modernization options: Amazon EMR (Elastic MapReduce): Managed Hadoop framework (Hadoop, Spark, Hive, Presto), auto-scaling (scale based on workload), Spot Instances integration (70-90% cost savings), transient clusters (spin up for job, terminate after), S3 as persistent storage (EMRFS). AWS Glue: Serverless ETL (no cluster management), auto-scaling (automatic capacity), pay per DPU-hour (Data Processing Unit), integrates with Glue Data Catalog, supports Spark and Python. For this scenario (10TB nightly batch processing): EMR approach: spin up cluster nightly (transient), process data from S3, use Spot Instances (cost-optimized), terminate cluster after job, no cluster management when idle. Glue approach: define Glue job (PySpark or Scala), schedule with EventBridge, Glue auto-scales resources, serverless (no infrastructure). Migration from on-premises Hadoop: Migrate data to S3 (DataSync or Snowball), port Hadoop jobs to EMR (mostly compatible) or Glue (some refactoring), test performance and cost, cutover batch scheduling to AWS. EMR vs Glue decision: EMR when: need specific Hadoop ecosystem tools (Hive, Presto, HBase), complex Spark jobs requiring tuning, want cluster control. Glue when: standard ETL workloads, want serverless simplicity, Python/Spark based jobs. Cost optimization: Transient EMR clusters (only pay during job runtime), Spot Instances for EMR (steep discounts), S3 storage cheaper than HDFS on EBS. Option A self-managed defeats modernization purpose. Option C/D inappropriate for big data batch. Additional AWS big data services: Redshift for data warehousing, Athena for SQL on S3 (serverless queries), Kinesis for streaming data."
        },
        {
          "id": "D4-T4.4-Q7",
          "question": "Windows applications use on-premises Active Directory for authentication. After migrating to AWS, need to maintain AD authentication. What modernization approach balances management overhead and functionality?",
          "options": [
            "Self-managed AD on EC2",
            "AWS Managed Microsoft AD for fully managed AD with trust relationships to on-premises",
            "Eliminate AD entirely and use IAM",
            "Azure AD (not AWS service)"
          ],
          "correctAnswer": 1,
          "explanation": "AWS Managed Microsoft AD for AD modernization: AWS Managed Microsoft AD (Directory Service): Actual Microsoft AD (not compatible alternative), fully managed by AWS (patching, backups, monitoring), multi-AZ deployment for HA, trust relationships with on-premises AD (hybrid scenarios). Capabilities: Standard AD features (Group Policy, LDAP, Kerberos, NTLM), schema extensions, trusts (one-way, two-way) with on-premises AD, integrates with AWS services (RDS SQL Server, FSx Windows, WorkSpaces). For this scenario (Windows apps need AD after migration): Managed Microsoft AD in AWS (no server management), establish trust with on-premises AD (hybrid), migrated applications authenticate against AWS-managed AD, users synchronized from on-premises (or use trust for lookup). Migration approaches: Hybrid: trust relationship between on-premises AD and AWS Managed AD, users/groups remain in on-premises, AWS applications trust on-premises AD. Cloud-only: migrate users/groups to AWS Managed AD, decommission on-premises AD eventually. AD Connector (alternative): proxy to on-premises AD (no data in AWS), suitable for simple authentication passthrough, doesn't support all AD features. Managed AD sizes: Standard: up to 5,000 users, 30,000 directory objects, Enterprise: up to 500,000+ directory objects. Option A (self-managed) operational overhead of patch, backup, HA configuration. Option C (eliminate AD) breaking change for Windows applications. Option D (Azure AD) not AWS service, different purpose (SaaS SSO vs traditional AD). When to use Managed AD: Windows workloads requiring traditional AD, hybrid scenarios (on-premises + AWS), need AD features (GP, trusts). When to use IAM: cloud-native apps, REST API authentication, AWS service access."
        },
        {
          "id": "D4-T4.4-Q8",
          "question": "Self-managed monitoring stack (Prometheus, Grafana on EC2) for containerized applications. Considering modernization to reduce operational overhead. What AWS managed alternative?",
          "options": [
            "Amazon Managed Service for Prometheus (AMP) and Amazon Managed Grafana (AMG)",
            "CloudWatch only (doesn't support Prometheus)",
            "Keep self-managed stack",
            "Third-party SaaS (not AWS service)"
          ],
          "correctAnswer": 0,
          "explanation": "Amazon Managed Service for Prometheus (AMP) and Managed Grafana (AMG): AMP (Amazon Managed Prometheus): Prometheus-compatible monitoring service, serverless (automatic scaling), secure (IAM integration, encryption), HA (Multi-AZ), integrates with EKS, ECS, EC2, Lambda. AMG (Amazon Managed Grafana): Fully managed Grafana service, pre-integrated with AMP, CloudWatch, X-Ray, connects to multiple data sources, user management via SSO (SAML), built-in dashboards. For this scenario (self-managed Prometheus/Grafana operational burden): AMP replaces self-managed Prometheus (no server management, auto-scaling, HA), AMG replaces self-managed Grafana (managed service, SSO, upgrades handled), integrates seamlessly (AMP as data source for AMG). Migration from self-managed: Configure Prometheus remote write to AMP workspace, gradual cutover (run both in parallel), import Grafana dashboards to AMG, update data sources to AMP, decommission self-managed. Architecture: EKS/ECS with Prometheus agent (scrapes metrics), agent sends to AMP via remote write, AMG queries AMP for visualization, users access AMG dashboards. Benefits: No server patching (fully managed), automatic scaling (no capacity planning), integrated security (IAM, encryption), pay-per-use (no idle costs), highly available (Multi-AZ). Cost model: AMP: per metric sample ingested and stored, per query sample processed, AMG: per active user per month. Option B CloudWatch alternative but not Prometheus-compatible (different query language). Self-managed (Option C) defeats modernization goal. When to use AMP/AMG: want Prometheus compatibility, reduce operational overhead, EKS/ECS monitoring. When self-manage: need bleeding-edge Prometheus features, extreme cost sensitivity, specific plugins not available."
        }
      ]
    }
  ]
}